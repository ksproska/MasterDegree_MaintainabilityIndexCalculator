<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MI Score and Java Method Table with Dynamic Coloring</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
<table id="methodTable">
    <thead>
    <tr>
        <th>MI</th>
        <th>HV</th>
        <th>CC</th>
        <th>LOC</th>
        <th>Method Code</th>
    </tr>
    </thead>
    <tbody>
<tr>
    <td>2</td><td>9095.72</td><td>94</td><td>401</td>
    <td><div class="code-container"><pre><code class="language-java">public int run(String[] argv) throws Exception {
    int exitCode = -1;
    if (argv.length &lt; 1) {
        displayUsage(&quot;&quot;);
        return exitCode;
    }
    String cmd = argv[0];
    String submitJobFile = null;
    String jobid = null;
    String taskid = null;
    String historyFileOrJobId = null;
    String historyOutFile = null;
    String historyOutFormat = HistoryViewer.HUMAN_FORMAT;
    String counterGroupName = null;
    String counterName = null;
    JobPriority jp = null;
    String taskType = null;
    String taskState = null;
    int fromEvent = 0;
    int nEvents = 0;
    int jpvalue = 0;
    String configOutFile = null;
    boolean getStatus = false;
    boolean getCounter = false;
    boolean killJob = false;
    boolean listEvents = false;
    boolean viewHistory = false;
    boolean viewAllHistory = false;
    boolean listJobs = false;
    boolean listAllJobs = false;
    boolean listActiveTrackers = false;
    boolean listBlacklistedTrackers = false;
    boolean displayTasks = false;
    boolean killTask = false;
    boolean failTask = false;
    boolean setJobPriority = false;
    boolean logs = false;
    boolean downloadConfig = false;
    if (&quot;-submit&quot;.equals(cmd)) {
        if (argv.length != 2) {
            displayUsage(cmd);
            return exitCode;
        }
        submitJobFile = argv[1];
    } else if (&quot;-status&quot;.equals(cmd)) {
        if (argv.length != 2) {
            displayUsage(cmd);
            return exitCode;
        }
        jobid = argv[1];
        getStatus = true;
    } else if (&quot;-counter&quot;.equals(cmd)) {
        if (argv.length != 4) {
            displayUsage(cmd);
            return exitCode;
        }
        getCounter = true;
        jobid = argv[1];
        counterGroupName = argv[2];
        counterName = argv[3];
    } else if (&quot;-kill&quot;.equals(cmd)) {
        if (argv.length != 2) {
            displayUsage(cmd);
            return exitCode;
        }
        jobid = argv[1];
        killJob = true;
    } else if (&quot;-set-priority&quot;.equals(cmd)) {
        if (argv.length != 3) {
            displayUsage(cmd);
            return exitCode;
        }
        jobid = argv[1];
        try {
            jp = JobPriority.valueOf(argv[2]);
        } catch (IllegalArgumentException iae) {
            try {
                jpvalue = Integer.parseInt(argv[2]);
            } catch (NumberFormatException ne) {
                LOG.info(&quot;Error number format: &quot;, ne);
                displayUsage(cmd);
                return exitCode;
            }
        }
        setJobPriority = true;
    } else if (&quot;-events&quot;.equals(cmd)) {
        if (argv.length != 4) {
            displayUsage(cmd);
            return exitCode;
        }
        jobid = argv[1];
        fromEvent = Integer.parseInt(argv[2]);
        nEvents = Integer.parseInt(argv[3]);
        listEvents = true;
    } else if (&quot;-history&quot;.equals(cmd)) {
        viewHistory = true;
        if (argv.length &lt; 2 || argv.length &gt; 7) {
            displayUsage(cmd);
            return exitCode;
        }
        int index = 1;
        if (&quot;all&quot;.equals(argv[index])) {
            index++;
            viewAllHistory = true;
            if (argv.length == 2) {
                displayUsage(cmd);
                return exitCode;
            }
        }
        historyFileOrJobId = argv[index++];
        if (argv.length &gt; index + 1 &amp;&amp; &quot;-outfile&quot;.equals(argv[index])) {
            index++;
            historyOutFile = argv[index++];
        }
        if (argv.length &gt; index + 1 &amp;&amp; &quot;-format&quot;.equals(argv[index])) {
            index++;
            historyOutFormat = argv[index++];
        }
        if (argv.length &gt; index) {
            displayUsage(cmd);
            return exitCode;
        }
    } else if (&quot;-list&quot;.equals(cmd)) {
        if (argv.length != 1 &amp;&amp; !(argv.length == 2 &amp;&amp; &quot;all&quot;.equals(argv[1]))) {
            displayUsage(cmd);
            return exitCode;
        }
        if (argv.length == 2 &amp;&amp; &quot;all&quot;.equals(argv[1])) {
            listAllJobs = true;
        } else {
            listJobs = true;
        }
    } else if (&quot;-kill-task&quot;.equals(cmd)) {
        if (argv.length != 2) {
            displayUsage(cmd);
            return exitCode;
        }
        killTask = true;
        taskid = argv[1];
    } else if (&quot;-fail-task&quot;.equals(cmd)) {
        if (argv.length != 2) {
            displayUsage(cmd);
            return exitCode;
        }
        failTask = true;
        taskid = argv[1];
    } else if (&quot;-list-active-trackers&quot;.equals(cmd)) {
        if (argv.length != 1) {
            displayUsage(cmd);
            return exitCode;
        }
        listActiveTrackers = true;
    } else if (&quot;-list-blacklisted-trackers&quot;.equals(cmd)) {
        if (argv.length != 1) {
            displayUsage(cmd);
            return exitCode;
        }
        listBlacklistedTrackers = true;
    } else if (&quot;-list-attempt-ids&quot;.equals(cmd)) {
        if (argv.length != 4) {
            displayUsage(cmd);
            return exitCode;
        }
        jobid = argv[1];
        taskType = argv[2];
        taskState = argv[3];
        displayTasks = true;
        if (!taskTypes.contains(org.apache.hadoop.util.StringUtils.toUpperCase(taskType))) {
            System.out.println(&quot;Error: Invalid task-type: &quot; + taskType);
            displayUsage(cmd);
            return exitCode;
        }
        if (!taskStates.contains(org.apache.hadoop.util.StringUtils.toLowerCase(taskState))) {
            System.out.println(&quot;Error: Invalid task-state: &quot; + taskState);
            displayUsage(cmd);
            return exitCode;
        }
    } else if (&quot;-logs&quot;.equals(cmd)) {
        if (argv.length == 2 || argv.length == 3) {
            logs = true;
            jobid = argv[1];
            if (argv.length == 3) {
                taskid = argv[2];
            } else {
                taskid = null;
            }
        } else {
            displayUsage(cmd);
            return exitCode;
        }
    } else if (&quot;-config&quot;.equals(cmd)) {
        downloadConfig = true;
        if (argv.length != 3) {
            displayUsage(cmd);
            return exitCode;
        }
        jobid = argv[1];
        configOutFile = argv[2];
    } else {
        displayUsage(cmd);
        return exitCode;
    }
    cluster = createCluster();
    try {
        if (submitJobFile != null) {
            Job job = Job.getInstance(new JobConf(submitJobFile));
            job.submit();
            System.out.println(&quot;Created job &quot; + job.getJobID());
            exitCode = 0;
        } else if (getStatus) {
            Job job = getJob(JobID.forName(jobid));
            if (job == null) {
                System.out.println(&quot;Could not find job &quot; + jobid);
            } else {
                Counters counters = job.getCounters();
                System.out.println();
                System.out.println(job);
                if (counters != null) {
                    System.out.println(counters);
                } else {
                    System.out.println(&quot;Counters not available. Job is retired.&quot;);
                }
                exitCode = 0;
            }
        } else if (getCounter) {
            Job job = getJob(JobID.forName(jobid));
            if (job == null) {
                System.out.println(&quot;Could not find job &quot; + jobid);
            } else {
                Counters counters = job.getCounters();
                if (counters == null) {
                    System.out.println(&quot;Counters not available for retired job &quot; + jobid);
                    exitCode = -1;
                } else {
                    System.out.println(getCounter(counters, counterGroupName, counterName));
                    exitCode = 0;
                }
            }
        } else if (killJob) {
            Job job = getJob(JobID.forName(jobid));
            if (job == null) {
                System.out.println(&quot;Could not find job &quot; + jobid);
            } else {
                JobStatus jobStatus = job.getStatus();
                if (jobStatus.getState() == JobStatus.State.FAILED) {
                    System.out.println(&quot;Could not mark the job &quot; + jobid + &quot; as killed, as it has already failed.&quot;);
                    exitCode = -1;
                } else if (jobStatus.getState() == JobStatus.State.KILLED) {
                    System.out.println(&quot;The job &quot; + jobid + &quot; has already been killed.&quot;);
                    exitCode = -1;
                } else if (jobStatus.getState() == JobStatus.State.SUCCEEDED) {
                    System.out.println(&quot;Could not kill the job &quot; + jobid + &quot;, as it has already succeeded.&quot;);
                    exitCode = -1;
                } else {
                    job.killJob();
                    System.out.println(&quot;Killed job &quot; + jobid);
                    exitCode = 0;
                }
            }
        } else if (setJobPriority) {
            Job job = getJob(JobID.forName(jobid));
            if (job == null) {
                System.out.println(&quot;Could not find job &quot; + jobid);
            } else {
                if (jp != null) {
                    job.setPriority(jp);
                } else {
                    job.setPriorityAsInteger(jpvalue);
                }
                System.out.println(&quot;Changed job priority.&quot;);
                exitCode = 0;
            }
        } else if (viewHistory) {
            if (historyFileOrJobId.endsWith(&quot;.jhist&quot;)) {
                viewHistory(historyFileOrJobId, viewAllHistory, historyOutFile, historyOutFormat);
                exitCode = 0;
            } else {
                Job job = getJob(JobID.forName(historyFileOrJobId));
                if (job == null) {
                    System.out.println(&quot;Could not find job &quot; + jobid);
                } else {
                    String historyUrl = job.getHistoryUrl();
                    if (historyUrl == null || historyUrl.isEmpty()) {
                        System.out.println(&quot;History file for job &quot; + historyFileOrJobId + &quot; is currently unavailable.&quot;);
                    } else {
                        viewHistory(historyUrl, viewAllHistory, historyOutFile, historyOutFormat);
                        exitCode = 0;
                    }
                }
            }
        } else if (listEvents) {
            Job job = getJob(JobID.forName(jobid));
            if (job == null) {
                System.out.println(&quot;Could not find job &quot; + jobid);
            } else {
                listEvents(job, fromEvent, nEvents);
                exitCode = 0;
            }
        } else if (listJobs) {
            listJobs(cluster);
            exitCode = 0;
        } else if (listAllJobs) {
            listAllJobs(cluster);
            exitCode = 0;
        } else if (listActiveTrackers) {
            listActiveTrackers(cluster);
            exitCode = 0;
        } else if (listBlacklistedTrackers) {
            listBlacklistedTrackers(cluster);
            exitCode = 0;
        } else if (displayTasks) {
            Job job = getJob(JobID.forName(jobid));
            if (job == null) {
                System.out.println(&quot;Could not find job &quot; + jobid);
            } else {
                displayTasks(getJob(JobID.forName(jobid)), taskType, taskState);
                exitCode = 0;
            }
        } else if (killTask) {
            TaskAttemptID taskID = TaskAttemptID.forName(taskid);
            Job job = getJob(taskID.getJobID());
            if (job == null) {
                System.out.println(&quot;Could not find job &quot; + jobid);
            } else if (job.killTask(taskID, false)) {
                System.out.println(&quot;Killed task &quot; + taskid);
                exitCode = 0;
            } else {
                System.out.println(&quot;Could not kill task &quot; + taskid);
                exitCode = -1;
            }
        } else if (failTask) {
            TaskAttemptID taskID = TaskAttemptID.forName(taskid);
            Job job = getJob(taskID.getJobID());
            if (job == null) {
                System.out.println(&quot;Could not find job &quot; + jobid);
            } else if (job.killTask(taskID, true)) {
                System.out.println(&quot;Killed task &quot; + taskID + &quot; by failing it&quot;);
                exitCode = 0;
            } else {
                System.out.println(&quot;Could not fail task &quot; + taskid);
                exitCode = -1;
            }
        } else if (logs) {
            JobID jobID = JobID.forName(jobid);
            if (getJob(jobID) == null) {
                System.out.println(&quot;Could not find job &quot; + jobid);
            } else {
                try {
                    TaskAttemptID taskAttemptID = TaskAttemptID.forName(taskid);
                    LogParams logParams = cluster.getLogParams(jobID, taskAttemptID);
                    LogCLIHelpers logDumper = new LogCLIHelpers();
                    logDumper.setConf(getConf());
                    exitCode = logDumper.dumpAContainersLogs(logParams.getApplicationId(), logParams.getContainerId(), logParams.getNodeId(), logParams.getOwner());
                } catch (IOException e) {
                    if (e instanceof RemoteException) {
                        throw e;
                    }
                    System.out.println(e.getMessage());
                }
            }
        } else if (downloadConfig) {
            Job job = getJob(JobID.forName(jobid));
            if (job == null) {
                System.out.println(&quot;Could not find job &quot; + jobid);
            } else {
                String jobFile = job.getJobFile();
                if (jobFile == null || jobFile.isEmpty()) {
                    System.out.println(&quot;Config file for job &quot; + jobFile + &quot; could not be found.&quot;);
                } else {
                    Path configPath = new Path(jobFile);
                    FileSystem fs = FileSystem.get(getConf());
                    fs.copyToLocalFile(configPath, new Path(configOutFile));
                    exitCode = 0;
                }
            }
        }
    } catch (RemoteException re) {
        IOException unwrappedException = re.unwrapRemoteException();
        if (unwrappedException instanceof AccessControlException) {
            System.out.println(unwrappedException.getMessage());
        } else {
            throw re;
        }
    } finally {
        cluster.close();
    }
    return exitCode;
}
</code></pre></div></td>
</tr>
<tr>
    <td>6</td><td>2542.36</td><td>108</td><td>327</td>
    <td><div class="code-container"><pre><code class="language-java">public void incInvokedMethod(Method method) {
    switch(method.getName()) {
        case &quot;getBlockLocations&quot;:
            getBlockLocationsOps.incr();
            break;
        case &quot;getServerDefaults&quot;:
            getServerDefaultsOps.incr();
            break;
        case &quot;create&quot;:
            createOps.incr();
            break;
        case &quot;append&quot;:
            appendOps.incr();
            break;
        case &quot;recoverLease&quot;:
            recoverLeaseOps.incr();
            break;
        case &quot;setReplication&quot;:
            setReplicationOps.incr();
            break;
        case &quot;setStoragePolicy&quot;:
            setStoragePolicyOps.incr();
            break;
        case &quot;getStoragePolicies&quot;:
            getStoragePoliciesOps.incr();
            break;
        case &quot;setPermission&quot;:
            setPermissionOps.incr();
            break;
        case &quot;setOwner&quot;:
            setOwnerOps.incr();
            break;
        case &quot;addBlock&quot;:
            addBlockOps.incr();
            break;
        case &quot;getAdditionalDatanode&quot;:
            getAdditionalDatanodeOps.incr();
            break;
        case &quot;abandonBlock&quot;:
            abandonBlockOps.incr();
            break;
        case &quot;complete&quot;:
            completeOps.incr();
            break;
        case &quot;updateBlockForPipeline&quot;:
            updateBlockForPipelineOps.incr();
            break;
        case &quot;updatePipeline&quot;:
            updatePipelineOps.incr();
            break;
        case &quot;getPreferredBlockSize&quot;:
            getPreferredBlockSizeOps.incr();
            break;
        case &quot;rename&quot;:
            renameOps.incr();
            break;
        case &quot;rename2&quot;:
            rename2Ops.incr();
            break;
        case &quot;concat&quot;:
            concatOps.incr();
            break;
        case &quot;truncate&quot;:
            truncateOps.incr();
            break;
        case &quot;delete&quot;:
            deleteOps.incr();
            break;
        case &quot;mkdirs&quot;:
            mkdirsOps.incr();
            break;
        case &quot;renewLease&quot;:
            renewLeaseOps.incr();
            break;
        case &quot;getListing&quot;:
            getListingOps.incr();
            break;
        case &quot;getBatchedListing&quot;:
            getBatchedListingOps.incr();
            break;
        case &quot;getFileInfo&quot;:
            getFileInfoOps.incr();
            break;
        case &quot;isFileClosed&quot;:
            isFileClosedOps.incr();
            break;
        case &quot;getFileLinkInfo&quot;:
            getFileLinkInfoOps.incr();
            break;
        case &quot;getLocatedFileInfo&quot;:
            getLocatedFileInfoOps.incr();
            break;
        case &quot;getStats&quot;:
            getStatsOps.incr();
            break;
        case &quot;getDatanodeReport&quot;:
            getDatanodeReportOps.incr();
            break;
        case &quot;getDatanodeStorageReport&quot;:
            getDatanodeStorageReportOps.incr();
            break;
        case &quot;setSafeMode&quot;:
            setSafeModeOps.incr();
            break;
        case &quot;restoreFailedStorage&quot;:
            restoreFailedStorageOps.incr();
            break;
        case &quot;saveNamespace&quot;:
            saveNamespaceOps.incr();
            break;
        case &quot;rollEdits&quot;:
            rollEditsOps.incr();
            break;
        case &quot;refreshNodes&quot;:
            refreshNodesOps.incr();
            break;
        case &quot;finalizeUpgrade&quot;:
            finalizeUpgradeOps.incr();
            break;
        case &quot;upgradeStatus&quot;:
            upgradeStatusOps.incr();
            break;
        case &quot;rollingUpgrade&quot;:
            rollingUpgradeOps.incr();
            break;
        case &quot;metaSave&quot;:
            metaSaveOps.incr();
            break;
        case &quot;listCorruptFileBlocks&quot;:
            listCorruptFileBlocksOps.incr();
            break;
        case &quot;setBalancerBandwidth&quot;:
            setBalancerBandwidthOps.incr();
            break;
        case &quot;getContentSummary&quot;:
            getContentSummaryOps.incr();
            break;
        case &quot;fsync&quot;:
            fsyncOps.incr();
            break;
        case &quot;setTimes&quot;:
            setTimesOps.incr();
            break;
        case &quot;createSymlink&quot;:
            createSymlinkOps.incr();
            break;
        case &quot;getLinkTarget&quot;:
            getLinkTargetOps.incr();
            break;
        case &quot;allowSnapshot&quot;:
            allowSnapshotOps.incr();
            break;
        case &quot;disallowSnapshot&quot;:
            disallowSnapshotOps.incr();
            break;
        case &quot;renameSnapshot&quot;:
            renameSnapshotOps.incr();
            break;
        case &quot;getSnapshottableDirListing&quot;:
            getSnapshottableDirListingOps.incr();
            break;
        case &quot;getSnapshotListing&quot;:
            getSnapshotListingOps.incr();
            break;
        case &quot;getSnapshotDiffReport&quot;:
            getSnapshotDiffReportOps.incr();
            break;
        case &quot;getSnapshotDiffReportListing&quot;:
            getSnapshotDiffReportListingOps.incr();
            break;
        case &quot;addCacheDirective&quot;:
            addCacheDirectiveOps.incr();
            break;
        case &quot;modifyCacheDirective&quot;:
            modifyCacheDirectiveOps.incr();
            break;
        case &quot;removeCacheDirective&quot;:
            removeCacheDirectiveOps.incr();
            break;
        case &quot;listCacheDirectives&quot;:
            listCacheDirectivesOps.incr();
            break;
        case &quot;addCachePool&quot;:
            addCachePoolOps.incr();
            break;
        case &quot;modifyCachePool&quot;:
            modifyCachePoolOps.incr();
            break;
        case &quot;removeCachePool&quot;:
            removeCachePoolOps.incr();
            break;
        case &quot;listCachePools&quot;:
            listCachePoolsOps.incr();
            break;
        case &quot;modifyAclEntries&quot;:
            modifyAclEntriesOps.incr();
            break;
        case &quot;removeAclEntries&quot;:
            removeAclEntriesOps.incr();
            break;
        case &quot;removeDefaultAcl&quot;:
            removeDefaultAclOps.incr();
            break;
        case &quot;removeAcl&quot;:
            removeAclOps.incr();
            break;
        case &quot;setAcl&quot;:
            setAclOps.incr();
            break;
        case &quot;getAclStatus&quot;:
            getAclStatusOps.incr();
            break;
        case &quot;createEncryptionZone&quot;:
            createEncryptionZoneOps.incr();
            break;
        case &quot;getEZForPath&quot;:
            getEZForPathOps.incr();
            break;
        case &quot;listEncryptionZones&quot;:
            listEncryptionZonesOps.incr();
            break;
        case &quot;reencryptEncryptionZone&quot;:
            reencryptEncryptionZoneOps.incr();
            break;
        case &quot;listReencryptionStatus&quot;:
            listReencryptionStatusOps.incr();
            break;
        case &quot;setXAttr&quot;:
            setXAttrOps.incr();
            break;
        case &quot;getXAttrs&quot;:
            getXAttrsOps.incr();
            break;
        case &quot;listXAttrs&quot;:
            listXAttrsOps.incr();
            break;
        case &quot;removeXAttr&quot;:
            removeXAttrsOps.incr();
            break;
        case &quot;checkAccess&quot;:
            checkAccessOps.incr();
            break;
        case &quot;getCurrentEditLogTxid&quot;:
            getCurrentEditLogTxidOps.incr();
            break;
        case &quot;getEditsFromTxid&quot;:
            getEditsFromTxidOps.incr();
            break;
        case &quot;getDataEncryptionKey&quot;:
            getDataEncryptionKeyOps.incr();
            break;
        case &quot;createSnapshot&quot;:
            createSnapshotOps.incr();
            break;
        case &quot;deleteSnapshot&quot;:
            deleteSnapshotOps.incr();
            break;
        case &quot;setQuota&quot;:
            setQuotaOps.incr();
            break;
        case &quot;getQuotaUsage&quot;:
            getQuotaUsageOps.incr();
            break;
        case &quot;reportBadBlocks&quot;:
            reportBadBlocksOps.incr();
            break;
        case &quot;unsetStoragePolicy&quot;:
            unsetStoragePolicyOps.incr();
            break;
        case &quot;getStoragePolicy&quot;:
            getStoragePolicyOps.incr();
            break;
        case &quot;getErasureCodingPolicies&quot;:
            getErasureCodingPoliciesOps.incr();
            break;
        case &quot;getErasureCodingCodecs&quot;:
            getErasureCodingCodecsOps.incr();
            break;
        case &quot;addErasureCodingPolicies&quot;:
            addErasureCodingPoliciesOps.incr();
            break;
        case &quot;removeErasureCodingPolicy&quot;:
            removeErasureCodingPolicyOps.incr();
            break;
        case &quot;disableErasureCodingPolicy&quot;:
            disableErasureCodingPolicyOps.incr();
            break;
        case &quot;enableErasureCodingPolicy&quot;:
            enableErasureCodingPolicyOps.incr();
            break;
        case &quot;getErasureCodingPolicy&quot;:
            getErasureCodingPolicyOps.incr();
            break;
        case &quot;setErasureCodingPolicy&quot;:
            setErasureCodingPolicyOps.incr();
            break;
        case &quot;unsetErasureCodingPolicy&quot;:
            unsetErasureCodingPolicyOps.incr();
            break;
        case &quot;getECTopologyResultForPolicies&quot;:
            getECTopologyResultForPoliciesOps.incr();
            break;
        case &quot;getECBlockGroupStats&quot;:
            getECBlockGroupStatsOps.incr();
            break;
        case &quot;getReplicatedBlockStats&quot;:
            getReplicatedBlockStatsOps.incr();
            break;
        case &quot;listOpenFiles&quot;:
            listOpenFilesOps.incr();
            break;
        case &quot;msync&quot;:
            msyncOps.incr();
            break;
        case &quot;satisfyStoragePolicy&quot;:
            satisfyStoragePolicyOps.incr();
            break;
        case &quot;getHAServiceState&quot;:
            getHAServiceStateOps.incr();
            break;
        case &quot;getSlowDatanodeReport&quot;:
            getSlowDatanodeReportOps.incr();
            break;
        default:
            otherOps.incr();
    }
}
</code></pre></div></td>
</tr>
<tr>
    <td>7</td><td>7455.51</td><td>67</td><td>382</td>
    <td><div class="code-container"><pre><code class="language-java">private Configuration handleOptions(ParsedOutput opts, Configuration base) throws ConfigException {
    ConfigExtractor extractor = new ConfigExtractor(base);
    {
        Integer mapAmount = null;
        try {
            mapAmount = extractor.getMapAmount(opts.getValue(ConfigOption.MAPS.getOpt()));
        } catch (Exception e) {
            throw new ConfigException(&quot;Error extracting &amp; merging map amount&quot;, e);
        }
        if (mapAmount != null) {
            if (mapAmount &lt;= 0) {
                throw new ConfigException(&quot;Map amount can not be less than or equal to zero&quot;);
            }
            base.set(ConfigOption.MAPS.getCfgOption(), mapAmount.toString());
        }
    }
    {
        Integer reduceAmount = null;
        try {
            reduceAmount = extractor.getMapAmount(opts.getValue(ConfigOption.REDUCES.getOpt()));
        } catch (Exception e) {
            throw new ConfigException(&quot;Error extracting &amp; merging reducer amount&quot;, e);
        }
        if (reduceAmount != null) {
            if (reduceAmount &lt;= 0) {
                throw new ConfigException(&quot;Reducer amount can not be less than or equal to zero&quot;);
            }
            base.set(ConfigOption.REDUCES.getCfgOption(), reduceAmount.toString());
        }
    }
    {
        Integer duration = null;
        try {
            duration = extractor.getDuration(opts.getValue(ConfigOption.DURATION.getOpt()));
        } catch (Exception e) {
            throw new ConfigException(&quot;Error extracting &amp; merging duration&quot;, e);
        }
        if (duration != null) {
            if (duration &lt;= 0) {
                throw new ConfigException(&quot;Duration can not be less than or equal to zero&quot;);
            }
            base.set(ConfigOption.DURATION.getCfgOption(), duration.toString());
        }
    }
    {
        Integer operationAmount = null;
        try {
            operationAmount = extractor.getOpCount(opts.getValue(ConfigOption.OPS.getOpt()));
        } catch (Exception e) {
            throw new ConfigException(&quot;Error extracting &amp; merging operation amount&quot;, e);
        }
        if (operationAmount != null) {
            if (operationAmount &lt;= 0) {
                throw new ConfigException(&quot;Operation amount can not be less than or equal to zero&quot;);
            }
            base.set(ConfigOption.OPS.getCfgOption(), operationAmount.toString());
        }
    }
    {
        try {
            boolean exitOnError = extractor.shouldExitOnFirstError(opts.getValue(ConfigOption.EXIT_ON_ERROR.getOpt()));
            base.setBoolean(ConfigOption.EXIT_ON_ERROR.getCfgOption(), exitOnError);
        } catch (Exception e) {
            throw new ConfigException(&quot;Error extracting &amp; merging exit on error value&quot;, e);
        }
    }
    {
        try {
            boolean waitOnTruncate = extractor.shouldWaitOnTruncate(opts.getValue(ConfigOption.TRUNCATE_WAIT.getOpt()));
            base.setBoolean(ConfigOption.TRUNCATE_WAIT.getCfgOption(), waitOnTruncate);
        } catch (Exception e) {
            throw new ConfigException(&quot;Error extracting &amp; merging wait on truncate value&quot;, e);
        }
    }
    {
        Integer fileAm = null;
        try {
            fileAm = extractor.getTotalFiles(opts.getValue(ConfigOption.FILES.getOpt()));
        } catch (Exception e) {
            throw new ConfigException(&quot;Error extracting &amp; merging total file limit amount&quot;, e);
        }
        if (fileAm != null) {
            if (fileAm &lt;= 0) {
                throw new ConfigException(&quot;File amount can not be less than or equal to zero&quot;);
            }
            base.set(ConfigOption.FILES.getCfgOption(), fileAm.toString());
        }
    }
    {
        try {
            String qname = extractor.getQueueName(opts.getValue(ConfigOption.QUEUE_NAME.getOpt()));
            if (qname != null) {
                base.set(ConfigOption.QUEUE_NAME.getCfgOption(), qname);
            }
        } catch (Exception e) {
            throw new ConfigException(&quot;Error extracting &amp; merging queue name&quot;, e);
        }
    }
    {
        Integer directoryLimit = null;
        try {
            directoryLimit = extractor.getDirSize(opts.getValue(ConfigOption.DIR_SIZE.getOpt()));
        } catch (Exception e) {
            throw new ConfigException(&quot;Error extracting &amp; merging directory file limit&quot;, e);
        }
        if (directoryLimit != null) {
            if (directoryLimit &lt;= 0) {
                throw new ConfigException(&quot;Directory file limit can not be less than or equal to zero&quot;);
            }
            base.set(ConfigOption.DIR_SIZE.getCfgOption(), directoryLimit.toString());
        }
    }
    {
        Path basedir = null;
        try {
            basedir = extractor.getBaseDirectory(opts.getValue(ConfigOption.BASE_DIR.getOpt()));
        } catch (Exception e) {
            throw new ConfigException(&quot;Error extracting &amp; merging base directory&quot;, e);
        }
        if (basedir != null) {
            basedir = new Path(basedir, Constants.BASE_DIR);
            base.set(ConfigOption.BASE_DIR.getCfgOption(), basedir.toString());
        }
    }
    {
        String fn = null;
        try {
            fn = extractor.getResultFile(opts.getValue(ConfigOption.RESULT_FILE.getOpt()));
        } catch (Exception e) {
            throw new ConfigException(&quot;Error extracting &amp; merging result file&quot;, e);
        }
        if (fn != null) {
            base.set(ConfigOption.RESULT_FILE.getCfgOption(), fn);
        }
    }
    {
        String fn = null;
        try {
            fn = extractor.getResultFile(opts.getValue(ConfigOption.RESULT_FILE.getOpt()));
        } catch (Exception e) {
            throw new ConfigException(&quot;Error extracting &amp; merging result file&quot;, e);
        }
        if (fn != null) {
            base.set(ConfigOption.RESULT_FILE.getCfgOption(), fn);
        }
    }
    {
        try {
            base = handleOperations(opts, base, extractor);
        } catch (Exception e) {
            throw new ConfigException(&quot;Error extracting &amp; merging operations&quot;, e);
        }
    }
    {
        Range&lt;Short&gt; replicationAm = null;
        try {
            replicationAm = extractor.getReplication(opts.getValue(ConfigOption.REPLICATION_AM.getOpt()));
        } catch (Exception e) {
            throw new ConfigException(&quot;Error extracting &amp; merging replication amount range&quot;, e);
        }
        if (replicationAm != null) {
            int minRepl = base.getInt(Constants.MIN_REPLICATION, 1);
            if (replicationAm.getLower() &lt; minRepl) {
                throw new ConfigException(&quot;Replication amount minimum is less than property configured minimum &quot; + minRepl);
            }
            if (replicationAm.getLower() &gt; replicationAm.getUpper()) {
                throw new ConfigException(&quot;Replication amount minimum is greater than its maximum&quot;);
            }
            if (replicationAm.getLower() &lt;= 0) {
                throw new ConfigException(&quot;Replication amount minimum must be greater than zero&quot;);
            }
            base.set(ConfigOption.REPLICATION_AM.getCfgOption(), replicationAm.toString());
        }
    }
    {
        Range&lt;Long&gt; sleepRange = null;
        try {
            sleepRange = extractor.getSleepRange(opts.getValue(ConfigOption.SLEEP_TIME.getOpt()));
        } catch (Exception e) {
            throw new ConfigException(&quot;Error extracting &amp; merging sleep size range&quot;, e);
        }
        if (sleepRange != null) {
            if (sleepRange.getLower() &gt; sleepRange.getUpper()) {
                throw new ConfigException(&quot;Sleep range minimum is greater than its maximum&quot;);
            }
            if (sleepRange.getLower() &lt;= 0) {
                throw new ConfigException(&quot;Sleep range minimum must be greater than zero&quot;);
            }
            base.set(ConfigOption.SLEEP_TIME.getCfgOption(), sleepRange.toString());
        }
    }
    {
        String pSize = opts.getValue(ConfigOption.PACKET_SIZE.getOpt());
        if (pSize == null) {
            pSize = ConfigOption.PACKET_SIZE.getDefault();
        }
        if (pSize != null) {
            try {
                Long packetSize = StringUtils.TraditionalBinaryPrefix.string2long(pSize);
                base.set(ConfigOption.PACKET_SIZE.getCfgOption(), packetSize.toString());
            } catch (Exception e) {
                throw new ConfigException(&quot;Error extracting &amp; merging write packet size&quot;, e);
            }
        }
    }
    {
        Range&lt;Long&gt; blockSize = null;
        try {
            blockSize = extractor.getBlockSize(opts.getValue(ConfigOption.BLOCK_SIZE.getOpt()));
        } catch (Exception e) {
            throw new ConfigException(&quot;Error extracting &amp; merging block size range&quot;, e);
        }
        if (blockSize != null) {
            if (blockSize.getLower() &gt; blockSize.getUpper()) {
                throw new ConfigException(&quot;Block size minimum is greater than its maximum&quot;);
            }
            if (blockSize.getLower() &lt;= 0) {
                throw new ConfigException(&quot;Block size minimum must be greater than zero&quot;);
            }
            Long bytesPerChecksum = extractor.getByteCheckSum();
            if (bytesPerChecksum != null) {
                if ((blockSize.getLower() % bytesPerChecksum) != 0) {
                    throw new ConfigException(&quot;Blocksize lower bound must be a multiple of &quot; + bytesPerChecksum);
                }
                if ((blockSize.getUpper() % bytesPerChecksum) != 0) {
                    throw new ConfigException(&quot;Blocksize upper bound must be a multiple of &quot; + bytesPerChecksum);
                }
            }
            base.set(ConfigOption.BLOCK_SIZE.getCfgOption(), blockSize.toString());
        }
    }
    {
        Range&lt;Long&gt; readSize = null;
        try {
            readSize = extractor.getReadSize(opts.getValue(ConfigOption.READ_SIZE.getOpt()));
        } catch (Exception e) {
            throw new ConfigException(&quot;Error extracting &amp; merging read size range&quot;, e);
        }
        if (readSize != null) {
            if (readSize.getLower() &gt; readSize.getUpper()) {
                throw new ConfigException(&quot;Read size minimum is greater than its maximum&quot;);
            }
            if (readSize.getLower() &lt; 0) {
                throw new ConfigException(&quot;Read size minimum must be greater than or equal to zero&quot;);
            }
            base.set(ConfigOption.READ_SIZE.getCfgOption(), readSize.toString());
        }
    }
    {
        Range&lt;Long&gt; writeSize = null;
        try {
            writeSize = extractor.getWriteSize(opts.getValue(ConfigOption.WRITE_SIZE.getOpt()));
        } catch (Exception e) {
            throw new ConfigException(&quot;Error extracting &amp; merging write size range&quot;, e);
        }
        if (writeSize != null) {
            if (writeSize.getLower() &gt; writeSize.getUpper()) {
                throw new ConfigException(&quot;Write size minimum is greater than its maximum&quot;);
            }
            if (writeSize.getLower() &lt; 0) {
                throw new ConfigException(&quot;Write size minimum must be greater than or equal to zero&quot;);
            }
            base.set(ConfigOption.WRITE_SIZE.getCfgOption(), writeSize.toString());
        }
    }
    {
        Range&lt;Long&gt; appendSize = null;
        try {
            appendSize = extractor.getAppendSize(opts.getValue(ConfigOption.APPEND_SIZE.getOpt()));
        } catch (Exception e) {
            throw new ConfigException(&quot;Error extracting &amp; merging append size range&quot;, e);
        }
        if (appendSize != null) {
            if (appendSize.getLower() &gt; appendSize.getUpper()) {
                throw new ConfigException(&quot;Append size minimum is greater than its maximum&quot;);
            }
            if (appendSize.getLower() &lt; 0) {
                throw new ConfigException(&quot;Append size minimum must be greater than or equal to zero&quot;);
            }
            base.set(ConfigOption.APPEND_SIZE.getCfgOption(), appendSize.toString());
        }
    }
    {
        Range&lt;Long&gt; truncateSize = null;
        try {
            truncateSize = extractor.getTruncateSize(opts.getValue(ConfigOption.TRUNCATE_SIZE.getOpt()));
        } catch (Exception e) {
            throw new ConfigException(&quot;Error extracting &amp; merging truncate size range&quot;, e);
        }
        if (truncateSize != null) {
            if (truncateSize.getLower() &gt; truncateSize.getUpper()) {
                throw new ConfigException(&quot;Truncate size minimum is greater than its maximum&quot;);
            }
            if (truncateSize.getLower() &lt; 0) {
                throw new ConfigException(&quot;Truncate size minimum must be greater than or equal to zero&quot;);
            }
            base.set(ConfigOption.TRUNCATE_SIZE.getCfgOption(), truncateSize.toString());
        }
    }
    {
        Long seed = null;
        try {
            seed = extractor.getRandomSeed(opts.getValue(ConfigOption.RANDOM_SEED.getOpt()));
        } catch (Exception e) {
            throw new ConfigException(&quot;Error extracting &amp; merging random number seed&quot;, e);
        }
        if (seed != null) {
            base.set(ConfigOption.RANDOM_SEED.getCfgOption(), seed.toString());
        }
    }
    return base;
}
</code></pre></div></td>
</tr>
<tr>
    <td>9</td><td>7995.07</td><td>59</td><td>350</td>
    <td><div class="code-container"><pre><code class="language-java">private Object statementHelper(TokenStream ts) throws IOException, JavaScriptException {
    Object pn = null;
    boolean skipsemi = false;
    int tt;
    int lastExprType = 0;
    tt = ts.getToken();
    switch(tt) {
        case TokenStream.IF:
            {
                skipsemi = true;
                sourceAdd((char) ts.IF);
                int lineno = ts.getLineno();
                Object cond = condition(ts);
                sourceAdd((char) ts.LC);
                sourceAdd((char) ts.EOL);
                Object ifTrue = statement(ts);
                Object ifFalse = null;
                if (ts.matchToken(ts.ELSE)) {
                    sourceAdd((char) ts.RC);
                    sourceAdd((char) ts.ELSE);
                    sourceAdd((char) ts.LC);
                    sourceAdd((char) ts.EOL);
                    ifFalse = statement(ts);
                }
                sourceAdd((char) ts.RC);
                sourceAdd((char) ts.EOL);
                pn = nf.createIf(cond, ifTrue, ifFalse, lineno);
                break;
            }
        case TokenStream.SWITCH:
            {
                skipsemi = true;
                sourceAdd((char) ts.SWITCH);
                pn = nf.createSwitch(ts.getLineno());
                Object cur_case = null;
                Object case_statements;
                mustMatchToken(ts, ts.LP, &quot;msg.no.paren.switch&quot;);
                sourceAdd((char) ts.LP);
                nf.addChildToBack(pn, expr(ts, false));
                mustMatchToken(ts, ts.GWT, &quot;msg.no.paren.after.switch&quot;);
                sourceAdd((char) ts.GWT);
                mustMatchToken(ts, ts.LC, &quot;msg.no.brace.switch&quot;);
                sourceAdd((char) ts.LC);
                sourceAdd((char) ts.EOL);
                while ((tt = ts.getToken()) != ts.RC &amp;&amp; tt != ts.EOF) {
                    switch(tt) {
                        case TokenStream.CASE:
                            sourceAdd((char) ts.CASE);
                            cur_case = nf.createUnary(ts.CASE, expr(ts, false));
                            sourceAdd((char) ts.COLON);
                            sourceAdd((char) ts.EOL);
                            break;
                        case TokenStream.DEFAULT:
                            cur_case = nf.createLeaf(ts.DEFAULT);
                            sourceAdd((char) ts.DEFAULT);
                            sourceAdd((char) ts.COLON);
                            sourceAdd((char) ts.EOL);
                            break;
                        default:
                            reportError(ts, &quot;msg.bad.switch&quot;);
                            break;
                    }
                    mustMatchToken(ts, ts.COLON, &quot;msg.no.colon.case&quot;);
                    case_statements = nf.createLeaf(TokenStream.BLOCK);
                    ((Node) case_statements).setIsSyntheticBlock(true);
                    while ((tt = ts.peekToken()) != ts.RC &amp;&amp; tt != ts.CASE &amp;&amp; tt != ts.DEFAULT &amp;&amp; tt != ts.EOF) {
                        nf.addChildToBack(case_statements, statement(ts));
                    }
                    nf.addChildToBack(cur_case, case_statements);
                    nf.addChildToBack(pn, cur_case);
                }
                sourceAdd((char) ts.RC);
                sourceAdd((char) ts.EOL);
                break;
            }
        case TokenStream.WHILE:
            {
                skipsemi = true;
                sourceAdd((char) ts.WHILE);
                int lineno = ts.getLineno();
                Object cond = condition(ts);
                sourceAdd((char) ts.LC);
                sourceAdd((char) ts.EOL);
                Object body = statement(ts);
                sourceAdd((char) ts.RC);
                sourceAdd((char) ts.EOL);
                pn = nf.createWhile(cond, body, lineno);
                break;
            }
        case TokenStream.DO:
            {
                sourceAdd((char) ts.DO);
                sourceAdd((char) ts.LC);
                sourceAdd((char) ts.EOL);
                int lineno = ts.getLineno();
                Object body = statement(ts);
                sourceAdd((char) ts.RC);
                mustMatchToken(ts, ts.WHILE, &quot;msg.no.while.do&quot;);
                sourceAdd((char) ts.WHILE);
                Object cond = condition(ts);
                pn = nf.createDoWhile(body, cond, lineno);
                break;
            }
        case TokenStream.FOR:
            {
                skipsemi = true;
                sourceAdd((char) ts.FOR);
                int lineno = ts.getLineno();
                Object init;
                Object cond;
                Object incr = null;
                Object body;
                mustMatchToken(ts, ts.LP, &quot;msg.no.paren.for&quot;);
                sourceAdd((char) ts.LP);
                tt = ts.peekToken();
                if (tt == ts.SEMI) {
                    init = nf.createLeaf(ts.VOID);
                } else {
                    if (tt == ts.VAR) {
                        ts.getToken();
                        init = variables(ts, true);
                    } else {
                        init = expr(ts, true);
                    }
                }
                tt = ts.peekToken();
                if (tt == ts.RELOP &amp;&amp; ts.getOp() == ts.IN) {
                    ts.matchToken(ts.RELOP);
                    sourceAdd((char) ts.IN);
                    cond = expr(ts, false);
                } else {
                    mustMatchToken(ts, ts.SEMI, &quot;msg.no.semi.for&quot;);
                    sourceAdd((char) ts.SEMI);
                    if (ts.peekToken() == ts.SEMI) {
                        cond = nf.createLeaf(ts.VOID);
                    } else {
                        cond = expr(ts, false);
                    }
                    mustMatchToken(ts, ts.SEMI, &quot;msg.no.semi.for.cond&quot;);
                    sourceAdd((char) ts.SEMI);
                    if (ts.peekToken() == ts.GWT) {
                        incr = nf.createLeaf(ts.VOID);
                    } else {
                        incr = expr(ts, false);
                    }
                }
                mustMatchToken(ts, ts.GWT, &quot;msg.no.paren.for.ctrl&quot;);
                sourceAdd((char) ts.GWT);
                sourceAdd((char) ts.LC);
                sourceAdd((char) ts.EOL);
                body = statement(ts);
                sourceAdd((char) ts.RC);
                sourceAdd((char) ts.EOL);
                if (incr == null) {
                    pn = nf.createForIn(init, cond, body, lineno);
                } else {
                    pn = nf.createFor(init, cond, incr, body, lineno);
                }
                break;
            }
        case TokenStream.TRY:
            {
                int lineno = ts.getLineno();
                Object tryblock;
                Object catchblocks = null;
                Object finallyblock = null;
                skipsemi = true;
                sourceAdd((char) ts.TRY);
                sourceAdd((char) ts.LC);
                sourceAdd((char) ts.EOL);
                tryblock = statement(ts);
                sourceAdd((char) ts.RC);
                sourceAdd((char) ts.EOL);
                catchblocks = nf.createLeaf(TokenStream.BLOCK);
                boolean sawDefaultCatch = false;
                int peek = ts.peekToken();
                if (peek == ts.CATCH) {
                    while (ts.matchToken(ts.CATCH)) {
                        if (sawDefaultCatch) {
                            reportError(ts, &quot;msg.catch.unreachable&quot;);
                        }
                        sourceAdd((char) ts.CATCH);
                        mustMatchToken(ts, ts.LP, &quot;msg.no.paren.catch&quot;);
                        sourceAdd((char) ts.LP);
                        mustMatchToken(ts, ts.NAME, &quot;msg.bad.catchcond&quot;);
                        String varName = ts.getString();
                        sourceAddString(ts.NAME, varName);
                        Object catchCond = null;
                        if (ts.matchToken(ts.IF)) {
                            sourceAdd((char) ts.IF);
                            catchCond = expr(ts, false);
                        } else {
                            sawDefaultCatch = true;
                        }
                        mustMatchToken(ts, ts.GWT, &quot;msg.bad.catchcond&quot;);
                        sourceAdd((char) ts.GWT);
                        mustMatchToken(ts, ts.LC, &quot;msg.no.brace.catchblock&quot;);
                        sourceAdd((char) ts.LC);
                        sourceAdd((char) ts.EOL);
                        nf.addChildToBack(catchblocks, nf.createCatch(varName, catchCond, statements(ts), ts.getLineno()));
                        mustMatchToken(ts, ts.RC, &quot;msg.no.brace.after.body&quot;);
                        sourceAdd((char) ts.RC);
                        sourceAdd((char) ts.EOL);
                    }
                } else if (peek != ts.FINALLY) {
                    mustMatchToken(ts, ts.FINALLY, &quot;msg.try.no.catchfinally&quot;);
                }
                if (ts.matchToken(ts.FINALLY)) {
                    sourceAdd((char) ts.FINALLY);
                    sourceAdd((char) ts.LC);
                    sourceAdd((char) ts.EOL);
                    finallyblock = statement(ts);
                    sourceAdd((char) ts.RC);
                    sourceAdd((char) ts.EOL);
                }
                pn = nf.createTryCatchFinally(tryblock, catchblocks, finallyblock, lineno);
                break;
            }
        case TokenStream.THROW:
            {
                int lineno = ts.getLineno();
                sourceAdd((char) ts.THROW);
                pn = nf.createThrow(expr(ts, false), lineno);
                if (lineno == ts.getLineno())
                    wellTerminated(ts, ts.ERROR);
                break;
            }
        case TokenStream.BREAK:
            {
                int lineno = ts.getLineno();
                sourceAdd((char) ts.BREAK);
                String label = matchLabel(ts);
                if (label != null) {
                    sourceAddString(ts.NAME, label);
                }
                pn = nf.createBreak(label, lineno);
                break;
            }
        case TokenStream.CONTINUE:
            {
                int lineno = ts.getLineno();
                sourceAdd((char) ts.CONTINUE);
                String label = matchLabel(ts);
                if (label != null) {
                    sourceAddString(ts.NAME, label);
                }
                pn = nf.createContinue(label, lineno);
                break;
            }
        case TokenStream.DEBUGGER:
            {
                int lineno = ts.getLineno();
                sourceAdd((char) ts.DEBUGGER);
                pn = nf.createDebugger(lineno);
                break;
            }
        case TokenStream.WITH:
            {
                reportError(ts, &quot;msg.jsni.unsupported.with&quot;);
                skipsemi = true;
                sourceAdd((char) ts.WITH);
                int lineno = ts.getLineno();
                mustMatchToken(ts, ts.LP, &quot;msg.no.paren.with&quot;);
                sourceAdd((char) ts.LP);
                Object obj = expr(ts, false);
                mustMatchToken(ts, ts.GWT, &quot;msg.no.paren.after.with&quot;);
                sourceAdd((char) ts.GWT);
                sourceAdd((char) ts.LC);
                sourceAdd((char) ts.EOL);
                Object body = statement(ts);
                sourceAdd((char) ts.RC);
                sourceAdd((char) ts.EOL);
                pn = nf.createWith(obj, body, lineno);
                break;
            }
        case TokenStream.VAR:
            {
                int lineno = ts.getLineno();
                pn = variables(ts, false);
                if (ts.getLineno() == lineno)
                    wellTerminated(ts, ts.ERROR);
                break;
            }
        case TokenStream.RETURN:
            {
                Object retExpr = null;
                int lineno = 0;
                sourceAdd((char) ts.RETURN);
                if ((ts.flags &amp; ts.TSF_FUNCTION) == 0)
                    reportError(ts, &quot;msg.bad.return&quot;);
                ts.flags |= ts.TSF_REGEXP;
                tt = ts.peekTokenSameLine();
                ts.flags &amp;= ~ts.TSF_REGEXP;
                if (tt != ts.EOF &amp;&amp; tt != ts.EOL &amp;&amp; tt != ts.SEMI &amp;&amp; tt != ts.RC) {
                    lineno = ts.getLineno();
                    retExpr = expr(ts, false);
                    if (ts.getLineno() == lineno)
                        wellTerminated(ts, ts.ERROR);
                    ts.flags |= ts.TSF_RETURN_EXPR;
                } else {
                    ts.flags |= ts.TSF_RETURN_VOID;
                }
                pn = nf.createReturn(retExpr, lineno);
                break;
            }
        case TokenStream.LC:
            skipsemi = true;
            pn = statements(ts);
            mustMatchToken(ts, ts.RC, &quot;msg.no.brace.block&quot;);
            break;
        case TokenStream.ERROR:
        case TokenStream.EOL:
        case TokenStream.SEMI:
            pn = nf.createLeaf(ts.VOID);
            skipsemi = true;
            break;
        default:
            {
                lastExprType = tt;
                int tokenno = ts.getTokenno();
                ts.ungetToken(tt);
                int lineno = ts.getLineno();
                pn = expr(ts, false);
                if (ts.peekToken() == ts.COLON) {
                    if (lastExprType != ts.NAME || (ts.getTokenno() != tokenno))
                        reportError(ts, &quot;msg.bad.label&quot;);
                    ts.getToken();
                    String name = ts.getString();
                    pn = nf.createLabel(name, lineno);
                    nf.addChildToBack(pn, statement(ts));
                    sourceAdd((char) ts.COLON);
                    sourceAdd((char) ts.EOL);
                    return pn;
                }
                if (lastExprType == ts.FUNCTION) {
                    if (nf.getLeafType(pn) != ts.FUNCTION) {
                        reportError(ts, &quot;msg.syntax&quot;);
                    }
                }
                pn = nf.createExprStatement(pn, lineno);
                if (ts.getLineno() == lineno || (lastExprType == ts.FUNCTION &amp;&amp; ts.getLineno() == lastExprEndLine)) {
                    wellTerminated(ts, lastExprType);
                }
                break;
            }
    }
    ts.matchToken(ts.SEMI);
    if (!skipsemi) {
        sourceAdd((char) ts.SEMI);
        sourceAdd((char) ts.EOL);
    }
    return pn;
}
</code></pre></div></td>
</tr>
<tr>
    <td>10</td><td>9448.55</td><td>60</td><td>300</td>
    <td><div class="code-container"><pre><code class="language-java">public boolean run() throws IOException, YarnException {
    LOG.info(&quot;Running Client&quot;);
    isRunning.set(true);
    yarnClient.start();
    clientStartTime = System.currentTimeMillis();
    YarnClusterMetrics clusterMetrics = yarnClient.getYarnClusterMetrics();
    LOG.info(&quot;Got Cluster metric info from ASM&quot; + &quot;, numNodeManagers=&quot; + clusterMetrics.getNumNodeManagers());
    List&lt;NodeReport&gt; clusterNodeReports = yarnClient.getNodeReports(NodeState.RUNNING);
    LOG.info(&quot;Got Cluster node info from ASM&quot;);
    for (NodeReport node : clusterNodeReports) {
        LOG.info(&quot;Got node report from ASM for&quot; + &quot;, nodeId=&quot; + node.getNodeId() + &quot;, nodeAddress=&quot; + node.getHttpAddress() + &quot;, nodeRackName=&quot; + node.getRackName() + &quot;, nodeNumContainers=&quot; + node.getNumContainers());
    }
    QueueInfo queueInfo = yarnClient.getQueueInfo(this.amQueue);
    if (queueInfo == null) {
        throw new IllegalArgumentException(String.format(&quot;Queue %s not present in scheduler configuration.&quot;, this.amQueue));
    }
    LOG.info(&quot;Queue info&quot; + &quot;, queueName=&quot; + queueInfo.getQueueName() + &quot;, queueCurrentCapacity=&quot; + queueInfo.getCurrentCapacity() + &quot;, queueMaxCapacity=&quot; + queueInfo.getMaximumCapacity() + &quot;, queueApplicationCount=&quot; + queueInfo.getApplications().size() + &quot;, queueChildQueueCount=&quot; + queueInfo.getChildQueues().size());
    List&lt;QueueUserACLInfo&gt; listAclInfo = yarnClient.getQueueAclsInfo();
    for (QueueUserACLInfo aclInfo : listAclInfo) {
        for (QueueACL userAcl : aclInfo.getUserAcls()) {
            LOG.info(&quot;User ACL Info for Queue&quot; + &quot;, queueName=&quot; + aclInfo.getQueueName() + &quot;, userAcl=&quot; + userAcl.name());
        }
    }
    if (domainId != null &amp;&amp; domainId.length() &gt; 0 &amp;&amp; toCreateDomain) {
        prepareTimelineDomain();
    }
    Map&lt;String, Resource&gt; profiles;
    try {
        profiles = yarnClient.getResourceProfiles();
    } catch (YARNFeatureNotEnabledException re) {
        profiles = null;
    }
    List&lt;String&gt; appProfiles = new ArrayList&lt;&gt;(2);
    appProfiles.add(amResourceProfile);
    appProfiles.add(containerResourceProfile);
    for (String appProfile : appProfiles) {
        if (appProfile != null &amp;&amp; !appProfile.isEmpty()) {
            if (profiles == null) {
                String message = &quot;Resource profiles is not enabled&quot;;
                LOG.error(message);
                throw new IOException(message);
            }
            if (!profiles.containsKey(appProfile)) {
                String message = &quot;Unknown resource profile &apos;&quot; + appProfile + &quot;&apos;. Valid resource profiles are &quot; + profiles.keySet();
                LOG.error(message);
                throw new IOException(message);
            }
        }
    }
    YarnClientApplication app = yarnClient.createApplication();
    GetNewApplicationResponse appResponse = app.getNewApplicationResponse();
    long maxMem = appResponse.getMaximumResourceCapability().getMemorySize();
    LOG.info(&quot;Max mem capability of resources in this cluster &quot; + maxMem);
    if (amMemory &gt; maxMem) {
        LOG.info(&quot;AM memory specified above max threshold of cluster. Using max value.&quot; + &quot;, specified=&quot; + amMemory + &quot;, max=&quot; + maxMem);
        amMemory = maxMem;
    }
    int maxVCores = appResponse.getMaximumResourceCapability().getVirtualCores();
    LOG.info(&quot;Max virtual cores capability of resources in this cluster &quot; + maxVCores);
    if (amVCores &gt; maxVCores) {
        LOG.info(&quot;AM virtual cores specified above max threshold of cluster. &quot; + &quot;Using max value.&quot; + &quot;, specified=&quot; + amVCores + &quot;, max=&quot; + maxVCores);
        amVCores = maxVCores;
    }
    ApplicationSubmissionContext appContext = app.getApplicationSubmissionContext();
    applicationId = appContext.getApplicationId();
    List&lt;ResourceTypeInfo&gt; resourceTypes = yarnClient.getResourceTypeInfo();
    setAMResourceCapability(appContext, profiles, resourceTypes);
    setContainerResources(profiles, resourceTypes);
    appContext.setKeepContainersAcrossApplicationAttempts(keepContainers);
    appContext.setApplicationName(appName);
    if (attemptFailuresValidityInterval &gt;= 0) {
        appContext.setAttemptFailuresValidityInterval(attemptFailuresValidityInterval);
    }
    Set&lt;String&gt; tags = new HashSet&lt;String&gt;();
    if (applicationTags != null) {
        tags.addAll(applicationTags);
    }
    if (flowName != null) {
        tags.add(TimelineUtils.generateFlowNameTag(flowName));
    }
    if (flowVersion != null) {
        tags.add(TimelineUtils.generateFlowVersionTag(flowVersion));
    }
    if (flowRunId != 0) {
        tags.add(TimelineUtils.generateFlowRunIdTag(flowRunId));
    }
    appContext.setApplicationTags(tags);
    Map&lt;String, LocalResource&gt; localResources = new HashMap&lt;String, LocalResource&gt;();
    LOG.info(&quot;Copy App Master jar from local filesystem and add to local environment&quot;);
    FileSystem fs = FileSystem.get(conf);
    addToLocalResources(fs, appMasterJar, appMasterJarPath, applicationId.toString(), localResources, null);
    if (!log4jPropFile.isEmpty()) {
        addToLocalResources(fs, log4jPropFile, log4jPath, applicationId.toString(), localResources, null);
    }
    StringBuilder localizableFiles = new StringBuilder();
    filesToLocalize.stream().forEach(path -&gt; {
        File f = new File(path);
        if (!f.exists()) {
            throw new UncheckedIOException(new IOException(path + &quot; does not exist&quot;));
        }
        if (!f.canRead()) {
            throw new UncheckedIOException(new IOException(path + &quot; cannot be read&quot;));
        }
        if (f.isDirectory()) {
            throw new UncheckedIOException(new IOException(path + &quot; is a directory&quot;));
        }
        try {
            String fileName = f.getName();
            uploadFile(fs, path, fileName, applicationId.toString());
            if (localizableFiles.length() == 0) {
                localizableFiles.append(fileName);
            } else {
                localizableFiles.append(&quot;,&quot;).append(fileName);
            }
        } catch (IOException e) {
            throw new UncheckedIOException(&quot;Cannot upload file: &quot; + path, e);
        }
    });
    String hdfsShellScriptLocation = &quot;&quot;;
    long hdfsShellScriptLen = 0;
    long hdfsShellScriptTimestamp = 0;
    if (!shellScriptPath.isEmpty()) {
        Path shellSrc = new Path(shellScriptPath);
        String shellPathSuffix = ApplicationMaster.getRelativePath(appName, applicationId.toString(), SCRIPT_PATH);
        Path shellDst = new Path(fs.getHomeDirectory(), shellPathSuffix);
        fs.copyFromLocalFile(false, true, shellSrc, shellDst);
        hdfsShellScriptLocation = shellDst.toUri().toString();
        FileStatus shellFileStatus = fs.getFileStatus(shellDst);
        hdfsShellScriptLen = shellFileStatus.getLen();
        hdfsShellScriptTimestamp = shellFileStatus.getModificationTime();
    }
    if (!shellCommand.isEmpty()) {
        addToLocalResources(fs, null, shellCommandPath, applicationId.toString(), localResources, shellCommand);
    }
    if (shellArgs.length &gt; 0) {
        addToLocalResources(fs, null, shellArgsPath, applicationId.toString(), localResources, StringUtils.join(shellArgs, &quot; &quot;));
    }
    LOG.info(&quot;Set the environment for the application master&quot;);
    Map&lt;String, String&gt; env = new HashMap&lt;String, String&gt;();
    env.put(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION, hdfsShellScriptLocation);
    env.put(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP, Long.toString(hdfsShellScriptTimestamp));
    env.put(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN, Long.toString(hdfsShellScriptLen));
    if (domainId != null &amp;&amp; domainId.length() &gt; 0) {
        env.put(DSConstants.DISTRIBUTEDSHELLTIMELINEDOMAIN, domainId);
    }
    StringBuilder classPathEnv = new StringBuilder(Environment.CLASSPATH.$$()).append(ApplicationConstants.CLASS_PATH_SEPARATOR).append(&quot;./*&quot;);
    for (String c : conf.getStrings(YarnConfiguration.YARN_APPLICATION_CLASSPATH, YarnConfiguration.DEFAULT_YARN_CROSS_PLATFORM_APPLICATION_CLASSPATH)) {
        classPathEnv.append(ApplicationConstants.CLASS_PATH_SEPARATOR).append(c.trim());
    }
    classPathEnv.append(ApplicationConstants.CLASS_PATH_SEPARATOR).append(&quot;./log4j.properties&quot;);
    if (conf.getBoolean(YarnConfiguration.IS_MINI_YARN_CLUSTER, false)) {
        classPathEnv.append(ApplicationConstants.CLASS_PATH_SEPARATOR).append(System.getProperty(&quot;java.class.path&quot;));
    }
    env.put(&quot;CLASSPATH&quot;, classPathEnv.toString());
    Vector&lt;CharSequence&gt; vargs = new Vector&lt;CharSequence&gt;(30);
    LOG.info(&quot;Setting up app master command&quot;);
    vargs.add(&quot;\&quot;&quot; + Environment.JAVA_HOME.$$() + &quot;/bin/java\&quot;&quot;);
    vargs.add(&quot;-Xmx&quot; + amMemory + &quot;m&quot;);
    vargs.add(ApplicationConstants.JVM_ADD_OPENS_VAR);
    vargs.add(appMasterMainClass);
    if (containerType != null) {
        vargs.add(&quot;--container_type &quot; + String.valueOf(containerType));
    }
    if (autoPromoteContainers) {
        vargs.add(&quot;--promote_opportunistic_after_start&quot;);
    }
    if (enforceExecType) {
        vargs.add(&quot;--enforce_execution_type&quot;);
    }
    if (containerMemory &gt; 0) {
        vargs.add(&quot;--container_memory &quot; + String.valueOf(containerMemory));
    }
    if (containerVirtualCores &gt; 0) {
        vargs.add(&quot;--container_vcores &quot; + String.valueOf(containerVirtualCores));
    }
    if (!containerResources.isEmpty()) {
        Joiner.MapJoiner joiner = Joiner.on(&apos;,&apos;).withKeyValueSeparator(&quot;=&quot;);
        vargs.add(&quot;--container_resources &quot; + joiner.join(containerResources));
    }
    if (containerResourceProfile != null &amp;&amp; !containerResourceProfile.isEmpty()) {
        vargs.add(&quot;--container_resource_profile &quot; + containerResourceProfile);
    }
    vargs.add(&quot;--num_containers &quot; + String.valueOf(numContainers));
    if (placementSpec != null &amp;&amp; placementSpec.length() &gt; 0) {
        String encodedSpec = Base64.getEncoder().encodeToString(placementSpec.getBytes(StandardCharsets.UTF_8));
        LOG.info(&quot;Encode placement spec: &quot; + encodedSpec);
        vargs.add(&quot;--placement_spec &quot; + encodedSpec);
    }
    if (null != nodeLabelExpression) {
        appContext.setNodeLabelExpression(nodeLabelExpression);
    }
    vargs.add(&quot;--priority &quot; + String.valueOf(shellCmdPriority));
    if (keepContainers) {
        vargs.add(&quot;--keep_containers_across_application_attempts&quot;);
    }
    for (Map.Entry&lt;String, String&gt; entry : shellEnv.entrySet()) {
        vargs.add(&quot;--shell_env &quot; + entry.getKey() + &quot;=&quot; + entry.getValue());
    }
    if (debugFlag) {
        vargs.add(&quot;--debug&quot;);
    }
    if (localizableFiles.length() &gt; 0) {
        vargs.add(&quot;--localized_files &quot; + localizableFiles.toString());
    }
    vargs.add(&quot;--appname &quot; + appName);
    vargs.add(&quot;--homedir &quot; + fs.getHomeDirectory());
    vargs.addAll(containerRetryOptions);
    vargs.add(&quot;1&gt;&quot; + ApplicationConstants.LOG_DIR_EXPANSION_VAR + &quot;/AppMaster.stdout&quot;);
    vargs.add(&quot;2&gt;&quot; + ApplicationConstants.LOG_DIR_EXPANSION_VAR + &quot;/AppMaster.stderr&quot;);
    StringBuilder command = new StringBuilder();
    for (CharSequence str : vargs) {
        command.append(str).append(&quot; &quot;);
    }
    LOG.info(&quot;Completed setting up app master command &quot; + command.toString());
    List&lt;String&gt; commands = new ArrayList&lt;String&gt;();
    commands.add(command.toString());
    ContainerLaunchContext amContainer = ContainerLaunchContext.newInstance(localResources, env, commands, null, null, null);
    Credentials rmCredentials = null;
    if (UserGroupInformation.isSecurityEnabled()) {
        rmCredentials = new Credentials();
        String tokenRenewer = YarnClientUtils.getRmPrincipal(conf);
        if (tokenRenewer == null || tokenRenewer.length() == 0) {
            throw new IOException(&quot;Can&apos;t get Master Kerberos principal for the RM to use as renewer&quot;);
        }
        final Token&lt;?&gt;[] tokens = fs.addDelegationTokens(tokenRenewer, rmCredentials);
        if (tokens != null) {
            for (Token&lt;?&gt; token : tokens) {
                LOG.info(&quot;Got dt for &quot; + fs.getUri() + &quot;; &quot; + token);
            }
        }
    }
    Credentials dockerCredentials = null;
    if (dockerClientConfig != null) {
        dockerCredentials = DockerClientConfigHandler.readCredentialsFromConfigFile(new Path(dockerClientConfig), conf, applicationId.toString());
    }
    if (rmCredentials != null || dockerCredentials != null) {
        DataOutputBuffer dob = new DataOutputBuffer();
        if (rmCredentials != null) {
            rmCredentials.writeTokenStorageToStream(dob);
        }
        if (dockerCredentials != null) {
            dockerCredentials.writeTokenStorageToStream(dob);
        }
        ByteBuffer tokens = ByteBuffer.wrap(dob.getData(), 0, dob.getLength());
        amContainer.setTokens(tokens);
    }
    appContext.setAMContainerSpec(amContainer);
    Priority pri = Priority.newInstance(amPriority);
    appContext.setPriority(pri);
    appContext.setQueue(amQueue);
    specifyLogAggregationContext(appContext);
    LOG.info(&quot;Submitting application to ASM&quot;);
    yarnClient.submitApplication(appContext);
    return monitorApplication(applicationId);
}
</code></pre></div></td>
</tr>
<tr>
    <td>11</td><td>11161.51</td><td>1</td><td>561</td>
    <td><div class="code-container"><pre><code class="language-java">public PersistentResourceXMLDescription getParserDescription() {
    final PersistentResourceXMLBuilder discoveryGroup = builder(DiscoveryGroupDefinition.PATH).addAttributes(CommonAttributes.SOCKET_BINDING, DiscoveryGroupDefinition.JGROUPS_CHANNEL_FACTORY, DiscoveryGroupDefinition.JGROUPS_CHANNEL, CommonAttributes.JGROUPS_CLUSTER, DiscoveryGroupDefinition.REFRESH_TIMEOUT, DiscoveryGroupDefinition.INITIAL_WAIT_TIMEOUT);
    final PersistentResourceXMLBuilder remoteConnector = builder(pathElement(REMOTE_CONNECTOR)).addAttributes(RemoteTransportDefinition.SOCKET_BINDING, CommonAttributes.PARAMS);
    final PersistentResourceXMLBuilder httpConnector = builder(MessagingExtension.HTTP_CONNECTOR_PATH).addAttributes(HTTPConnectorDefinition.SOCKET_BINDING, HTTPConnectorDefinition.ENDPOINT, HTTPConnectorDefinition.SERVER_NAME, CommonAttributes.PARAMS);
    final PersistentResourceXMLBuilder invmConnector = builder(pathElement(IN_VM_CONNECTOR)).addAttributes(InVMTransportDefinition.SERVER_ID, CommonAttributes.PARAMS);
    final PersistentResourceXMLBuilder connector = builder(pathElement(CONNECTOR)).addAttributes(GenericTransportDefinition.SOCKET_BINDING, CommonAttributes.FACTORY_CLASS, CommonAttributes.PARAMS);
    final PersistentResourceXMLBuilder pooledConnectionFactory = builder(MessagingExtension.POOLED_CONNECTION_FACTORY_PATH).addAttributes(ConnectionFactoryAttributes.Common.ENTRIES, ConnectionFactoryAttributes.Common.DISCOVERY_GROUP, ConnectionFactoryAttributes.Common.CONNECTORS, CommonAttributes.HA, ConnectionFactoryAttributes.Common.CLIENT_FAILURE_CHECK_PERIOD, ConnectionFactoryAttributes.Common.CONNECTION_TTL, CommonAttributes.CALL_TIMEOUT, CommonAttributes.CALL_FAILOVER_TIMEOUT, ConnectionFactoryAttributes.Common.CONSUMER_WINDOW_SIZE, ConnectionFactoryAttributes.Common.CONSUMER_MAX_RATE, ConnectionFactoryAttributes.Common.CONFIRMATION_WINDOW_SIZE, ConnectionFactoryAttributes.Common.PRODUCER_WINDOW_SIZE, ConnectionFactoryAttributes.Common.PRODUCER_MAX_RATE, ConnectionFactoryAttributes.Common.PROTOCOL_MANAGER_FACTORY, ConnectionFactoryAttributes.Common.COMPRESS_LARGE_MESSAGES, ConnectionFactoryAttributes.Common.CACHE_LARGE_MESSAGE_CLIENT, CommonAttributes.MIN_LARGE_MESSAGE_SIZE, CommonAttributes.CLIENT_ID, ConnectionFactoryAttributes.Common.DUPS_OK_BATCH_SIZE, ConnectionFactoryAttributes.Common.TRANSACTION_BATCH_SIZE, ConnectionFactoryAttributes.Common.BLOCK_ON_ACKNOWLEDGE, ConnectionFactoryAttributes.Common.BLOCK_ON_NON_DURABLE_SEND, ConnectionFactoryAttributes.Common.BLOCK_ON_DURABLE_SEND, ConnectionFactoryAttributes.Common.AUTO_GROUP, ConnectionFactoryAttributes.Common.PRE_ACKNOWLEDGE, ConnectionFactoryAttributes.Common.RETRY_INTERVAL, ConnectionFactoryAttributes.Common.RETRY_INTERVAL_MULTIPLIER, CommonAttributes.MAX_RETRY_INTERVAL, ConnectionFactoryAttributes.Common.RECONNECT_ATTEMPTS, ConnectionFactoryAttributes.Common.FAILOVER_ON_INITIAL_CONNECTION, ConnectionFactoryAttributes.Common.CONNECTION_LOAD_BALANCING_CLASS_NAME, ConnectionFactoryAttributes.Common.USE_GLOBAL_POOLS, ConnectionFactoryAttributes.Common.SCHEDULED_THREAD_POOL_MAX_SIZE, ConnectionFactoryAttributes.Common.THREAD_POOL_MAX_SIZE, ConnectionFactoryAttributes.Common.GROUP_ID, ConnectionFactoryAttributes.Common.DESERIALIZATION_BLACKLIST, ConnectionFactoryAttributes.Common.DESERIALIZATION_WHITELIST, ConnectionFactoryAttributes.Pooled.USE_JNDI, ConnectionFactoryAttributes.Pooled.JNDI_PARAMS, ConnectionFactoryAttributes.Pooled.REBALANCE_CONNECTIONS, ConnectionFactoryAttributes.Pooled.USE_LOCAL_TX, ConnectionFactoryAttributes.Pooled.SETUP_ATTEMPTS, ConnectionFactoryAttributes.Pooled.SETUP_INTERVAL, ConnectionFactoryAttributes.Pooled.ALLOW_LOCAL_TRANSACTIONS, ConnectionFactoryAttributes.Pooled.TRANSACTION, ConnectionFactoryAttributes.Pooled.USER, ConnectionFactoryAttributes.Pooled.PASSWORD, ConnectionFactoryAttributes.Pooled.CREDENTIAL_REFERENCE, ConnectionFactoryAttributes.Pooled.MIN_POOL_SIZE, ConnectionFactoryAttributes.Pooled.USE_AUTO_RECOVERY, ConnectionFactoryAttributes.Pooled.MAX_POOL_SIZE, ConnectionFactoryAttributes.Pooled.MANAGED_CONNECTION_POOL, ConnectionFactoryAttributes.Pooled.ENLISTMENT_TRACE, ConnectionFactoryAttributes.Common.INITIAL_MESSAGE_PACKET_SIZE, ConnectionFactoryAttributes.Pooled.INITIAL_CONNECT_ATTEMPTS, ConnectionFactoryAttributes.Pooled.STATISTICS_ENABLED);
    return builder(MessagingExtension.SUBSYSTEM_PATH, NAMESPACE).addAttributes(MessagingSubsystemRootResourceDefinition.GLOBAL_CLIENT_THREAD_POOL_MAX_SIZE, MessagingSubsystemRootResourceDefinition.GLOBAL_CLIENT_SCHEDULED_THREAD_POOL_MAX_SIZE).addChild(httpConnector).addChild(remoteConnector).addChild(invmConnector).addChild(connector).addChild(discoveryGroup).addChild(builder(MessagingExtension.CONNECTION_FACTORY_PATH).addAttributes(CommonAttributes.HA, ConnectionFactoryAttributes.Regular.FACTORY_TYPE, ConnectionFactoryAttributes.Common.DISCOVERY_GROUP, ConnectionFactoryAttributes.Common.CONNECTORS, ConnectionFactoryAttributes.Common.ENTRIES)).addChild(pooledConnectionFactory).addChild(builder(MessagingExtension.EXTERNAL_JMS_QUEUE_PATH).addAttributes(ConnectionFactoryAttributes.Common.ENTRIES)).addChild(builder(MessagingExtension.EXTERNAL_JMS_TOPIC_PATH).addAttributes(ConnectionFactoryAttributes.Common.ENTRIES)).addChild(builder(MessagingExtension.SERVER_PATH).addAttributes(ServerDefinition.PERSISTENCE_ENABLED, ServerDefinition.PERSIST_ID_CACHE, ServerDefinition.PERSIST_DELIVERY_COUNT_BEFORE_DELIVERY, ServerDefinition.ID_CACHE_SIZE, ServerDefinition.PAGE_MAX_CONCURRENT_IO, ServerDefinition.SCHEDULED_THREAD_POOL_MAX_SIZE, ServerDefinition.THREAD_POOL_MAX_SIZE, ServerDefinition.WILD_CARD_ROUTING_ENABLED, ServerDefinition.CONNECTION_TTL_OVERRIDE, ServerDefinition.ASYNC_CONNECTION_EXECUTION_ENABLED, ServerDefinition.SECURITY_ENABLED, ServerDefinition.SECURITY_DOMAIN, ServerDefinition.ELYTRON_DOMAIN, ServerDefinition.SECURITY_INVALIDATION_INTERVAL, ServerDefinition.OVERRIDE_IN_VM_SECURITY, ServerDefinition.CLUSTER_USER, ServerDefinition.CLUSTER_PASSWORD, ServerDefinition.CREDENTIAL_REFERENCE, ServerDefinition.MANAGEMENT_ADDRESS, ServerDefinition.MANAGEMENT_NOTIFICATION_ADDRESS, ServerDefinition.JMX_MANAGEMENT_ENABLED, ServerDefinition.JMX_DOMAIN, ServerDefinition.JOURNAL_TYPE, ServerDefinition.JOURNAL_BUFFER_TIMEOUT, ServerDefinition.JOURNAL_BUFFER_SIZE, ServerDefinition.JOURNAL_SYNC_TRANSACTIONAL, ServerDefinition.JOURNAL_SYNC_NON_TRANSACTIONAL, ServerDefinition.LOG_JOURNAL_WRITE_RATE, ServerDefinition.JOURNAL_FILE_SIZE, ServerDefinition.JOURNAL_MIN_FILES, ServerDefinition.JOURNAL_POOL_FILES, ServerDefinition.JOURNAL_COMPACT_PERCENTAGE, ServerDefinition.JOURNAL_COMPACT_MIN_FILES, ServerDefinition.JOURNAL_MAX_IO, ServerDefinition.CREATE_BINDINGS_DIR, ServerDefinition.CREATE_JOURNAL_DIR, ServerDefinition.JOURNAL_DATASOURCE, ServerDefinition.JOURNAL_MESSAGES_TABLE, ServerDefinition.JOURNAL_BINDINGS_TABLE, ServerDefinition.JOURNAL_JMS_BINDINGS_TABLE, ServerDefinition.JOURNAL_LARGE_MESSAGES_TABLE, ServerDefinition.JOURNAL_PAGE_STORE_TABLE, ServerDefinition.JOURNAL_NODE_MANAGER_STORE_TABLE, ServerDefinition.JOURNAL_DATABASE, ServerDefinition.JOURNAL_JDBC_LOCK_EXPIRATION, ServerDefinition.JOURNAL_JDBC_LOCK_RENEW_PERIOD, ServerDefinition.JOURNAL_JDBC_NETWORK_TIMEOUT, ServerDefinition.GLOBAL_MAX_DISK_USAGE, ServerDefinition.DISK_SCAN_PERIOD, ServerDefinition.GLOBAL_MAX_MEMORY_SIZE, ServerDefinition.STATISTICS_ENABLED, ServerDefinition.MESSAGE_COUNTER_SAMPLE_PERIOD, ServerDefinition.MESSAGE_COUNTER_MAX_DAY_HISTORY, ServerDefinition.TRANSACTION_TIMEOUT, ServerDefinition.TRANSACTION_TIMEOUT_SCAN_PERIOD, ServerDefinition.MESSAGE_EXPIRY_SCAN_PERIOD, ServerDefinition.MESSAGE_EXPIRY_THREAD_PRIORITY, ServerDefinition.PERF_BLAST_PAGES, ServerDefinition.RUN_SYNC_SPEED_TEST, ServerDefinition.SERVER_DUMP_INTERVAL, ServerDefinition.MEMORY_MEASURE_INTERVAL, ServerDefinition.MEMORY_WARNING_THRESHOLD, CommonAttributes.INCOMING_INTERCEPTORS, CommonAttributes.OUTGOING_INTERCEPTORS).addChild(builder(MessagingExtension.LIVE_ONLY_PATH).addAttributes(ScaleDownAttributes.SCALE_DOWN, ScaleDownAttributes.SCALE_DOWN_CLUSTER_NAME, ScaleDownAttributes.SCALE_DOWN_GROUP_NAME, ScaleDownAttributes.SCALE_DOWN_DISCOVERY_GROUP, ScaleDownAttributes.SCALE_DOWN_CONNECTORS)).addChild(builder(REPLICATION_MASTER_PATH).addAttributes(HAAttributes.CLUSTER_NAME, HAAttributes.GROUP_NAME, HAAttributes.CHECK_FOR_LIVE_SERVER, HAAttributes.INITIAL_REPLICATION_SYNC_TIMEOUT)).addChild(builder(MessagingExtension.REPLICATION_SLAVE_PATH).addAttributes(HAAttributes.CLUSTER_NAME, HAAttributes.GROUP_NAME, HAAttributes.ALLOW_FAILBACK, HAAttributes.INITIAL_REPLICATION_SYNC_TIMEOUT, HAAttributes.MAX_SAVED_REPLICATED_JOURNAL_SIZE, HAAttributes.RESTART_BACKUP, ScaleDownAttributes.SCALE_DOWN, ScaleDownAttributes.SCALE_DOWN_CLUSTER_NAME, ScaleDownAttributes.SCALE_DOWN_GROUP_NAME, ScaleDownAttributes.SCALE_DOWN_DISCOVERY_GROUP, ScaleDownAttributes.SCALE_DOWN_CONNECTORS)).addChild(builder(REPLICATION_COLOCATED_PATH).addAttributes(HAAttributes.REQUEST_BACKUP, HAAttributes.BACKUP_REQUEST_RETRIES, HAAttributes.BACKUP_REQUEST_RETRY_INTERVAL, HAAttributes.MAX_BACKUPS, HAAttributes.BACKUP_PORT_OFFSET, HAAttributes.EXCLUDED_CONNECTORS).addChild(builder(MessagingExtension.CONFIGURATION_MASTER_PATH).addAttributes(HAAttributes.CLUSTER_NAME, HAAttributes.GROUP_NAME, HAAttributes.CHECK_FOR_LIVE_SERVER, HAAttributes.INITIAL_REPLICATION_SYNC_TIMEOUT)).addChild(builder(MessagingExtension.CONFIGURATION_SLAVE_PATH).addAttributes(HAAttributes.CLUSTER_NAME, HAAttributes.GROUP_NAME, HAAttributes.ALLOW_FAILBACK, HAAttributes.INITIAL_REPLICATION_SYNC_TIMEOUT, HAAttributes.MAX_SAVED_REPLICATED_JOURNAL_SIZE, HAAttributes.RESTART_BACKUP, ScaleDownAttributes.SCALE_DOWN, ScaleDownAttributes.SCALE_DOWN_CLUSTER_NAME, ScaleDownAttributes.SCALE_DOWN_GROUP_NAME, ScaleDownAttributes.SCALE_DOWN_DISCOVERY_GROUP, ScaleDownAttributes.SCALE_DOWN_CONNECTORS))).addChild(builder(SHARED_STORE_MASTER_PATH).addAttributes(HAAttributes.FAILOVER_ON_SERVER_SHUTDOWN)).addChild(builder(SHARED_STORE_SLAVE_PATH).addAttributes(HAAttributes.ALLOW_FAILBACK, HAAttributes.FAILOVER_ON_SERVER_SHUTDOWN, HAAttributes.RESTART_BACKUP, ScaleDownAttributes.SCALE_DOWN, ScaleDownAttributes.SCALE_DOWN_CLUSTER_NAME, ScaleDownAttributes.SCALE_DOWN_GROUP_NAME, ScaleDownAttributes.SCALE_DOWN_DISCOVERY_GROUP, ScaleDownAttributes.SCALE_DOWN_CONNECTORS)).addChild(builder(SHARED_STORE_COLOCATED_PATH).addAttributes(HAAttributes.REQUEST_BACKUP, HAAttributes.BACKUP_REQUEST_RETRIES, HAAttributes.BACKUP_REQUEST_RETRY_INTERVAL, HAAttributes.MAX_BACKUPS, HAAttributes.BACKUP_PORT_OFFSET).addChild(builder(CONFIGURATION_MASTER_PATH).addAttributes(HAAttributes.FAILOVER_ON_SERVER_SHUTDOWN)).addChild(builder(CONFIGURATION_SLAVE_PATH).addAttributes(HAAttributes.ALLOW_FAILBACK, HAAttributes.FAILOVER_ON_SERVER_SHUTDOWN, HAAttributes.RESTART_BACKUP, ScaleDownAttributes.SCALE_DOWN, ScaleDownAttributes.SCALE_DOWN_CLUSTER_NAME, ScaleDownAttributes.SCALE_DOWN_GROUP_NAME, ScaleDownAttributes.SCALE_DOWN_DISCOVERY_GROUP, ScaleDownAttributes.SCALE_DOWN_CONNECTORS))).addChild(builder(MessagingExtension.BINDINGS_DIRECTORY_PATH).addAttributes(PathDefinition.PATHS.get(CommonAttributes.BINDINGS_DIRECTORY), PathDefinition.RELATIVE_TO)).addChild(builder(MessagingExtension.JOURNAL_DIRECTORY_PATH).addAttributes(PathDefinition.PATHS.get(CommonAttributes.JOURNAL_DIRECTORY), PathDefinition.RELATIVE_TO)).addChild(builder(MessagingExtension.LARGE_MESSAGES_DIRECTORY_PATH).addAttributes(PathDefinition.PATHS.get(CommonAttributes.LARGE_MESSAGES_DIRECTORY), PathDefinition.RELATIVE_TO)).addChild(builder(MessagingExtension.PAGING_DIRECTORY_PATH).addAttributes(PathDefinition.PATHS.get(CommonAttributes.PAGING_DIRECTORY), PathDefinition.RELATIVE_TO)).addChild(builder(MessagingExtension.QUEUE_PATH).addAttributes(QueueDefinition.ADDRESS, CommonAttributes.DURABLE, CommonAttributes.FILTER, QueueDefinition.ROUTING_TYPE)).addChild(builder(MessagingExtension.SECURITY_SETTING_PATH).addChild(builder(MessagingExtension.ROLE_PATH).addAttributes(SecurityRoleDefinition.SEND, SecurityRoleDefinition.CONSUME, SecurityRoleDefinition.CREATE_DURABLE_QUEUE, SecurityRoleDefinition.DELETE_DURABLE_QUEUE, SecurityRoleDefinition.CREATE_NON_DURABLE_QUEUE, SecurityRoleDefinition.DELETE_NON_DURABLE_QUEUE, SecurityRoleDefinition.MANAGE))).addChild(builder(MessagingExtension.ADDRESS_SETTING_PATH).addAttributes(CommonAttributes.DEAD_LETTER_ADDRESS, CommonAttributes.EXPIRY_ADDRESS, AddressSettingDefinition.EXPIRY_DELAY, AddressSettingDefinition.REDELIVERY_DELAY, AddressSettingDefinition.REDELIVERY_MULTIPLIER, AddressSettingDefinition.MAX_DELIVERY_ATTEMPTS, AddressSettingDefinition.MAX_REDELIVERY_DELAY, AddressSettingDefinition.MAX_SIZE_BYTES, AddressSettingDefinition.PAGE_SIZE_BYTES, AddressSettingDefinition.PAGE_MAX_CACHE_SIZE, AddressSettingDefinition.ADDRESS_FULL_MESSAGE_POLICY, AddressSettingDefinition.MESSAGE_COUNTER_HISTORY_DAY_LIMIT, AddressSettingDefinition.LAST_VALUE_QUEUE, AddressSettingDefinition.REDISTRIBUTION_DELAY, AddressSettingDefinition.SEND_TO_DLA_ON_NO_ROUTE, AddressSettingDefinition.SLOW_CONSUMER_CHECK_PERIOD, AddressSettingDefinition.SLOW_CONSUMER_POLICY, AddressSettingDefinition.SLOW_CONSUMER_THRESHOLD, AddressSettingDefinition.AUTO_CREATE_JMS_QUEUES, AddressSettingDefinition.AUTO_DELETE_JMS_QUEUES, AddressSettingDefinition.AUTO_CREATE_QUEUES, AddressSettingDefinition.AUTO_DELETE_QUEUES, AddressSettingDefinition.AUTO_CREATE_ADDRESSES, AddressSettingDefinition.AUTO_DELETE_ADDRESSES)).addChild(httpConnector).addChild(remoteConnector).addChild(invmConnector).addChild(connector).addChild(builder(MessagingExtension.HTTP_ACCEPTOR_PATH).addAttributes(HTTPAcceptorDefinition.HTTP_LISTENER, HTTPAcceptorDefinition.UPGRADE_LEGACY, CommonAttributes.PARAMS)).addChild(builder(pathElement(REMOTE_ACCEPTOR)).addAttributes(RemoteTransportDefinition.SOCKET_BINDING, CommonAttributes.PARAMS)).addChild(builder(pathElement(IN_VM_ACCEPTOR)).addAttributes(InVMTransportDefinition.SERVER_ID, CommonAttributes.PARAMS)).addChild(builder(pathElement(ACCEPTOR)).addAttributes(GenericTransportDefinition.SOCKET_BINDING, CommonAttributes.FACTORY_CLASS, CommonAttributes.PARAMS)).addChild(builder(MessagingExtension.BROADCAST_GROUP_PATH).addAttributes(CommonAttributes.SOCKET_BINDING, BroadcastGroupDefinition.JGROUPS_CHANNEL_FACTORY, BroadcastGroupDefinition.JGROUPS_CHANNEL, CommonAttributes.JGROUPS_CLUSTER, BroadcastGroupDefinition.BROADCAST_PERIOD, BroadcastGroupDefinition.CONNECTOR_REFS)).addChild(discoveryGroup).addChild(builder(MessagingExtension.CLUSTER_CONNECTION_PATH).addAttributes(ClusterConnectionDefinition.ADDRESS, ClusterConnectionDefinition.CONNECTOR_NAME, ClusterConnectionDefinition.CHECK_PERIOD, ClusterConnectionDefinition.CONNECTION_TTL, CommonAttributes.MIN_LARGE_MESSAGE_SIZE, CommonAttributes.CALL_TIMEOUT, ClusterConnectionDefinition.CALL_FAILOVER_TIMEOUT, ClusterConnectionDefinition.RETRY_INTERVAL, ClusterConnectionDefinition.RETRY_INTERVAL_MULTIPLIER, ClusterConnectionDefinition.MAX_RETRY_INTERVAL, ClusterConnectionDefinition.INITIAL_CONNECT_ATTEMPTS, ClusterConnectionDefinition.RECONNECT_ATTEMPTS, ClusterConnectionDefinition.USE_DUPLICATE_DETECTION, ClusterConnectionDefinition.MESSAGE_LOAD_BALANCING_TYPE, ClusterConnectionDefinition.MAX_HOPS, CommonAttributes.BRIDGE_CONFIRMATION_WINDOW_SIZE, ClusterConnectionDefinition.PRODUCER_WINDOW_SIZE, ClusterConnectionDefinition.NOTIFICATION_ATTEMPTS, ClusterConnectionDefinition.NOTIFICATION_INTERVAL, ClusterConnectionDefinition.CONNECTOR_REFS, ClusterConnectionDefinition.ALLOW_DIRECT_CONNECTIONS_ONLY, ClusterConnectionDefinition.DISCOVERY_GROUP_NAME)).addChild(builder(MessagingExtension.GROUPING_HANDLER_PATH).addAttributes(GroupingHandlerDefinition.TYPE, GroupingHandlerDefinition.GROUPING_HANDLER_ADDRESS, GroupingHandlerDefinition.TIMEOUT, GroupingHandlerDefinition.GROUP_TIMEOUT, GroupingHandlerDefinition.REAPER_PERIOD)).addChild(builder(DivertDefinition.PATH).addAttributes(DivertDefinition.ROUTING_NAME, DivertDefinition.ADDRESS, DivertDefinition.FORWARDING_ADDRESS, CommonAttributes.FILTER, CommonAttributes.TRANSFORMER_CLASS_NAME, DivertDefinition.EXCLUSIVE)).addChild(builder(MessagingExtension.BRIDGE_PATH).addAttributes(BridgeDefinition.QUEUE_NAME, BridgeDefinition.FORWARDING_ADDRESS, CommonAttributes.HA, CommonAttributes.FILTER, CommonAttributes.TRANSFORMER_CLASS_NAME, CommonAttributes.MIN_LARGE_MESSAGE_SIZE, CommonAttributes.CHECK_PERIOD, CommonAttributes.CONNECTION_TTL, CommonAttributes.RETRY_INTERVAL, CommonAttributes.RETRY_INTERVAL_MULTIPLIER, CommonAttributes.MAX_RETRY_INTERVAL, BridgeDefinition.INITIAL_CONNECT_ATTEMPTS, BridgeDefinition.RECONNECT_ATTEMPTS, BridgeDefinition.RECONNECT_ATTEMPTS_ON_SAME_NODE, BridgeDefinition.USE_DUPLICATE_DETECTION, CommonAttributes.BRIDGE_CONFIRMATION_WINDOW_SIZE, BridgeDefinition.PRODUCER_WINDOW_SIZE, BridgeDefinition.USER, BridgeDefinition.PASSWORD, BridgeDefinition.CREDENTIAL_REFERENCE, BridgeDefinition.CONNECTOR_REFS, BridgeDefinition.DISCOVERY_GROUP_NAME)).addChild(builder(MessagingExtension.CONNECTOR_SERVICE_PATH).addAttributes(CommonAttributes.FACTORY_CLASS, CommonAttributes.PARAMS)).addChild(builder(MessagingExtension.JMS_QUEUE_PATH).addAttributes(CommonAttributes.DESTINATION_ENTRIES, CommonAttributes.SELECTOR, CommonAttributes.DURABLE, CommonAttributes.LEGACY_ENTRIES)).addChild(builder(MessagingExtension.JMS_TOPIC_PATH).addAttributes(CommonAttributes.DESTINATION_ENTRIES, CommonAttributes.LEGACY_ENTRIES)).addChild(builder(MessagingExtension.CONNECTION_FACTORY_PATH).addAttributes(ConnectionFactoryAttributes.Common.ENTRIES, ConnectionFactoryAttributes.Common.DISCOVERY_GROUP, ConnectionFactoryAttributes.Common.CONNECTORS, CommonAttributes.HA, ConnectionFactoryAttributes.Common.CLIENT_FAILURE_CHECK_PERIOD, ConnectionFactoryAttributes.Common.CONNECTION_TTL, CommonAttributes.CALL_TIMEOUT, CommonAttributes.CALL_FAILOVER_TIMEOUT, ConnectionFactoryAttributes.Common.CONSUMER_WINDOW_SIZE, ConnectionFactoryAttributes.Common.CONSUMER_MAX_RATE, ConnectionFactoryAttributes.Common.CONFIRMATION_WINDOW_SIZE, ConnectionFactoryAttributes.Common.PRODUCER_WINDOW_SIZE, ConnectionFactoryAttributes.Common.PRODUCER_MAX_RATE, ConnectionFactoryAttributes.Common.PROTOCOL_MANAGER_FACTORY, ConnectionFactoryAttributes.Common.COMPRESS_LARGE_MESSAGES, ConnectionFactoryAttributes.Common.CACHE_LARGE_MESSAGE_CLIENT, CommonAttributes.MIN_LARGE_MESSAGE_SIZE, CommonAttributes.CLIENT_ID, ConnectionFactoryAttributes.Common.DUPS_OK_BATCH_SIZE, ConnectionFactoryAttributes.Common.TRANSACTION_BATCH_SIZE, ConnectionFactoryAttributes.Common.BLOCK_ON_ACKNOWLEDGE, ConnectionFactoryAttributes.Common.BLOCK_ON_NON_DURABLE_SEND, ConnectionFactoryAttributes.Common.BLOCK_ON_DURABLE_SEND, ConnectionFactoryAttributes.Common.AUTO_GROUP, ConnectionFactoryAttributes.Common.PRE_ACKNOWLEDGE, ConnectionFactoryAttributes.Common.RETRY_INTERVAL, ConnectionFactoryAttributes.Common.RETRY_INTERVAL_MULTIPLIER, CommonAttributes.MAX_RETRY_INTERVAL, ConnectionFactoryAttributes.Common.RECONNECT_ATTEMPTS, ConnectionFactoryAttributes.Common.FAILOVER_ON_INITIAL_CONNECTION, ConnectionFactoryAttributes.Common.CONNECTION_LOAD_BALANCING_CLASS_NAME, ConnectionFactoryAttributes.Common.USE_GLOBAL_POOLS, ConnectionFactoryAttributes.Common.SCHEDULED_THREAD_POOL_MAX_SIZE, ConnectionFactoryAttributes.Common.THREAD_POOL_MAX_SIZE, ConnectionFactoryAttributes.Common.GROUP_ID, ConnectionFactoryAttributes.Common.DESERIALIZATION_BLACKLIST, ConnectionFactoryAttributes.Common.DESERIALIZATION_WHITELIST, ConnectionFactoryAttributes.Common.INITIAL_MESSAGE_PACKET_SIZE, ConnectionFactoryAttributes.Regular.FACTORY_TYPE)).addChild(builder(MessagingExtension.LEGACY_CONNECTION_FACTORY_PATH).addAttributes(LegacyConnectionFactoryDefinition.ENTRIES, LegacyConnectionFactoryDefinition.DISCOVERY_GROUP, LegacyConnectionFactoryDefinition.CONNECTORS, LegacyConnectionFactoryDefinition.AUTO_GROUP, LegacyConnectionFactoryDefinition.BLOCK_ON_ACKNOWLEDGE, LegacyConnectionFactoryDefinition.BLOCK_ON_DURABLE_SEND, LegacyConnectionFactoryDefinition.BLOCK_ON_NON_DURABLE_SEND, CommonAttributes.CALL_TIMEOUT, CommonAttributes.CALL_FAILOVER_TIMEOUT, LegacyConnectionFactoryDefinition.CACHE_LARGE_MESSAGE_CLIENT, LegacyConnectionFactoryDefinition.CLIENT_FAILURE_CHECK_PERIOD, CommonAttributes.CLIENT_ID, LegacyConnectionFactoryDefinition.COMPRESS_LARGE_MESSAGES, LegacyConnectionFactoryDefinition.CONFIRMATION_WINDOW_SIZE, LegacyConnectionFactoryDefinition.CONNECTION_LOAD_BALANCING_CLASS_NAME, LegacyConnectionFactoryDefinition.CONNECTION_TTL, LegacyConnectionFactoryDefinition.CONSUMER_MAX_RATE, LegacyConnectionFactoryDefinition.CONSUMER_WINDOW_SIZE, LegacyConnectionFactoryDefinition.DUPS_OK_BATCH_SIZE, LegacyConnectionFactoryDefinition.FACTORY_TYPE, LegacyConnectionFactoryDefinition.FAILOVER_ON_INITIAL_CONNECTION, LegacyConnectionFactoryDefinition.GROUP_ID, LegacyConnectionFactoryDefinition.INITIAL_CONNECT_ATTEMPTS, LegacyConnectionFactoryDefinition.INITIAL_MESSAGE_PACKET_SIZE, LegacyConnectionFactoryDefinition.HA, LegacyConnectionFactoryDefinition.MAX_RETRY_INTERVAL, LegacyConnectionFactoryDefinition.MIN_LARGE_MESSAGE_SIZE, LegacyConnectionFactoryDefinition.PRE_ACKNOWLEDGE, LegacyConnectionFactoryDefinition.PRODUCER_MAX_RATE, LegacyConnectionFactoryDefinition.PRODUCER_WINDOW_SIZE, LegacyConnectionFactoryDefinition.RECONNECT_ATTEMPTS, LegacyConnectionFactoryDefinition.RETRY_INTERVAL, LegacyConnectionFactoryDefinition.RETRY_INTERVAL_MULTIPLIER, LegacyConnectionFactoryDefinition.SCHEDULED_THREAD_POOL_MAX_SIZE, LegacyConnectionFactoryDefinition.THREAD_POOL_MAX_SIZE, LegacyConnectionFactoryDefinition.TRANSACTION_BATCH_SIZE, LegacyConnectionFactoryDefinition.USE_GLOBAL_POOLS)).addChild(pooledConnectionFactory)).addChild(builder(MessagingExtension.JMS_BRIDGE_PATH).addAttributes(JMSBridgeDefinition.MODULE, JMSBridgeDefinition.QUALITY_OF_SERVICE, JMSBridgeDefinition.FAILURE_RETRY_INTERVAL, JMSBridgeDefinition.MAX_RETRIES, JMSBridgeDefinition.MAX_BATCH_SIZE, JMSBridgeDefinition.MAX_BATCH_TIME, CommonAttributes.SELECTOR, JMSBridgeDefinition.SUBSCRIPTION_NAME, CommonAttributes.CLIENT_ID, JMSBridgeDefinition.ADD_MESSAGE_ID_IN_HEADER, JMSBridgeDefinition.SOURCE_CONNECTION_FACTORY, JMSBridgeDefinition.SOURCE_DESTINATION, JMSBridgeDefinition.SOURCE_USER, JMSBridgeDefinition.SOURCE_PASSWORD, JMSBridgeDefinition.SOURCE_CREDENTIAL_REFERENCE, JMSBridgeDefinition.TARGET_CONNECTION_FACTORY, JMSBridgeDefinition.TARGET_DESTINATION, JMSBridgeDefinition.TARGET_USER, JMSBridgeDefinition.TARGET_PASSWORD, JMSBridgeDefinition.TARGET_CREDENTIAL_REFERENCE, JMSBridgeDefinition.SOURCE_CONTEXT, JMSBridgeDefinition.TARGET_CONTEXT)).build();
}
</code></pre></div></td>
</tr>
<tr>
    <td>12</td><td>10082.46</td><td>1</td><td>517</td>
    <td><div class="code-container"><pre><code class="language-java">public PersistentResourceXMLDescription getParserDescription() {
    final PersistentResourceXMLBuilder jgroupDiscoveryGroup = builder(JGroupsDiscoveryGroupDefinition.PATH).addAttributes(DiscoveryGroupDefinition.JGROUPS_CHANNEL_FACTORY, DiscoveryGroupDefinition.JGROUPS_CHANNEL, CommonAttributes.JGROUPS_CLUSTER, DiscoveryGroupDefinition.REFRESH_TIMEOUT, DiscoveryGroupDefinition.INITIAL_WAIT_TIMEOUT);
    final PersistentResourceXMLBuilder socketDiscoveryGroup = builder(SocketDiscoveryGroupDefinition.PATH).addAttributes(CommonAttributes.SOCKET_BINDING, DiscoveryGroupDefinition.REFRESH_TIMEOUT, DiscoveryGroupDefinition.INITIAL_WAIT_TIMEOUT);
    final PersistentResourceXMLBuilder remoteConnector = builder(pathElement(REMOTE_CONNECTOR)).addAttributes(RemoteTransportDefinition.SOCKET_BINDING, CommonAttributes.PARAMS);
    final PersistentResourceXMLBuilder httpConnector = builder(MessagingExtension.HTTP_CONNECTOR_PATH).addAttributes(HTTPConnectorDefinition.SOCKET_BINDING, HTTPConnectorDefinition.ENDPOINT, HTTPConnectorDefinition.SERVER_NAME, CommonAttributes.PARAMS);
    final PersistentResourceXMLBuilder invmConnector = builder(pathElement(IN_VM_CONNECTOR)).addAttributes(InVMTransportDefinition.SERVER_ID, CommonAttributes.PARAMS);
    final PersistentResourceXMLBuilder connector = builder(pathElement(CONNECTOR)).addAttributes(GenericTransportDefinition.SOCKET_BINDING, CommonAttributes.FACTORY_CLASS, CommonAttributes.PARAMS);
    return builder(MessagingExtension.SUBSYSTEM_PATH, NAMESPACE).addAttributes(MessagingSubsystemRootResourceDefinition.GLOBAL_CLIENT_THREAD_POOL_MAX_SIZE, MessagingSubsystemRootResourceDefinition.GLOBAL_CLIENT_SCHEDULED_THREAD_POOL_MAX_SIZE).addChild(httpConnector).addChild(remoteConnector).addChild(invmConnector).addChild(connector).addChild(jgroupDiscoveryGroup).addChild(socketDiscoveryGroup).addChild(builder(MessagingExtension.CONNECTION_FACTORY_PATH).addAttributes(CommonAttributes.HA, ConnectionFactoryAttributes.Regular.FACTORY_TYPE, ConnectionFactoryAttributes.Common.DISCOVERY_GROUP, ConnectionFactoryAttributes.Common.CONNECTORS, ConnectionFactoryAttributes.Common.ENTRIES, ConnectionFactoryAttributes.External.ENABLE_AMQ1_PREFIX, ConnectionFactoryAttributes.Common.USE_TOPOLOGY)).addChild(createPooledConnectionFactory(true)).addChild(builder(MessagingExtension.EXTERNAL_JMS_QUEUE_PATH).addAttributes(ConnectionFactoryAttributes.Common.ENTRIES)).addChild(builder(MessagingExtension.EXTERNAL_JMS_TOPIC_PATH).addAttributes(ConnectionFactoryAttributes.Common.ENTRIES)).addChild(builder(MessagingExtension.SERVER_PATH).addAttributes(ServerDefinition.PERSISTENCE_ENABLED, ServerDefinition.PERSIST_ID_CACHE, ServerDefinition.PERSIST_DELIVERY_COUNT_BEFORE_DELIVERY, ServerDefinition.ID_CACHE_SIZE, ServerDefinition.PAGE_MAX_CONCURRENT_IO, ServerDefinition.SCHEDULED_THREAD_POOL_MAX_SIZE, ServerDefinition.THREAD_POOL_MAX_SIZE, ServerDefinition.WILD_CARD_ROUTING_ENABLED, ServerDefinition.CONNECTION_TTL_OVERRIDE, ServerDefinition.ASYNC_CONNECTION_EXECUTION_ENABLED, ServerDefinition.SECURITY_ENABLED, ServerDefinition.SECURITY_DOMAIN, ServerDefinition.ELYTRON_DOMAIN, ServerDefinition.SECURITY_INVALIDATION_INTERVAL, ServerDefinition.OVERRIDE_IN_VM_SECURITY, ServerDefinition.CLUSTER_USER, ServerDefinition.CLUSTER_PASSWORD, ServerDefinition.CREDENTIAL_REFERENCE, ServerDefinition.MANAGEMENT_ADDRESS, ServerDefinition.MANAGEMENT_NOTIFICATION_ADDRESS, ServerDefinition.JMX_MANAGEMENT_ENABLED, ServerDefinition.JMX_DOMAIN, ServerDefinition.JOURNAL_TYPE, ServerDefinition.JOURNAL_BUFFER_TIMEOUT, ServerDefinition.JOURNAL_BUFFER_SIZE, ServerDefinition.JOURNAL_SYNC_TRANSACTIONAL, ServerDefinition.JOURNAL_SYNC_NON_TRANSACTIONAL, ServerDefinition.LOG_JOURNAL_WRITE_RATE, ServerDefinition.JOURNAL_FILE_SIZE, ServerDefinition.JOURNAL_MIN_FILES, ServerDefinition.JOURNAL_POOL_FILES, ServerDefinition.JOURNAL_FILE_OPEN_TIMEOUT, ServerDefinition.JOURNAL_COMPACT_PERCENTAGE, ServerDefinition.JOURNAL_COMPACT_MIN_FILES, ServerDefinition.JOURNAL_MAX_IO, ServerDefinition.CREATE_BINDINGS_DIR, ServerDefinition.CREATE_JOURNAL_DIR, ServerDefinition.JOURNAL_DATASOURCE, ServerDefinition.JOURNAL_MESSAGES_TABLE, ServerDefinition.JOURNAL_BINDINGS_TABLE, ServerDefinition.JOURNAL_JMS_BINDINGS_TABLE, ServerDefinition.JOURNAL_LARGE_MESSAGES_TABLE, ServerDefinition.JOURNAL_PAGE_STORE_TABLE, ServerDefinition.JOURNAL_NODE_MANAGER_STORE_TABLE, ServerDefinition.JOURNAL_DATABASE, ServerDefinition.JOURNAL_JDBC_LOCK_EXPIRATION, ServerDefinition.JOURNAL_JDBC_LOCK_RENEW_PERIOD, ServerDefinition.JOURNAL_JDBC_NETWORK_TIMEOUT, ServerDefinition.GLOBAL_MAX_DISK_USAGE, ServerDefinition.DISK_SCAN_PERIOD, ServerDefinition.GLOBAL_MAX_MEMORY_SIZE, ServerDefinition.STATISTICS_ENABLED, ServerDefinition.MESSAGE_COUNTER_SAMPLE_PERIOD, ServerDefinition.MESSAGE_COUNTER_MAX_DAY_HISTORY, ServerDefinition.TRANSACTION_TIMEOUT, ServerDefinition.TRANSACTION_TIMEOUT_SCAN_PERIOD, ServerDefinition.MESSAGE_EXPIRY_SCAN_PERIOD, ServerDefinition.MESSAGE_EXPIRY_THREAD_PRIORITY, ServerDefinition.PERF_BLAST_PAGES, ServerDefinition.RUN_SYNC_SPEED_TEST, ServerDefinition.SERVER_DUMP_INTERVAL, ServerDefinition.MEMORY_MEASURE_INTERVAL, ServerDefinition.MEMORY_WARNING_THRESHOLD, CommonAttributes.INCOMING_INTERCEPTORS, CommonAttributes.OUTGOING_INTERCEPTORS).addChild(builder(MessagingExtension.LIVE_ONLY_PATH).addAttributes(ScaleDownAttributes.SCALE_DOWN, ScaleDownAttributes.SCALE_DOWN_CLUSTER_NAME, ScaleDownAttributes.SCALE_DOWN_GROUP_NAME, ScaleDownAttributes.SCALE_DOWN_DISCOVERY_GROUP, ScaleDownAttributes.SCALE_DOWN_CONNECTORS)).addChild(builder(REPLICATION_MASTER_PATH).addAttributes(HAAttributes.CLUSTER_NAME, HAAttributes.GROUP_NAME, HAAttributes.CHECK_FOR_LIVE_SERVER, HAAttributes.INITIAL_REPLICATION_SYNC_TIMEOUT)).addChild(builder(MessagingExtension.REPLICATION_SLAVE_PATH).addAttributes(HAAttributes.CLUSTER_NAME, HAAttributes.GROUP_NAME, HAAttributes.ALLOW_FAILBACK, HAAttributes.INITIAL_REPLICATION_SYNC_TIMEOUT, HAAttributes.MAX_SAVED_REPLICATED_JOURNAL_SIZE, HAAttributes.RESTART_BACKUP, ScaleDownAttributes.SCALE_DOWN, ScaleDownAttributes.SCALE_DOWN_CLUSTER_NAME, ScaleDownAttributes.SCALE_DOWN_GROUP_NAME, ScaleDownAttributes.SCALE_DOWN_DISCOVERY_GROUP, ScaleDownAttributes.SCALE_DOWN_CONNECTORS)).addChild(builder(MessagingExtension.REPLICATION_COLOCATED_PATH).addAttributes(HAAttributes.REQUEST_BACKUP, HAAttributes.BACKUP_REQUEST_RETRIES, HAAttributes.BACKUP_REQUEST_RETRY_INTERVAL, HAAttributes.MAX_BACKUPS, HAAttributes.BACKUP_PORT_OFFSET, HAAttributes.EXCLUDED_CONNECTORS).addChild(builder(MessagingExtension.CONFIGURATION_MASTER_PATH).addAttributes(HAAttributes.CLUSTER_NAME, HAAttributes.GROUP_NAME, HAAttributes.CHECK_FOR_LIVE_SERVER, HAAttributes.INITIAL_REPLICATION_SYNC_TIMEOUT)).addChild(builder(MessagingExtension.CONFIGURATION_SLAVE_PATH).addAttributes(HAAttributes.CLUSTER_NAME, HAAttributes.GROUP_NAME, HAAttributes.ALLOW_FAILBACK, HAAttributes.INITIAL_REPLICATION_SYNC_TIMEOUT, HAAttributes.MAX_SAVED_REPLICATED_JOURNAL_SIZE, HAAttributes.RESTART_BACKUP, ScaleDownAttributes.SCALE_DOWN, ScaleDownAttributes.SCALE_DOWN_CLUSTER_NAME, ScaleDownAttributes.SCALE_DOWN_GROUP_NAME, ScaleDownAttributes.SCALE_DOWN_DISCOVERY_GROUP, ScaleDownAttributes.SCALE_DOWN_CONNECTORS))).addChild(builder(SHARED_STORE_MASTER_PATH).addAttributes(HAAttributes.FAILOVER_ON_SERVER_SHUTDOWN)).addChild(builder(SHARED_STORE_SLAVE_PATH).addAttributes(HAAttributes.ALLOW_FAILBACK, HAAttributes.FAILOVER_ON_SERVER_SHUTDOWN, HAAttributes.RESTART_BACKUP, ScaleDownAttributes.SCALE_DOWN, ScaleDownAttributes.SCALE_DOWN_CLUSTER_NAME, ScaleDownAttributes.SCALE_DOWN_GROUP_NAME, ScaleDownAttributes.SCALE_DOWN_DISCOVERY_GROUP, ScaleDownAttributes.SCALE_DOWN_CONNECTORS)).addChild(builder(MessagingExtension.SHARED_STORE_COLOCATED_PATH).addAttributes(HAAttributes.REQUEST_BACKUP, HAAttributes.BACKUP_REQUEST_RETRIES, HAAttributes.BACKUP_REQUEST_RETRY_INTERVAL, HAAttributes.MAX_BACKUPS, HAAttributes.BACKUP_PORT_OFFSET).addChild(builder(CONFIGURATION_MASTER_PATH).addAttributes(HAAttributes.FAILOVER_ON_SERVER_SHUTDOWN)).addChild(builder(CONFIGURATION_SLAVE_PATH).addAttributes(HAAttributes.ALLOW_FAILBACK, HAAttributes.FAILOVER_ON_SERVER_SHUTDOWN, HAAttributes.RESTART_BACKUP, ScaleDownAttributes.SCALE_DOWN, ScaleDownAttributes.SCALE_DOWN_CLUSTER_NAME, ScaleDownAttributes.SCALE_DOWN_GROUP_NAME, ScaleDownAttributes.SCALE_DOWN_DISCOVERY_GROUP, ScaleDownAttributes.SCALE_DOWN_CONNECTORS))).addChild(builder(MessagingExtension.BINDINGS_DIRECTORY_PATH).addAttributes(PathDefinition.PATHS.get(CommonAttributes.BINDINGS_DIRECTORY), PathDefinition.RELATIVE_TO)).addChild(builder(MessagingExtension.JOURNAL_DIRECTORY_PATH).addAttributes(PathDefinition.PATHS.get(CommonAttributes.JOURNAL_DIRECTORY), PathDefinition.RELATIVE_TO)).addChild(builder(MessagingExtension.LARGE_MESSAGES_DIRECTORY_PATH).addAttributes(PathDefinition.PATHS.get(CommonAttributes.LARGE_MESSAGES_DIRECTORY), PathDefinition.RELATIVE_TO)).addChild(builder(MessagingExtension.PAGING_DIRECTORY_PATH).addAttributes(PathDefinition.PATHS.get(CommonAttributes.PAGING_DIRECTORY), PathDefinition.RELATIVE_TO)).addChild(builder(MessagingExtension.QUEUE_PATH).addAttributes(QueueDefinition.ADDRESS, CommonAttributes.DURABLE, CommonAttributes.FILTER, QueueDefinition.ROUTING_TYPE)).addChild(builder(MessagingExtension.SECURITY_SETTING_PATH).addChild(builder(MessagingExtension.ROLE_PATH).addAttributes(SecurityRoleDefinition.SEND, SecurityRoleDefinition.CONSUME, SecurityRoleDefinition.CREATE_DURABLE_QUEUE, SecurityRoleDefinition.DELETE_DURABLE_QUEUE, SecurityRoleDefinition.CREATE_NON_DURABLE_QUEUE, SecurityRoleDefinition.DELETE_NON_DURABLE_QUEUE, SecurityRoleDefinition.MANAGE))).addChild(builder(MessagingExtension.ADDRESS_SETTING_PATH).addAttributes(CommonAttributes.DEAD_LETTER_ADDRESS, CommonAttributes.EXPIRY_ADDRESS, AddressSettingDefinition.EXPIRY_DELAY, AddressSettingDefinition.REDELIVERY_DELAY, AddressSettingDefinition.REDELIVERY_MULTIPLIER, AddressSettingDefinition.MAX_DELIVERY_ATTEMPTS, AddressSettingDefinition.MAX_REDELIVERY_DELAY, AddressSettingDefinition.MAX_SIZE_BYTES, AddressSettingDefinition.PAGE_SIZE_BYTES, AddressSettingDefinition.PAGE_MAX_CACHE_SIZE, AddressSettingDefinition.ADDRESS_FULL_MESSAGE_POLICY, AddressSettingDefinition.MESSAGE_COUNTER_HISTORY_DAY_LIMIT, AddressSettingDefinition.LAST_VALUE_QUEUE, AddressSettingDefinition.REDISTRIBUTION_DELAY, AddressSettingDefinition.SEND_TO_DLA_ON_NO_ROUTE, AddressSettingDefinition.SLOW_CONSUMER_CHECK_PERIOD, AddressSettingDefinition.SLOW_CONSUMER_POLICY, AddressSettingDefinition.SLOW_CONSUMER_THRESHOLD, AddressSettingDefinition.AUTO_CREATE_JMS_QUEUES, AddressSettingDefinition.AUTO_DELETE_JMS_QUEUES, AddressSettingDefinition.AUTO_CREATE_QUEUES, AddressSettingDefinition.AUTO_DELETE_QUEUES, AddressSettingDefinition.AUTO_CREATE_ADDRESSES, AddressSettingDefinition.AUTO_DELETE_ADDRESSES)).addChild(httpConnector).addChild(remoteConnector).addChild(invmConnector).addChild(connector).addChild(builder(MessagingExtension.HTTP_ACCEPTOR_PATH).addAttributes(HTTPAcceptorDefinition.HTTP_LISTENER, HTTPAcceptorDefinition.UPGRADE_LEGACY, CommonAttributes.PARAMS)).addChild(builder(pathElement(REMOTE_ACCEPTOR)).addAttributes(RemoteTransportDefinition.SOCKET_BINDING, CommonAttributes.PARAMS)).addChild(builder(pathElement(IN_VM_ACCEPTOR)).addAttributes(InVMTransportDefinition.SERVER_ID, CommonAttributes.PARAMS)).addChild(builder(pathElement(ACCEPTOR)).addAttributes(GenericTransportDefinition.SOCKET_BINDING, CommonAttributes.FACTORY_CLASS, CommonAttributes.PARAMS)).addChild(builder(MessagingExtension.JGROUPS_BROADCAST_GROUP_PATH).addAttributes(BroadcastGroupDefinition.JGROUPS_CHANNEL_FACTORY, BroadcastGroupDefinition.JGROUPS_CHANNEL, CommonAttributes.JGROUPS_CLUSTER, BroadcastGroupDefinition.BROADCAST_PERIOD, BroadcastGroupDefinition.CONNECTOR_REFS)).addChild(builder(MessagingExtension.SOCKET_BROADCAST_GROUP_PATH).addAttributes(CommonAttributes.SOCKET_BINDING, BroadcastGroupDefinition.BROADCAST_PERIOD, BroadcastGroupDefinition.CONNECTOR_REFS)).addChild(jgroupDiscoveryGroup).addChild(socketDiscoveryGroup).addChild(builder(MessagingExtension.CLUSTER_CONNECTION_PATH).addAttributes(ClusterConnectionDefinition.ADDRESS, ClusterConnectionDefinition.CONNECTOR_NAME, ClusterConnectionDefinition.CHECK_PERIOD, ClusterConnectionDefinition.CONNECTION_TTL, CommonAttributes.MIN_LARGE_MESSAGE_SIZE, CommonAttributes.CALL_TIMEOUT, ClusterConnectionDefinition.CALL_FAILOVER_TIMEOUT, ClusterConnectionDefinition.RETRY_INTERVAL, ClusterConnectionDefinition.RETRY_INTERVAL_MULTIPLIER, ClusterConnectionDefinition.MAX_RETRY_INTERVAL, ClusterConnectionDefinition.INITIAL_CONNECT_ATTEMPTS, ClusterConnectionDefinition.RECONNECT_ATTEMPTS, ClusterConnectionDefinition.USE_DUPLICATE_DETECTION, ClusterConnectionDefinition.MESSAGE_LOAD_BALANCING_TYPE, ClusterConnectionDefinition.MAX_HOPS, CommonAttributes.BRIDGE_CONFIRMATION_WINDOW_SIZE, ClusterConnectionDefinition.PRODUCER_WINDOW_SIZE, ClusterConnectionDefinition.NOTIFICATION_ATTEMPTS, ClusterConnectionDefinition.NOTIFICATION_INTERVAL, ClusterConnectionDefinition.CONNECTOR_REFS, ClusterConnectionDefinition.ALLOW_DIRECT_CONNECTIONS_ONLY, ClusterConnectionDefinition.DISCOVERY_GROUP_NAME)).addChild(builder(MessagingExtension.GROUPING_HANDLER_PATH).addAttributes(GroupingHandlerDefinition.TYPE, GroupingHandlerDefinition.GROUPING_HANDLER_ADDRESS, GroupingHandlerDefinition.TIMEOUT, GroupingHandlerDefinition.GROUP_TIMEOUT, GroupingHandlerDefinition.REAPER_PERIOD)).addChild(builder(DivertDefinition.PATH).addAttributes(DivertDefinition.ROUTING_NAME, DivertDefinition.ADDRESS, DivertDefinition.FORWARDING_ADDRESS, CommonAttributes.FILTER, CommonAttributes.TRANSFORMER_CLASS_NAME, DivertDefinition.EXCLUSIVE)).addChild(builder(MessagingExtension.BRIDGE_PATH).addAttributes(BridgeDefinition.QUEUE_NAME, BridgeDefinition.FORWARDING_ADDRESS, CommonAttributes.HA, CommonAttributes.FILTER, CommonAttributes.TRANSFORMER_CLASS_NAME, CommonAttributes.MIN_LARGE_MESSAGE_SIZE, CommonAttributes.CHECK_PERIOD, CommonAttributes.CONNECTION_TTL, CommonAttributes.RETRY_INTERVAL, CommonAttributes.RETRY_INTERVAL_MULTIPLIER, CommonAttributes.MAX_RETRY_INTERVAL, BridgeDefinition.INITIAL_CONNECT_ATTEMPTS, BridgeDefinition.RECONNECT_ATTEMPTS, BridgeDefinition.RECONNECT_ATTEMPTS_ON_SAME_NODE, BridgeDefinition.USE_DUPLICATE_DETECTION, CommonAttributes.BRIDGE_CONFIRMATION_WINDOW_SIZE, BridgeDefinition.PRODUCER_WINDOW_SIZE, BridgeDefinition.USER, BridgeDefinition.PASSWORD, BridgeDefinition.CREDENTIAL_REFERENCE, BridgeDefinition.CONNECTOR_REFS, BridgeDefinition.DISCOVERY_GROUP_NAME)).addChild(builder(MessagingExtension.CONNECTOR_SERVICE_PATH).addAttributes(CommonAttributes.FACTORY_CLASS, CommonAttributes.PARAMS)).addChild(builder(MessagingExtension.JMS_QUEUE_PATH).addAttributes(CommonAttributes.DESTINATION_ENTRIES, CommonAttributes.SELECTOR, CommonAttributes.DURABLE, CommonAttributes.LEGACY_ENTRIES)).addChild(builder(MessagingExtension.JMS_TOPIC_PATH).addAttributes(CommonAttributes.DESTINATION_ENTRIES, CommonAttributes.LEGACY_ENTRIES)).addChild(builder(MessagingExtension.CONNECTION_FACTORY_PATH).addAttributes(ConnectionFactoryAttributes.Common.ENTRIES, ConnectionFactoryAttributes.Common.DISCOVERY_GROUP, ConnectionFactoryAttributes.Common.CONNECTORS, CommonAttributes.HA, ConnectionFactoryAttributes.Common.CLIENT_FAILURE_CHECK_PERIOD, ConnectionFactoryAttributes.Common.CONNECTION_TTL, CommonAttributes.CALL_TIMEOUT, CommonAttributes.CALL_FAILOVER_TIMEOUT, ConnectionFactoryAttributes.Common.CONSUMER_WINDOW_SIZE, ConnectionFactoryAttributes.Common.CONSUMER_MAX_RATE, ConnectionFactoryAttributes.Common.CONFIRMATION_WINDOW_SIZE, ConnectionFactoryAttributes.Common.PRODUCER_WINDOW_SIZE, ConnectionFactoryAttributes.Common.PRODUCER_MAX_RATE, ConnectionFactoryAttributes.Common.PROTOCOL_MANAGER_FACTORY, ConnectionFactoryAttributes.Common.COMPRESS_LARGE_MESSAGES, ConnectionFactoryAttributes.Common.CACHE_LARGE_MESSAGE_CLIENT, CommonAttributes.MIN_LARGE_MESSAGE_SIZE, CommonAttributes.CLIENT_ID, ConnectionFactoryAttributes.Common.DUPS_OK_BATCH_SIZE, ConnectionFactoryAttributes.Common.TRANSACTION_BATCH_SIZE, ConnectionFactoryAttributes.Common.BLOCK_ON_ACKNOWLEDGE, ConnectionFactoryAttributes.Common.BLOCK_ON_NON_DURABLE_SEND, ConnectionFactoryAttributes.Common.BLOCK_ON_DURABLE_SEND, ConnectionFactoryAttributes.Common.AUTO_GROUP, ConnectionFactoryAttributes.Common.PRE_ACKNOWLEDGE, ConnectionFactoryAttributes.Common.RETRY_INTERVAL, ConnectionFactoryAttributes.Common.RETRY_INTERVAL_MULTIPLIER, CommonAttributes.MAX_RETRY_INTERVAL, ConnectionFactoryAttributes.Common.RECONNECT_ATTEMPTS, ConnectionFactoryAttributes.Common.FAILOVER_ON_INITIAL_CONNECTION, ConnectionFactoryAttributes.Common.CONNECTION_LOAD_BALANCING_CLASS_NAME, ConnectionFactoryAttributes.Common.USE_GLOBAL_POOLS, ConnectionFactoryAttributes.Common.SCHEDULED_THREAD_POOL_MAX_SIZE, ConnectionFactoryAttributes.Common.THREAD_POOL_MAX_SIZE, ConnectionFactoryAttributes.Common.GROUP_ID, ConnectionFactoryAttributes.Common.DESERIALIZATION_BLACKLIST, ConnectionFactoryAttributes.Common.DESERIALIZATION_WHITELIST, ConnectionFactoryAttributes.Common.INITIAL_MESSAGE_PACKET_SIZE, ConnectionFactoryAttributes.Regular.FACTORY_TYPE, ConnectionFactoryAttributes.Common.USE_TOPOLOGY)).addChild(builder(MessagingExtension.LEGACY_CONNECTION_FACTORY_PATH).addAttributes(LegacyConnectionFactoryDefinition.ENTRIES, LegacyConnectionFactoryDefinition.DISCOVERY_GROUP, LegacyConnectionFactoryDefinition.CONNECTORS, LegacyConnectionFactoryDefinition.AUTO_GROUP, LegacyConnectionFactoryDefinition.BLOCK_ON_ACKNOWLEDGE, LegacyConnectionFactoryDefinition.BLOCK_ON_DURABLE_SEND, LegacyConnectionFactoryDefinition.BLOCK_ON_NON_DURABLE_SEND, CommonAttributes.CALL_TIMEOUT, CommonAttributes.CALL_FAILOVER_TIMEOUT, LegacyConnectionFactoryDefinition.CACHE_LARGE_MESSAGE_CLIENT, LegacyConnectionFactoryDefinition.CLIENT_FAILURE_CHECK_PERIOD, CommonAttributes.CLIENT_ID, LegacyConnectionFactoryDefinition.COMPRESS_LARGE_MESSAGES, LegacyConnectionFactoryDefinition.CONFIRMATION_WINDOW_SIZE, LegacyConnectionFactoryDefinition.CONNECTION_LOAD_BALANCING_CLASS_NAME, LegacyConnectionFactoryDefinition.CONNECTION_TTL, LegacyConnectionFactoryDefinition.CONSUMER_MAX_RATE, LegacyConnectionFactoryDefinition.CONSUMER_WINDOW_SIZE, LegacyConnectionFactoryDefinition.DUPS_OK_BATCH_SIZE, LegacyConnectionFactoryDefinition.FACTORY_TYPE, LegacyConnectionFactoryDefinition.FAILOVER_ON_INITIAL_CONNECTION, LegacyConnectionFactoryDefinition.GROUP_ID, LegacyConnectionFactoryDefinition.INITIAL_CONNECT_ATTEMPTS, LegacyConnectionFactoryDefinition.INITIAL_MESSAGE_PACKET_SIZE, LegacyConnectionFactoryDefinition.HA, LegacyConnectionFactoryDefinition.MAX_RETRY_INTERVAL, LegacyConnectionFactoryDefinition.MIN_LARGE_MESSAGE_SIZE, LegacyConnectionFactoryDefinition.PRE_ACKNOWLEDGE, LegacyConnectionFactoryDefinition.PRODUCER_MAX_RATE, LegacyConnectionFactoryDefinition.PRODUCER_WINDOW_SIZE, LegacyConnectionFactoryDefinition.RECONNECT_ATTEMPTS, LegacyConnectionFactoryDefinition.RETRY_INTERVAL, LegacyConnectionFactoryDefinition.RETRY_INTERVAL_MULTIPLIER, LegacyConnectionFactoryDefinition.SCHEDULED_THREAD_POOL_MAX_SIZE, LegacyConnectionFactoryDefinition.THREAD_POOL_MAX_SIZE, LegacyConnectionFactoryDefinition.TRANSACTION_BATCH_SIZE, LegacyConnectionFactoryDefinition.USE_GLOBAL_POOLS)).addChild(createPooledConnectionFactory(false))).addChild(builder(MessagingExtension.JMS_BRIDGE_PATH).addAttributes(JMSBridgeDefinition.MODULE, JMSBridgeDefinition.QUALITY_OF_SERVICE, JMSBridgeDefinition.FAILURE_RETRY_INTERVAL, JMSBridgeDefinition.MAX_RETRIES, JMSBridgeDefinition.MAX_BATCH_SIZE, JMSBridgeDefinition.MAX_BATCH_TIME, CommonAttributes.SELECTOR, JMSBridgeDefinition.SUBSCRIPTION_NAME, CommonAttributes.CLIENT_ID, JMSBridgeDefinition.ADD_MESSAGE_ID_IN_HEADER, JMSBridgeDefinition.SOURCE_CONNECTION_FACTORY, JMSBridgeDefinition.SOURCE_DESTINATION, JMSBridgeDefinition.SOURCE_USER, JMSBridgeDefinition.SOURCE_PASSWORD, JMSBridgeDefinition.SOURCE_CREDENTIAL_REFERENCE, JMSBridgeDefinition.TARGET_CONNECTION_FACTORY, JMSBridgeDefinition.TARGET_DESTINATION, JMSBridgeDefinition.TARGET_USER, JMSBridgeDefinition.TARGET_PASSWORD, JMSBridgeDefinition.TARGET_CREDENTIAL_REFERENCE, JMSBridgeDefinition.SOURCE_CONTEXT, JMSBridgeDefinition.TARGET_CONTEXT)).build();
}
</code></pre></div></td>
</tr>
<tr>
    <td>13</td><td>13054.64</td><td>20</td><td>340</td>
    <td><div class="code-container"><pre><code class="language-java">public void test(@ArquillianResource(SessionOperationServlet.class) @OperateOnDeployment(DEPLOYMENT_1) URL baseURL1, @ArquillianResource(SessionOperationServlet.class) @OperateOnDeployment(DEPLOYMENT_2) URL baseURL2) throws IOException, URISyntaxException, InterruptedException {
    String sessionId;
    try (CloseableHttpClient client = TestHttpClientUtils.promiscuousCookieHttpClient()) {
        try (CloseableHttpResponse response = client.execute(new HttpGet(SessionOperationServlet.createSetURI(baseURL1, &quot;a&quot;)))) {
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.SESSION_ID));
            sessionId = response.getFirstHeader(SessionOperationServlet.SESSION_ID).getValue();
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.CREATED_SESSIONS));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.DESTROYED_SESSIONS));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.ADDED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.REPLACED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.REMOVED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.BOUND_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.UNBOUND_ATTRIBUTES));
            Assert.assertEquals(sessionId, response.getFirstHeader(SessionOperationServlet.CREATED_SESSIONS).getValue());
        }
        try (CloseableHttpResponse response = client.execute(new HttpGet(SessionOperationServlet.createSetURI(baseURL1, &quot;a&quot;, &quot;1&quot;)))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.SESSION_ID));
            Assert.assertEquals(sessionId, response.getFirstHeader(SessionOperationServlet.SESSION_ID).getValue());
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.CREATED_SESSIONS));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.DESTROYED_SESSIONS));
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.ADDED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.REPLACED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.REMOVED_ATTRIBUTES));
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.BOUND_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.UNBOUND_ATTRIBUTES));
            Assert.assertEquals(&quot;a&quot;, response.getFirstHeader(SessionOperationServlet.ADDED_ATTRIBUTES).getValue());
            Assert.assertEquals(&quot;1&quot;, response.getFirstHeader(SessionOperationServlet.BOUND_ATTRIBUTES).getValue());
        }
        if (!this.transactional) {
            Thread.sleep(AbstractClusteringTestCase.GRACE_TIME_TO_REPLICATE);
        }
        try (CloseableHttpResponse response = client.execute(new HttpGet(SessionOperationServlet.createGetURI(baseURL2, &quot;a&quot;)))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.SESSION_ID));
            Assert.assertEquals(sessionId, response.getFirstHeader(SessionOperationServlet.SESSION_ID).getValue());
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.RESULT));
            Assert.assertEquals(&quot;1&quot;, response.getFirstHeader(SessionOperationServlet.RESULT).getValue());
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.CREATED_SESSIONS));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.DESTROYED_SESSIONS));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.ADDED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.REPLACED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.REMOVED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.BOUND_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.UNBOUND_ATTRIBUTES));
        }
        try (CloseableHttpResponse response = client.execute(new HttpGet(SessionOperationServlet.createRemoveURI(baseURL2, &quot;b&quot;)))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.SESSION_ID));
            Assert.assertEquals(sessionId, response.getFirstHeader(SessionOperationServlet.SESSION_ID).getValue());
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.RESULT));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.CREATED_SESSIONS));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.DESTROYED_SESSIONS));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.ADDED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.REPLACED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.REMOVED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.BOUND_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.UNBOUND_ATTRIBUTES));
        }
        if (!this.transactional) {
            Thread.sleep(AbstractClusteringTestCase.GRACE_TIME_TO_REPLICATE);
        }
        try (CloseableHttpResponse response = client.execute(new HttpGet(SessionOperationServlet.createSetURI(baseURL1, &quot;a&quot;, &quot;2&quot;)))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.SESSION_ID));
            Assert.assertEquals(sessionId, response.getFirstHeader(SessionOperationServlet.SESSION_ID).getValue());
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.CREATED_SESSIONS));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.DESTROYED_SESSIONS));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.ADDED_ATTRIBUTES));
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.REPLACED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.REMOVED_ATTRIBUTES));
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.BOUND_ATTRIBUTES));
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.UNBOUND_ATTRIBUTES));
            Assert.assertEquals(&quot;a&quot;, response.getFirstHeader(SessionOperationServlet.REPLACED_ATTRIBUTES).getValue());
            Assert.assertEquals(&quot;2&quot;, response.getFirstHeader(SessionOperationServlet.BOUND_ATTRIBUTES).getValue());
            Assert.assertEquals(&quot;1&quot;, response.getFirstHeader(SessionOperationServlet.UNBOUND_ATTRIBUTES).getValue());
        }
        if (!this.transactional) {
            Thread.sleep(AbstractClusteringTestCase.GRACE_TIME_TO_REPLICATE);
        }
        try (CloseableHttpResponse response = client.execute(new HttpGet(SessionOperationServlet.createGetURI(baseURL2, &quot;a&quot;)))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.SESSION_ID));
            Assert.assertEquals(sessionId, response.getFirstHeader(SessionOperationServlet.SESSION_ID).getValue());
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.RESULT));
            Assert.assertEquals(&quot;2&quot;, response.getFirstHeader(SessionOperationServlet.RESULT).getValue());
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.CREATED_SESSIONS));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.DESTROYED_SESSIONS));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.ADDED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.REPLACED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.REMOVED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.BOUND_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.UNBOUND_ATTRIBUTES));
        }
        if (!this.transactional) {
            Thread.sleep(AbstractClusteringTestCase.GRACE_TIME_TO_REPLICATE);
        }
        try (CloseableHttpResponse response = client.execute(new HttpGet(SessionOperationServlet.createSetURI(baseURL1, &quot;a&quot;)))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.SESSION_ID));
            Assert.assertEquals(sessionId, response.getFirstHeader(SessionOperationServlet.SESSION_ID).getValue());
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.CREATED_SESSIONS));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.DESTROYED_SESSIONS));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.ADDED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.REPLACED_ATTRIBUTES));
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.REMOVED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.BOUND_ATTRIBUTES));
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.UNBOUND_ATTRIBUTES));
            Assert.assertEquals(&quot;a&quot;, response.getFirstHeader(SessionOperationServlet.REMOVED_ATTRIBUTES).getValue());
            Assert.assertEquals(&quot;2&quot;, response.getFirstHeader(SessionOperationServlet.UNBOUND_ATTRIBUTES).getValue());
        }
        if (!this.transactional) {
            Thread.sleep(AbstractClusteringTestCase.GRACE_TIME_TO_REPLICATE);
        }
        try (CloseableHttpResponse response = client.execute(new HttpGet(SessionOperationServlet.createGetURI(baseURL2, &quot;a&quot;)))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.SESSION_ID));
            Assert.assertEquals(sessionId, response.getFirstHeader(SessionOperationServlet.SESSION_ID).getValue());
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.RESULT));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.CREATED_SESSIONS));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.DESTROYED_SESSIONS));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.ADDED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.REPLACED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.REMOVED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.BOUND_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.UNBOUND_ATTRIBUTES));
        }
        if (!this.transactional) {
            Thread.sleep(AbstractClusteringTestCase.GRACE_TIME_TO_REPLICATE);
        }
        try (CloseableHttpResponse response = client.execute(new HttpGet(SessionOperationServlet.createSetURI(baseURL1, &quot;a&quot;, &quot;3&quot;, &quot;4&quot;)))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.SESSION_ID));
            Assert.assertEquals(sessionId, response.getFirstHeader(SessionOperationServlet.SESSION_ID).getValue());
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.CREATED_SESSIONS));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.DESTROYED_SESSIONS));
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.ADDED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.REPLACED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.REMOVED_ATTRIBUTES));
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.BOUND_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.UNBOUND_ATTRIBUTES));
            Assert.assertEquals(&quot;a&quot;, response.getFirstHeader(SessionOperationServlet.ADDED_ATTRIBUTES).getValue());
            Assert.assertEquals(&quot;3&quot;, response.getFirstHeader(SessionOperationServlet.BOUND_ATTRIBUTES).getValue());
        }
        if (!this.transactional) {
            Thread.sleep(AbstractClusteringTestCase.GRACE_TIME_TO_REPLICATE);
        }
        try (CloseableHttpResponse response = client.execute(new HttpGet(SessionOperationServlet.createGetURI(baseURL2, &quot;a&quot;)))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.SESSION_ID));
            Assert.assertEquals(sessionId, response.getFirstHeader(SessionOperationServlet.SESSION_ID).getValue());
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.RESULT));
            Assert.assertEquals(&quot;4&quot;, response.getFirstHeader(SessionOperationServlet.RESULT).getValue());
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.CREATED_SESSIONS));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.DESTROYED_SESSIONS));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.ADDED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.REPLACED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.REMOVED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.BOUND_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.UNBOUND_ATTRIBUTES));
        }
        if (!this.transactional) {
            Thread.sleep(AbstractClusteringTestCase.GRACE_TIME_TO_REPLICATE);
        }
        try (CloseableHttpResponse response = client.execute(new HttpGet(SessionOperationServlet.createRemoveURI(baseURL1, &quot;a&quot;)))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.SESSION_ID));
            Assert.assertEquals(sessionId, response.getFirstHeader(SessionOperationServlet.SESSION_ID).getValue());
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.CREATED_SESSIONS));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.DESTROYED_SESSIONS));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.ADDED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.REPLACED_ATTRIBUTES));
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.REMOVED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.BOUND_ATTRIBUTES));
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.UNBOUND_ATTRIBUTES));
            Assert.assertEquals(&quot;a&quot;, response.getFirstHeader(SessionOperationServlet.REMOVED_ATTRIBUTES).getValue());
            Assert.assertEquals(&quot;4&quot;, response.getFirstHeader(SessionOperationServlet.UNBOUND_ATTRIBUTES).getValue());
        }
        if (!this.transactional) {
            Thread.sleep(AbstractClusteringTestCase.GRACE_TIME_TO_REPLICATE);
        }
        try (CloseableHttpResponse response = client.execute(new HttpGet(SessionOperationServlet.createGetURI(baseURL2, &quot;a&quot;)))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.SESSION_ID));
            Assert.assertEquals(sessionId, response.getFirstHeader(SessionOperationServlet.SESSION_ID).getValue());
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.RESULT));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.CREATED_SESSIONS));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.DESTROYED_SESSIONS));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.ADDED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.REPLACED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.REMOVED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.BOUND_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.UNBOUND_ATTRIBUTES));
        }
        try (CloseableHttpResponse response = client.execute(new HttpGet(SessionOperationServlet.createSetURI(baseURL2, &quot;a&quot;, &quot;5&quot;)))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.SESSION_ID));
            Assert.assertEquals(sessionId, response.getFirstHeader(SessionOperationServlet.SESSION_ID).getValue());
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.CREATED_SESSIONS));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.DESTROYED_SESSIONS));
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.ADDED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.REPLACED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.REMOVED_ATTRIBUTES));
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.BOUND_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.UNBOUND_ATTRIBUTES));
            Assert.assertEquals(&quot;a&quot;, response.getFirstHeader(SessionOperationServlet.ADDED_ATTRIBUTES).getValue());
            Assert.assertEquals(&quot;5&quot;, response.getFirstHeader(SessionOperationServlet.BOUND_ATTRIBUTES).getValue());
        }
        if (!this.transactional) {
            Thread.sleep(AbstractClusteringTestCase.GRACE_TIME_TO_REPLICATE);
        }
        try (CloseableHttpResponse response = client.execute(new HttpGet(SessionOperationServlet.createInvalidateURI(baseURL1)))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.SESSION_ID));
            Assert.assertEquals(sessionId, response.getFirstHeader(SessionOperationServlet.SESSION_ID).getValue());
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.CREATED_SESSIONS));
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.DESTROYED_SESSIONS));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.ADDED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.REPLACED_ATTRIBUTES));
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.REMOVED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.BOUND_ATTRIBUTES));
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.UNBOUND_ATTRIBUTES));
            Assert.assertEquals(response.getFirstHeader(SessionOperationServlet.SESSION_ID).getValue(), response.getFirstHeader(SessionOperationServlet.DESTROYED_SESSIONS).getValue());
            Assert.assertEquals(&quot;a&quot;, response.getFirstHeader(SessionOperationServlet.REMOVED_ATTRIBUTES).getValue());
            Assert.assertEquals(&quot;5&quot;, response.getFirstHeader(SessionOperationServlet.UNBOUND_ATTRIBUTES).getValue());
        }
        if (!this.transactional) {
            Thread.sleep(AbstractClusteringTestCase.GRACE_TIME_TO_REPLICATE);
        }
        try (CloseableHttpResponse response = client.execute(new HttpGet(SessionOperationServlet.createSetURI(baseURL2, &quot;a&quot;, &quot;6&quot;)))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.SESSION_ID));
            sessionId = response.getFirstHeader(SessionOperationServlet.SESSION_ID).getValue();
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.CREATED_SESSIONS));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.DESTROYED_SESSIONS));
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.ADDED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.REPLACED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.REMOVED_ATTRIBUTES));
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.BOUND_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.UNBOUND_ATTRIBUTES));
            Assert.assertEquals(response.getFirstHeader(SessionOperationServlet.SESSION_ID).getValue(), response.getFirstHeader(SessionOperationServlet.CREATED_SESSIONS).getValue());
            Assert.assertEquals(&quot;a&quot;, response.getFirstHeader(SessionOperationServlet.ADDED_ATTRIBUTES).getValue());
            Assert.assertEquals(&quot;6&quot;, response.getFirstHeader(SessionOperationServlet.BOUND_ATTRIBUTES).getValue());
        }
        try (CloseableHttpResponse response = client.execute(new HttpGet(SessionOperationServlet.createGetAndSetURI(baseURL2, &quot;a&quot;, &quot;7&quot;)))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.SESSION_ID));
            Assert.assertEquals(sessionId, response.getFirstHeader(SessionOperationServlet.SESSION_ID).getValue());
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.RESULT));
            Assert.assertEquals(&quot;6&quot;, response.getFirstHeader(SessionOperationServlet.RESULT).getValue());
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.CREATED_SESSIONS));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.DESTROYED_SESSIONS));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.ADDED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.REPLACED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.REMOVED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.BOUND_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.UNBOUND_ATTRIBUTES));
        }
        try (CloseableHttpResponse response = client.execute(new HttpGet(SessionOperationServlet.createGetURI(baseURL2, &quot;a&quot;)))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.SESSION_ID));
            Assert.assertEquals(sessionId, response.getFirstHeader(SessionOperationServlet.SESSION_ID).getValue());
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.RESULT));
            Assert.assertEquals(&quot;7&quot;, response.getFirstHeader(SessionOperationServlet.RESULT).getValue());
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.CREATED_SESSIONS));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.DESTROYED_SESSIONS));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.ADDED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.REPLACED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.REMOVED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.BOUND_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.UNBOUND_ATTRIBUTES));
        }
        if (!this.transactional) {
            Thread.sleep(AbstractClusteringTestCase.GRACE_TIME_TO_REPLICATE);
        }
        try (CloseableHttpResponse response = client.execute(new HttpGet(SessionOperationServlet.createTimeoutURI(baseURL1, 1)))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertTrue(response.containsHeader(SessionOperationServlet.SESSION_ID));
            Assert.assertEquals(sessionId, response.getFirstHeader(SessionOperationServlet.SESSION_ID).getValue());
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.RESULT));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.CREATED_SESSIONS));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.DESTROYED_SESSIONS));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.ADDED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.REPLACED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.REMOVED_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.BOUND_ATTRIBUTES));
            Assert.assertFalse(response.containsHeader(SessionOperationServlet.UNBOUND_ATTRIBUTES));
            sessionId = response.getFirstHeader(SessionOperationServlet.SESSION_ID).getValue();
        }
        Instant start = Instant.now();
        while (Instant.now().isBefore(start.plus(EXPIRATION_DURATION))) {
            try (CloseableHttpResponse response = client.execute(new HttpGet(SessionOperationServlet.createGetURI(baseURL1, &quot;a&quot;)))) {
                Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
                Assert.assertTrue(response.containsHeader(SessionOperationServlet.SESSION_ID));
                Assert.assertEquals(sessionId, response.getFirstHeader(SessionOperationServlet.SESSION_ID).getValue());
            }
            Thread.sleep(100);
        }
    }
    Thread.sleep(EXPIRATION_DURATION.toMillis());
    try (CloseableHttpClient client = TestHttpClientUtils.promiscuousCookieHttpClient()) {
        boolean destroyed = false;
        String newSessionId = null;
        int maxAttempts = 30;
        for (int attempt = 1; attempt &lt;= maxAttempts &amp;&amp; !destroyed; attempt++) {
            for (URL baseURL : Arrays.asList(baseURL1, baseURL2)) {
                if (!destroyed) {
                    try (CloseableHttpResponse response = client.execute(new HttpGet(SessionOperationServlet.createGetURI(baseURL, &quot;a&quot;, sessionId)))) {
                        Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
                        Assert.assertFalse(response.containsHeader(SessionOperationServlet.RESULT));
                        Assert.assertTrue(response.containsHeader(SessionOperationServlet.SESSION_ID));
                        Assert.assertEquals(newSessionId == null, response.containsHeader(SessionOperationServlet.CREATED_SESSIONS));
                        if (newSessionId == null) {
                            newSessionId = response.getFirstHeader(SessionOperationServlet.SESSION_ID).getValue();
                        } else {
                            Assert.assertEquals(newSessionId, response.getFirstHeader(SessionOperationServlet.SESSION_ID).getValue());
                        }
                        destroyed = response.containsHeader(SessionOperationServlet.DESTROYED_SESSIONS);
                        Assert.assertFalse(response.containsHeader(SessionOperationServlet.ADDED_ATTRIBUTES));
                        Assert.assertFalse(response.containsHeader(SessionOperationServlet.REPLACED_ATTRIBUTES));
                        Assert.assertEquals(destroyed, response.containsHeader(SessionOperationServlet.REMOVED_ATTRIBUTES));
                        Assert.assertFalse(response.containsHeader(SessionOperationServlet.BOUND_ATTRIBUTES));
                        Assert.assertEquals(destroyed, response.containsHeader(SessionOperationServlet.UNBOUND_ATTRIBUTES));
                        if (destroyed) {
                            Assert.assertEquals(sessionId, response.getFirstHeader(SessionOperationServlet.DESTROYED_SESSIONS).getValue());
                            Assert.assertEquals(&quot;a&quot;, response.getFirstHeader(SessionOperationServlet.REMOVED_ATTRIBUTES).getValue());
                            Assert.assertEquals(&quot;7&quot;, response.getFirstHeader(SessionOperationServlet.UNBOUND_ATTRIBUTES).getValue());
                            log.infof(&quot;Session destroyed within %d attempts.&quot;, attempt);
                        }
                    }
                }
            }
            Thread.sleep(TimeUnit.SECONDS.toMillis(1));
        }
        Assert.assertTrue(&quot;Session has not been destroyed following expiration within &quot; + maxAttempts + &quot; attempts.&quot;, destroyed);
    }
}
</code></pre></div></td>
</tr>
<tr>
    <td>14</td><td>5349.97</td><td>62</td><td>208</td>
    <td><div class="code-container"><pre><code class="language-java">public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {
    final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();
    final EjbJarMetaData metaData = deploymentUnit.getAttachment(EjbDeploymentAttachmentKeys.EJB_JAR_METADATA);
    if (metaData == null || metaData.getAssemblyDescriptor() == null) {
        return;
    }
    final EEModuleDescription eeModuleDescription = deploymentUnit.getAttachment(Attachments.EE_MODULE_DESCRIPTION);
    final Module module = deploymentUnit.getAttachment(org.jboss.as.server.deployment.Attachments.MODULE);
    final DeploymentReflectionIndex index = deploymentUnit.getAttachment(org.jboss.as.server.deployment.Attachments.REFLECTION_INDEX);
    final List&lt;ContainerInterceptorsMetaData&gt; containerInterceptorConfigurations = metaData.getAssemblyDescriptor().getAny(ContainerInterceptorsMetaData.class);
    if (containerInterceptorConfigurations == null || containerInterceptorConfigurations.isEmpty()) {
        return;
    }
    final ContainerInterceptorsMetaData containerInterceptorsMetaData = containerInterceptorConfigurations.get(0);
    if (containerInterceptorsMetaData == null) {
        return;
    }
    final InterceptorBindingsMetaData containerInterceptorBindings = containerInterceptorsMetaData.getInterceptorBindings();
    if (containerInterceptorBindings == null || containerInterceptorBindings.isEmpty()) {
        return;
    }
    final Map&lt;String, List&lt;InterceptorBindingMetaData&gt;&gt; bindingsPerEJB = new HashMap&lt;String, List&lt;InterceptorBindingMetaData&gt;&gt;();
    final List&lt;InterceptorBindingMetaData&gt; bindingsForAllEJBs = new ArrayList&lt;InterceptorBindingMetaData&gt;();
    for (final InterceptorBindingMetaData containerInterceptorBinding : containerInterceptorBindings) {
        if (containerInterceptorBinding.getEjbName().equals(&quot;*&quot;)) {
            if (containerInterceptorBinding.getMethod() != null) {
                throw EjbLogger.ROOT_LOGGER.defaultInterceptorsNotBindToMethod();
            }
            if (containerInterceptorBinding.getInterceptorOrder() != null) {
                throw EjbLogger.ROOT_LOGGER.defaultInterceptorsNotSpecifyOrder();
            }
            bindingsForAllEJBs.add(containerInterceptorBinding);
        } else {
            List&lt;InterceptorBindingMetaData&gt; bindings = bindingsPerEJB.get(containerInterceptorBinding.getEjbName());
            if (bindings == null) {
                bindings = new ArrayList&lt;InterceptorBindingMetaData&gt;();
                bindingsPerEJB.put(containerInterceptorBinding.getEjbName(), bindings);
            }
            bindings.add(containerInterceptorBinding);
        }
    }
    final List&lt;InterceptorDescription&gt; interceptorDescriptionsForAllEJBs = new ArrayList&lt;InterceptorDescription&gt;();
    for (InterceptorBindingMetaData binding : bindingsForAllEJBs) {
        if (binding.getInterceptorClasses() != null) {
            for (final String clazz : binding.getInterceptorClasses()) {
                interceptorDescriptionsForAllEJBs.add(new InterceptorDescription(clazz));
            }
        }
    }
    for (final ComponentDescription componentDescription : eeModuleDescription.getComponentDescriptions()) {
        if (!(componentDescription instanceof EJBComponentDescription)) {
            continue;
        }
        final EJBComponentDescription ejbComponentDescription = (EJBComponentDescription) componentDescription;
        final Class&lt;?&gt; componentClass;
        try {
            componentClass = module.getClassLoader().loadClass(ejbComponentDescription.getComponentClassName());
        } catch (ClassNotFoundException e) {
            throw EjbLogger.ROOT_LOGGER.failToLoadComponentClass(e, ejbComponentDescription.getComponentClassName());
        }
        final List&lt;InterceptorBindingMetaData&gt; bindingsApplicableForCurrentEJB = bindingsPerEJB.get(ejbComponentDescription.getComponentName());
        final Map&lt;Method, List&lt;InterceptorBindingMetaData&gt;&gt; methodInterceptors = new HashMap&lt;Method, List&lt;InterceptorBindingMetaData&gt;&gt;();
        final List&lt;InterceptorBindingMetaData&gt; classLevelBindings = new ArrayList&lt;InterceptorBindingMetaData&gt;();
        boolean classLevelExcludeDefaultInterceptors = false;
        Map&lt;Method, Boolean&gt; methodLevelExcludeDefaultInterceptors = new HashMap&lt;Method, Boolean&gt;();
        Map&lt;Method, Boolean&gt; methodLevelExcludeClassInterceptors = new HashMap&lt;Method, Boolean&gt;();
        boolean classLevelAbsoluteOrder = false;
        final Map&lt;Method, Boolean&gt; methodLevelAbsoluteOrder = new HashMap&lt;Method, Boolean&gt;();
        if (bindingsApplicableForCurrentEJB != null) {
            for (final InterceptorBindingMetaData binding : bindingsApplicableForCurrentEJB) {
                if (binding.getMethod() == null) {
                    classLevelBindings.add(binding);
                    if (binding.isExcludeDefaultInterceptors()) {
                        classLevelExcludeDefaultInterceptors = true;
                    }
                    if (binding.isTotalOrdering()) {
                        if (classLevelAbsoluteOrder) {
                            throw EjbLogger.ROOT_LOGGER.twoEjbBindingsSpecifyAbsoluteOrder(componentClass.toString());
                        } else {
                            classLevelAbsoluteOrder = true;
                        }
                    }
                } else {
                    final NamedMethodMetaData methodData = binding.getMethod();
                    final ClassReflectionIndex classIndex = index.getClassIndex(componentClass);
                    Method resolvedMethod = null;
                    if (methodData.getMethodParams() == null) {
                        final Collection&lt;Method&gt; methods = classIndex.getAllMethods(methodData.getMethodName());
                        if (methods.isEmpty()) {
                            throw EjbLogger.ROOT_LOGGER.failToFindMethodInEjbJarXml(componentClass.getName(), methodData.getMethodName());
                        } else if (methods.size() &gt; 1) {
                            throw EjbLogger.ROOT_LOGGER.multipleMethodReferencedInEjbJarXml(methodData.getMethodName(), componentClass.getName());
                        }
                        resolvedMethod = methods.iterator().next();
                    } else {
                        final Collection&lt;Method&gt; methods = classIndex.getAllMethods(methodData.getMethodName(), methodData.getMethodParams().size());
                        for (final Method method : methods) {
                            boolean match = true;
                            for (int i = 0; i &lt; method.getParameterCount(); ++i) {
                                if (!method.getParameterTypes()[i].getName().equals(methodData.getMethodParams().get(i))) {
                                    match = false;
                                    break;
                                }
                            }
                            if (match) {
                                resolvedMethod = method;
                                break;
                            }
                        }
                        if (resolvedMethod == null) {
                            throw EjbLogger.ROOT_LOGGER.failToFindMethodWithParameterTypes(componentClass.getName(), methodData.getMethodName(), methodData.getMethodParams());
                        }
                    }
                    List&lt;InterceptorBindingMetaData&gt; methodSpecificInterceptorBindings = methodInterceptors.get(resolvedMethod);
                    if (methodSpecificInterceptorBindings == null) {
                        methodSpecificInterceptorBindings = new ArrayList&lt;InterceptorBindingMetaData&gt;();
                        methodInterceptors.put(resolvedMethod, methodSpecificInterceptorBindings);
                    }
                    methodSpecificInterceptorBindings.add(binding);
                    if (binding.isExcludeDefaultInterceptors()) {
                        methodLevelExcludeDefaultInterceptors.put(resolvedMethod, true);
                    }
                    if (binding.isExcludeClassInterceptors()) {
                        methodLevelExcludeClassInterceptors.put(resolvedMethod, true);
                    }
                    if (binding.isTotalOrdering()) {
                        if (methodLevelAbsoluteOrder.containsKey(resolvedMethod)) {
                            throw EjbLogger.ROOT_LOGGER.twoEjbBindingsSpecifyAbsoluteOrder(resolvedMethod.toString());
                        } else {
                            methodLevelAbsoluteOrder.put(resolvedMethod, true);
                        }
                    }
                }
            }
        }
        ejbComponentDescription.setDefaultContainerInterceptors(interceptorDescriptionsForAllEJBs);
        if (classLevelExcludeDefaultInterceptors) {
            ejbComponentDescription.setExcludeDefaultContainerInterceptors(true);
        }
        final List&lt;InterceptorDescription&gt; classLevelInterceptors = new ArrayList&lt;InterceptorDescription&gt;();
        if (classLevelAbsoluteOrder) {
            for (final InterceptorBindingMetaData binding : classLevelBindings) {
                if (binding.isTotalOrdering()) {
                    for (final String interceptor : binding.getInterceptorOrder()) {
                        classLevelInterceptors.add(new InterceptorDescription(interceptor));
                    }
                    break;
                }
            }
            ejbComponentDescription.setExcludeDefaultContainerInterceptors(true);
        } else {
            for (InterceptorBindingMetaData binding : classLevelBindings) {
                if (binding.getInterceptorClasses() != null) {
                    for (final String interceptor : binding.getInterceptorClasses()) {
                        classLevelInterceptors.add(new InterceptorDescription(interceptor));
                    }
                }
            }
        }
        ejbComponentDescription.setClassLevelContainerInterceptors(classLevelInterceptors);
        for (Map.Entry&lt;Method, List&lt;InterceptorBindingMetaData&gt;&gt; entry : methodInterceptors.entrySet()) {
            final Method method = entry.getKey();
            final List&lt;InterceptorBindingMetaData&gt; methodBindings = entry.getValue();
            boolean totalOrder = methodLevelAbsoluteOrder.containsKey(method);
            final MethodIdentifier methodIdentifier = MethodIdentifier.getIdentifierForMethod(method);
            Boolean excludeDefaultInterceptors = methodLevelExcludeDefaultInterceptors.get(method);
            excludeDefaultInterceptors = excludeDefaultInterceptors == null ? Boolean.FALSE : excludeDefaultInterceptors;
            if (!excludeDefaultInterceptors) {
                excludeDefaultInterceptors = ejbComponentDescription.isExcludeDefaultContainerInterceptors() || ejbComponentDescription.isExcludeDefaultContainerInterceptors(methodIdentifier);
            }
            Boolean excludeClassInterceptors = methodLevelExcludeClassInterceptors.get(method);
            excludeClassInterceptors = excludeClassInterceptors == null ? Boolean.FALSE : excludeClassInterceptors;
            if (!excludeClassInterceptors) {
                excludeClassInterceptors = ejbComponentDescription.isExcludeClassLevelContainerInterceptors(methodIdentifier);
            }
            final List&lt;InterceptorDescription&gt; methodLevelInterceptors = new ArrayList&lt;InterceptorDescription&gt;();
            if (totalOrder) {
                for (final InterceptorBindingMetaData binding : methodBindings) {
                    if (binding.isTotalOrdering()) {
                        for (final String interceptor : binding.getInterceptorOrder()) {
                            methodLevelInterceptors.add(new InterceptorDescription(interceptor));
                        }
                    }
                }
            } else {
                if (!excludeDefaultInterceptors) {
                    methodLevelInterceptors.addAll(interceptorDescriptionsForAllEJBs);
                }
                if (!excludeClassInterceptors) {
                    for (InterceptorDescription interceptor : classLevelInterceptors) {
                        methodLevelInterceptors.add(interceptor);
                    }
                }
                for (final InterceptorBindingMetaData binding : methodBindings) {
                    if (binding.getInterceptorClasses() != null) {
                        for (final String interceptor : binding.getInterceptorClasses()) {
                            methodLevelInterceptors.add(new InterceptorDescription(interceptor));
                        }
                    }
                }
            }
            ejbComponentDescription.excludeClassLevelContainerInterceptors(methodIdentifier);
            ejbComponentDescription.excludeDefaultContainerInterceptors(methodIdentifier);
            ejbComponentDescription.setMethodContainerInterceptors(methodIdentifier, methodLevelInterceptors);
        }
    }
}
</code></pre></div></td>
</tr>
<tr>
    <td>15</td><td>3496.15</td><td>58</td><td>237</td>
    <td><div class="code-container"><pre><code class="language-java">public void configure(final DeploymentPhaseContext context, final ComponentDescription description, final ComponentConfiguration configuration) throws DeploymentUnitProcessingException {
    final DeploymentUnit deploymentUnit = context.getDeploymentUnit();
    final DeploymentReflectionIndex deploymentReflectionIndex = deploymentUnit.getAttachment(REFLECTION_INDEX);
    final EEApplicationClasses applicationClasses = deploymentUnit.getAttachment(Attachments.EE_APPLICATION_CLASSES_DESCRIPTION);
    final EEModuleDescription moduleDescription = deploymentUnit.getAttachment(Attachments.EE_MODULE_DESCRIPTION);
    final Module module = deploymentUnit.getAttachment(org.jboss.as.server.deployment.Attachments.MODULE);
    final boolean metadataComplete = MetadataCompleteMarker.isMetadataComplete(deploymentUnit);
    final Deque&lt;InterceptorFactory&gt; instantiators = new ArrayDeque&lt;&gt;();
    final Deque&lt;InterceptorFactory&gt; injectors = new ArrayDeque&lt;&gt;();
    final Deque&lt;InterceptorFactory&gt; uninjectors = new ArrayDeque&lt;&gt;();
    final Deque&lt;InterceptorFactory&gt; destructors = new ArrayDeque&lt;&gt;();
    final Map&lt;String, List&lt;InterceptorFactory&gt;&gt; userAroundInvokesByInterceptorClass = new HashMap&lt;&gt;();
    final Map&lt;String, List&lt;InterceptorFactory&gt;&gt; userAroundConstructsByInterceptorClass = new HashMap&lt;String, List&lt;InterceptorFactory&gt;&gt;();
    final Map&lt;String, List&lt;InterceptorFactory&gt;&gt; userAroundTimeoutsByInterceptorClass;
    final Map&lt;String, List&lt;InterceptorFactory&gt;&gt; userPrePassivatesByInterceptorClass;
    final Map&lt;String, List&lt;InterceptorFactory&gt;&gt; userPostActivatesByInterceptorClass;
    final Map&lt;String, List&lt;InterceptorFactory&gt;&gt; userPostConstructByInterceptorClass = new HashMap&lt;String, List&lt;InterceptorFactory&gt;&gt;();
    final Map&lt;String, List&lt;InterceptorFactory&gt;&gt; userPreDestroyByInterceptorClass = new HashMap&lt;String, List&lt;InterceptorFactory&gt;&gt;();
    final Set&lt;MethodIdentifier&gt; timeoutMethods = description.getTimerMethods();
    if (description.isTimerServiceRequired()) {
        userAroundTimeoutsByInterceptorClass = new HashMap&lt;&gt;();
    } else {
        userAroundTimeoutsByInterceptorClass = null;
    }
    if (description.isPassivationApplicable()) {
        userPrePassivatesByInterceptorClass = new HashMap&lt;&gt;();
        userPostActivatesByInterceptorClass = new HashMap&lt;&gt;();
    } else {
        userPrePassivatesByInterceptorClass = null;
        userPostActivatesByInterceptorClass = null;
    }
    final InterceptorFactory instantiator;
    final ComponentFactory instanceFactory = configuration.getInstanceFactory();
    if (instanceFactory != null) {
        instantiator = new ImmediateInterceptorFactory(new ComponentInstantiatorInterceptor(instanceFactory, BasicComponentInstance.INSTANCE_KEY, true));
    } else {
        final ClassReflectionIndex componentClassIndex = deploymentReflectionIndex.getClassIndex(configuration.getComponentClass());
        final Constructor&lt;?&gt; constructor = componentClassIndex.getConstructor(EMPTY_CLASS_ARRAY);
        if (constructor == null) {
            throw EeLogger.ROOT_LOGGER.defaultConstructorNotFound(configuration.getComponentClass());
        }
        instantiator = new ImmediateInterceptorFactory(new ComponentInstantiatorInterceptor(new ConstructorComponentFactory(constructor), BasicComponentInstance.INSTANCE_KEY, true));
    }
    final List&lt;InterceptorDescription&gt; interceptorWithLifecycleCallbacks = new ArrayList&lt;InterceptorDescription&gt;();
    if (!description.isExcludeDefaultInterceptors()) {
        interceptorWithLifecycleCallbacks.addAll(description.getDefaultInterceptors());
    }
    interceptorWithLifecycleCallbacks.addAll(description.getClassInterceptors());
    for (final InterceptorDescription interceptorDescription : description.getAllInterceptors()) {
        final String interceptorClassName = interceptorDescription.getInterceptorClassName();
        final Class&lt;?&gt; interceptorClass;
        try {
            interceptorClass = ClassLoadingUtils.loadClass(interceptorClassName, module);
        } catch (ClassNotFoundException e) {
            throw EeLogger.ROOT_LOGGER.cannotLoadInterceptor(e, interceptorClassName);
        }
        final InterceptorEnvironment interceptorEnvironment = moduleDescription.getInterceptorEnvironment().get(interceptorClassName);
        if (interceptorEnvironment != null) {
            description.getBindingConfigurations().addAll(interceptorEnvironment.getBindingConfigurations());
            for (final ResourceInjectionConfiguration injection : interceptorEnvironment.getResourceInjections()) {
                description.addResourceInjection(injection);
            }
        }
        final Object contextKey = interceptorClass;
        configuration.getInterceptorContextKeys().add(contextKey);
        final ClassReflectionIndex interceptorIndex = deploymentReflectionIndex.getClassIndex(interceptorClass);
        final Constructor&lt;?&gt; constructor = interceptorIndex.getConstructor(EMPTY_CLASS_ARRAY);
        if (constructor == null) {
            throw EeLogger.ROOT_LOGGER.defaultConstructorNotFoundOnComponent(interceptorClassName, configuration.getComponentClass());
        }
        instantiators.addFirst(new ImmediateInterceptorFactory(new ComponentInstantiatorInterceptor(new ConstructorComponentFactory(constructor), contextKey, false)));
        destructors.addLast(new ImmediateInterceptorFactory(new ManagedReferenceReleaseInterceptor(contextKey)));
        final boolean interceptorHasLifecycleCallbacks = interceptorWithLifecycleCallbacks.contains(interceptorDescription);
        new ClassDescriptionTraversal(interceptorClass, applicationClasses) {

            @Override
            public void handle(final Class&lt;?&gt; clazz, EEModuleClassDescription classDescription) throws DeploymentUnitProcessingException {
                mergeInjectionsForClass(clazz, interceptorClass, classDescription, moduleDescription, deploymentReflectionIndex, description, configuration, context, injectors, contextKey, uninjectors, metadataComplete);
                final InterceptorClassDescription interceptorConfig;
                if (classDescription != null &amp;&amp; !metadataComplete) {
                    interceptorConfig = InterceptorClassDescription.merge(classDescription.getInterceptorClassDescription(), moduleDescription.getInterceptorClassOverride(clazz.getName()));
                } else {
                    interceptorConfig = InterceptorClassDescription.merge(null, moduleDescription.getInterceptorClassOverride(clazz.getName()));
                }
                if (interceptorHasLifecycleCallbacks &amp;&amp; !description.isIgnoreLifecycleInterceptors()) {
                    final MethodIdentifier postConstructMethodIdentifier = interceptorConfig.getPostConstruct();
                    handleInterceptorClass(clazz, postConstructMethodIdentifier, userPostConstructByInterceptorClass, true, true);
                    final MethodIdentifier preDestroyMethodIdentifier = interceptorConfig.getPreDestroy();
                    handleInterceptorClass(clazz, preDestroyMethodIdentifier, userPreDestroyByInterceptorClass, true, true);
                    final MethodIdentifier aroundConstructMethodIdentifier = interceptorConfig.getAroundConstruct();
                    handleInterceptorClass(clazz, aroundConstructMethodIdentifier, userAroundConstructsByInterceptorClass, true, true);
                }
                final MethodIdentifier aroundInvokeMethodIdentifier = interceptorConfig.getAroundInvoke();
                handleInterceptorClass(clazz, aroundInvokeMethodIdentifier, userAroundInvokesByInterceptorClass, false, false);
                if (description.isTimerServiceRequired()) {
                    final MethodIdentifier aroundTimeoutMethodIdentifier = interceptorConfig.getAroundTimeout();
                    handleInterceptorClass(clazz, aroundTimeoutMethodIdentifier, userAroundTimeoutsByInterceptorClass, false, false);
                }
                if (description.isPassivationApplicable()) {
                    handleInterceptorClass(clazz, interceptorConfig.getPrePassivate(), userPrePassivatesByInterceptorClass, false, false);
                    handleInterceptorClass(clazz, interceptorConfig.getPostActivate(), userPostActivatesByInterceptorClass, false, false);
                }
            }

            private void handleInterceptorClass(final Class&lt;?&gt; clazz, final MethodIdentifier methodIdentifier, final Map&lt;String, List&lt;InterceptorFactory&gt;&gt; classMap, final boolean changeMethod, final boolean lifecycleMethod) throws DeploymentUnitProcessingException {
                if (methodIdentifier != null) {
                    final Method method = ClassReflectionIndexUtil.findRequiredMethod(deploymentReflectionIndex, clazz, methodIdentifier);
                    if (isNotOverriden(clazz, method, interceptorClass, deploymentReflectionIndex)) {
                        final InterceptorFactory interceptorFactory = new ImmediateInterceptorFactory(new ManagedReferenceLifecycleMethodInterceptor(contextKey, method, changeMethod, lifecycleMethod));
                        List&lt;InterceptorFactory&gt; factories = classMap.get(interceptorClassName);
                        if (factories == null) {
                            classMap.put(interceptorClassName, factories = new ArrayList&lt;InterceptorFactory&gt;());
                        }
                        factories.add(interceptorFactory);
                    }
                }
            }
        }.run();
    }
    final List&lt;InterceptorFactory&gt; userAroundConstruct = new ArrayList&lt;InterceptorFactory&gt;();
    final List&lt;InterceptorFactory&gt; userPostConstruct = new ArrayList&lt;InterceptorFactory&gt;();
    final List&lt;InterceptorFactory&gt; userPreDestroy = new ArrayList&lt;InterceptorFactory&gt;();
    final List&lt;InterceptorFactory&gt; userPrePassivate = new ArrayList&lt;InterceptorFactory&gt;();
    final List&lt;InterceptorFactory&gt; userPostActivate = new ArrayList&lt;InterceptorFactory&gt;();
    for (final InterceptorDescription interceptorClass : interceptorWithLifecycleCallbacks) {
        if (userPostConstructByInterceptorClass.containsKey(interceptorClass.getInterceptorClassName())) {
            userPostConstruct.addAll(userPostConstructByInterceptorClass.get(interceptorClass.getInterceptorClassName()));
        }
        if (userAroundConstructsByInterceptorClass.containsKey(interceptorClass.getInterceptorClassName())) {
            userAroundConstruct.addAll(userAroundConstructsByInterceptorClass.get(interceptorClass.getInterceptorClassName()));
        }
        if (userPreDestroyByInterceptorClass.containsKey(interceptorClass.getInterceptorClassName())) {
            userPreDestroy.addAll(userPreDestroyByInterceptorClass.get(interceptorClass.getInterceptorClassName()));
        }
        if (description.isPassivationApplicable()) {
            if (userPrePassivatesByInterceptorClass.containsKey(interceptorClass.getInterceptorClassName())) {
                userPrePassivate.addAll(userPrePassivatesByInterceptorClass.get(interceptorClass.getInterceptorClassName()));
            }
            if (userPostActivatesByInterceptorClass.containsKey(interceptorClass.getInterceptorClassName())) {
                userPostActivate.addAll(userPostActivatesByInterceptorClass.get(interceptorClass.getInterceptorClassName()));
            }
        }
    }
    if (!injectors.isEmpty()) {
        configuration.addPostConstructInterceptors(new ArrayList&lt;&gt;(injectors), InterceptorOrder.ComponentPostConstruct.INTERCEPTOR_RESOURCE_INJECTION_INTERCEPTORS);
    }
    if (!instantiators.isEmpty()) {
        configuration.addPostConstructInterceptors(new ArrayList&lt;&gt;(instantiators), InterceptorOrder.ComponentPostConstruct.INTERCEPTOR_INSTANTIATION_INTERCEPTORS);
    }
    if (!userAroundConstruct.isEmpty()) {
        configuration.addAroundConstructInterceptors(userAroundConstruct, InterceptorOrder.AroundConstruct.INTERCEPTOR_AROUND_CONSTRUCT);
    }
    configuration.addAroundConstructInterceptor(instantiator, InterceptorOrder.AroundConstruct.CONSTRUCT_COMPONENT);
    configuration.addAroundConstructInterceptor(new ImmediateInterceptorFactory(Interceptors.getTerminalInterceptor()), InterceptorOrder.AroundConstruct.TERMINAL_INTERCEPTOR);
    if (!configuration.getAroundConstructInterceptors().isEmpty()) {
        configuration.addPostConstructInterceptor(new AroundConstructInterceptorFactory(Interceptors.getChainedInterceptorFactory(configuration.getAroundConstructInterceptors())), InterceptorOrder.ComponentPostConstruct.AROUND_CONSTRUCT_CHAIN);
    }
    if (!userPostConstruct.isEmpty()) {
        configuration.addPostConstructInterceptors(userPostConstruct, InterceptorOrder.ComponentPostConstruct.INTERCEPTOR_USER_INTERCEPTORS);
    }
    if (!uninjectors.isEmpty()) {
        configuration.addPreDestroyInterceptors(new ArrayList&lt;&gt;(uninjectors), InterceptorOrder.ComponentPreDestroy.INTERCEPTOR_UNINJECTION_INTERCEPTORS);
    }
    if (!destructors.isEmpty()) {
        configuration.addPreDestroyInterceptors(new ArrayList&lt;&gt;(destructors), InterceptorOrder.ComponentPreDestroy.INTERCEPTOR_DESTRUCTION_INTERCEPTORS);
    }
    if (!userPreDestroy.isEmpty()) {
        configuration.addPreDestroyInterceptors(userPreDestroy, InterceptorOrder.ComponentPreDestroy.INTERCEPTOR_USER_INTERCEPTORS);
    }
    if (description.isPassivationApplicable()) {
        if (!userPrePassivate.isEmpty()) {
            configuration.addPrePassivateInterceptors(userPrePassivate, InterceptorOrder.ComponentPassivation.INTERCEPTOR_USER_INTERCEPTORS);
        }
        if (!userPostActivate.isEmpty()) {
            configuration.addPostActivateInterceptors(userPostActivate, InterceptorOrder.ComponentPassivation.INTERCEPTOR_USER_INTERCEPTORS);
        }
    }
    final List&lt;InterceptorDescription&gt; classInterceptors = description.getClassInterceptors();
    final Map&lt;MethodIdentifier, List&lt;InterceptorDescription&gt;&gt; methodInterceptors = description.getMethodInterceptors();
    if (description.isIntercepted()) {
        for (final Method method : configuration.getDefinedComponentMethods()) {
            final MethodIdentifier identifier = MethodIdentifier.getIdentifier(method.getReturnType(), method.getName(), method.getParameterTypes());
            final List&lt;InterceptorFactory&gt; userAroundInvokes = new ArrayList&lt;InterceptorFactory&gt;();
            final List&lt;InterceptorFactory&gt; userAroundTimeouts = new ArrayList&lt;InterceptorFactory&gt;();
            final boolean requiresTimerChain = description.isTimerServiceRequired() &amp;&amp; timeoutMethods.contains(identifier);
            if (!description.isExcludeDefaultInterceptors() &amp;&amp; !description.isExcludeDefaultInterceptors(identifier)) {
                for (InterceptorDescription interceptorDescription : description.getDefaultInterceptors()) {
                    String interceptorClassName = interceptorDescription.getInterceptorClassName();
                    List&lt;InterceptorFactory&gt; aroundInvokes = userAroundInvokesByInterceptorClass.get(interceptorClassName);
                    if (aroundInvokes != null) {
                        userAroundInvokes.addAll(aroundInvokes);
                    }
                    if (requiresTimerChain) {
                        List&lt;InterceptorFactory&gt; aroundTimeouts = userAroundTimeoutsByInterceptorClass.get(interceptorClassName);
                        if (aroundTimeouts != null) {
                            userAroundTimeouts.addAll(aroundTimeouts);
                        }
                    }
                }
            }
            if (!description.isExcludeClassInterceptors(identifier)) {
                for (InterceptorDescription interceptorDescription : classInterceptors) {
                    String interceptorClassName = interceptorDescription.getInterceptorClassName();
                    List&lt;InterceptorFactory&gt; aroundInvokes = userAroundInvokesByInterceptorClass.get(interceptorClassName);
                    if (aroundInvokes != null) {
                        userAroundInvokes.addAll(aroundInvokes);
                    }
                    if (requiresTimerChain) {
                        List&lt;InterceptorFactory&gt; aroundTimeouts = userAroundTimeoutsByInterceptorClass.get(interceptorClassName);
                        if (aroundTimeouts != null) {
                            userAroundTimeouts.addAll(aroundTimeouts);
                        }
                    }
                }
            }
            List&lt;InterceptorDescription&gt; methodLevelInterceptors = methodInterceptors.get(identifier);
            if (methodLevelInterceptors != null) {
                for (InterceptorDescription methodLevelInterceptor : methodLevelInterceptors) {
                    String interceptorClassName = methodLevelInterceptor.getInterceptorClassName();
                    List&lt;InterceptorFactory&gt; aroundInvokes = userAroundInvokesByInterceptorClass.get(interceptorClassName);
                    if (aroundInvokes != null) {
                        userAroundInvokes.addAll(aroundInvokes);
                    }
                    if (requiresTimerChain) {
                        List&lt;InterceptorFactory&gt; aroundTimeouts = userAroundTimeoutsByInterceptorClass.get(interceptorClassName);
                        if (aroundTimeouts != null) {
                            userAroundTimeouts.addAll(aroundTimeouts);
                        }
                    }
                }
            }
            if (requiresTimerChain) {
                configuration.addComponentInterceptor(method, new UserInterceptorFactory(weaved(userAroundInvokes), weaved(userAroundTimeouts)), InterceptorOrder.Component.INTERCEPTOR_USER_INTERCEPTORS);
            } else {
                configuration.addComponentInterceptors(method, userAroundInvokes, InterceptorOrder.Component.INTERCEPTOR_USER_INTERCEPTORS);
            }
        }
    }
}
</code></pre></div></td>
</tr>
<tr>
    <td>16</td><td>5040.82</td><td>50</td><td>218</td>
    <td><div class="code-container"><pre><code class="language-java">private void processDeployment(final WarMetaData warMetaData, final DeploymentUnit deploymentUnit, final RequirementServiceTarget serviceTarget, final String deploymentName, final String hostName, final String serverInstanceName, final boolean isDefaultWebModule) throws DeploymentUnitProcessingException {
    ResourceRoot deploymentResourceRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT);
    final VirtualFile deploymentRoot = deploymentResourceRoot.getRoot();
    final Module module = deploymentUnit.getAttachment(Attachments.MODULE);
    if (module == null) {
        throw new DeploymentUnitProcessingException(UndertowLogger.ROOT_LOGGER.failedToResolveModule(deploymentUnit));
    }
    final JBossWebMetaData metaData = warMetaData.getMergedJBossWebMetaData();
    final List&lt;SetupAction&gt; setupActions = deploymentUnit.getAttachmentList(org.jboss.as.ee.component.Attachments.WEB_SETUP_ACTIONS);
    CapabilityServiceSupport capabilitySupport = deploymentUnit.getAttachment(Attachments.CAPABILITY_SERVICE_SUPPORT);
    ScisMetaData scisMetaData = deploymentUnit.getAttachment(ScisMetaData.ATTACHMENT_KEY);
    final Set&lt;ServiceName&gt; dependentComponents = new HashSet&lt;&gt;();
    final List&lt;ServiceName&gt; components = deploymentUnit.getAttachmentList(WebComponentDescription.WEB_COMPONENTS);
    final Set&lt;ServiceName&gt; failed = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.FAILED_COMPONENTS);
    for (final ServiceName component : components) {
        if (!failed.contains(component)) {
            dependentComponents.add(component);
        }
    }
    String servletContainerName = Optional.ofNullable(metaData.getServletContainerName()).orElse(this.defaultContainer);
    final boolean componentRegistryExists = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.COMPONENT_REGISTRY) != null;
    final ComponentRegistry componentRegistry = componentRegistryExists ? deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.COMPONENT_REGISTRY) : new ComponentRegistry(null);
    final ClassLoader loader = module.getClassLoader();
    final WebInjectionContainer injectionContainer = (metaData.getDistributable() == null) ? new CachingWebInjectionContainer(loader, componentRegistry) : new SimpleWebInjectionContainer(loader, componentRegistry);
    DeploymentUnit parentDeploymentUnit = deploymentUnit.getParent();
    String jaccContextId = metaData.getJaccContextID();
    if (jaccContextId == null) {
        jaccContextId = deploymentUnit.getName();
    }
    if (parentDeploymentUnit != null) {
        jaccContextId = parentDeploymentUnit.getName() + &quot;!&quot; + jaccContextId;
    }
    String pathName = pathNameOfDeployment(deploymentUnit, metaData, isDefaultWebModule);
    final Set&lt;ServiceName&gt; additionalDependencies = new HashSet&lt;&gt;();
    for (final SetupAction setupAction : setupActions) {
        Set&lt;ServiceName&gt; dependencies = setupAction.dependencies();
        if (dependencies != null) {
            additionalDependencies.addAll(dependencies);
        }
    }
    if (!deploymentResourceRoot.isUsePhysicalCodeSource()) {
        try {
            deploymentUnit.addToAttachmentList(ServletContextAttribute.ATTACHMENT_KEY, new ServletContextAttribute(Constants.CODE_SOURCE_ATTRIBUTE_NAME, deploymentRoot.toURL()));
        } catch (MalformedURLException e) {
            throw new DeploymentUnitProcessingException(e);
        }
    }
    deploymentUnit.addToAttachmentList(ServletContextAttribute.ATTACHMENT_KEY, new ServletContextAttribute(Constants.PERMISSION_COLLECTION_ATTRIBUTE_NAME, deploymentUnit.getAttachment(Attachments.MODULE_PERMISSIONS)));
    additionalDependencies.addAll(warMetaData.getAdditionalDependencies());
    final ServiceName hostServiceName = capabilitySupport.getCapabilityServiceName(Capabilities.CAPABILITY_HOST, serverInstanceName, hostName);
    final ServiceName legacyDeploymentServiceName = UndertowService.deploymentServiceName(serverInstanceName, hostName, pathName);
    final ServiceName deploymentServiceName = UndertowService.deploymentServiceName(deploymentUnit.getServiceName());
    StartupCountdown countDown = deploymentUnit.getAttachment(STARTUP_COUNTDOWN);
    if (countDown != null) {
        deploymentUnit.addToAttachmentList(UndertowAttachments.UNDERTOW_INITIAL_HANDLER_CHAIN_WRAPPERS, handler -&gt; new ComponentStartupCountdownHandler(handler, countDown));
    }
    String securityDomainName = deploymentUnit.getAttachment(UndertowAttachments.RESOLVED_SECURITY_DOMAIN);
    TldsMetaData tldsMetaData = deploymentUnit.getAttachment(TldsMetaData.ATTACHMENT_KEY);
    final ServiceName deploymentInfoServiceName = deploymentServiceName.append(UndertowDeploymentInfoService.SERVICE_NAME);
    final ServiceName legacyDeploymentInfoServiceName = legacyDeploymentServiceName.append(UndertowDeploymentInfoService.SERVICE_NAME);
    final RequirementServiceBuilder&lt;?&gt; builder = serviceTarget.addService();
    final Consumer&lt;DeploymentInfo&gt; deploymentInfo = builder.provides(deploymentInfoServiceName, legacyDeploymentInfoServiceName);
    final Supplier&lt;UndertowService&gt; undertowService = builder.requires(capabilitySupport.getCapabilityServiceName(Capabilities.CAPABILITY_UNDERTOW));
    final Supplier&lt;ServletContainerService&gt; servletContainerService = builder.requires(capabilitySupport.getCapabilityServiceName(Capabilities.CAPABILITY_SERVLET_CONTAINER, servletContainerName));
    final Supplier&lt;ComponentRegistry&gt; componentRegistryDependency = componentRegistryExists ? builder.requires(ComponentRegistry.serviceName(deploymentUnit)) : Functions.constantSupplier(componentRegistry);
    final Supplier&lt;Host&gt; host = builder.requires(hostServiceName);
    final Supplier&lt;SuspendController&gt; suspendController = builder.requires(capabilitySupport.getCapabilityServiceName(Capabilities.REF_SUSPEND_CONTROLLER));
    final Supplier&lt;ServerEnvironment&gt; serverEnvironment = builder.requires(ServerEnvironment.SERVICE_DESCRIPTOR);
    Supplier&lt;SecurityDomain&gt; securityDomain = null;
    Supplier&lt;HttpServerAuthenticationMechanismFactory&gt; mechanismFactorySupplier = null;
    Supplier&lt;BiFunction&lt;DeploymentInfo, Function&lt;String, RunAsIdentityMetaData&gt;, Registration&gt;&gt; applySecurityFunction = null;
    for (final ServiceName additionalDependency : additionalDependencies) {
        builder.requires(additionalDependency);
    }
    final SecurityMetaData securityMetaData = deploymentUnit.getAttachment(ATTACHMENT_KEY);
    if (isVirtualDomainRequired(deploymentUnit) || isVirtualMechanismFactoryRequired(deploymentUnit)) {
        securityDomain = builder.requires(securityMetaData.getSecurityDomain());
    } else if (securityDomainName != null) {
        if (mappedSecurityDomain.test(securityDomainName)) {
            applySecurityFunction = builder.requires(capabilitySupport.getCapabilityServiceName(Capabilities.CAPABILITY_APPLICATION_SECURITY_DOMAIN, securityDomainName));
        } else {
            throw ROOT_LOGGER.deploymentConfiguredForLegacySecurity();
        }
    }
    if (isVirtualMechanismFactoryRequired(deploymentUnit)) {
        if (securityMetaData instanceof AdvancedSecurityMetaData) {
            mechanismFactorySupplier = builder.requires(((AdvancedSecurityMetaData) securityMetaData).getHttpServerAuthenticationMechanismFactory());
        }
    }
    Supplier&lt;ControlPoint&gt; controlPoint = RequestControllerActivationMarker.isRequestControllerEnabled(deploymentUnit) ? builder.requires(ControlPointService.serviceName(Optional.ofNullable(parentDeploymentUnit).orElse(deploymentUnit).getName(), UndertowExtension.SUBSYSTEM_NAME)) : null;
    SharedSessionManagerConfig sharedSessionManagerConfig = parentDeploymentUnit != null ? parentDeploymentUnit.getAttachment(SharedSessionManagerConfig.ATTACHMENT_KEY) : null;
    ServiceName sessionManagerFactoryServiceName = (sharedSessionManagerConfig != null) ? parentDeploymentUnit.getServiceName().append(SharedSessionManagerConfig.SHARED_SESSION_MANAGER_SERVICE_NAME) : deploymentServiceName.append(&quot;session&quot;);
    ServiceName sessionConfigWrapperFactoryServiceName = (sharedSessionManagerConfig != null) ? parentDeploymentUnit.getServiceName().append(SharedSessionManagerConfig.SHARED_SESSION_AFFINITY_SERVICE_NAME) : deploymentServiceName.append(&quot;affinity&quot;);
    ServletContainerService servletContainer = deploymentUnit.getAttachment(UndertowAttachments.SERVLET_CONTAINER_SERVICE);
    Supplier&lt;SessionManagerFactory&gt; sessionManagerFactory = (servletContainer != null) ? builder.requires(sessionManagerFactoryServiceName) : null;
    Supplier&lt;Function&lt;CookieConfig, SessionConfigWrapper&gt;&gt; sessionConfigWrapperFactory = (servletContainer != null) ? builder.requires(sessionConfigWrapperFactoryServiceName) : null;
    if ((servletContainer != null) &amp;&amp; (sharedSessionManagerConfig == null)) {
        Integer maxActiveSessions = (metaData.getMaxActiveSessions() != null) ? metaData.getMaxActiveSessions() : servletContainer.getMaxSessions();
        SessionConfigMetaData sessionConfig = metaData.getSessionConfig();
        int defaultSessionTimeout = ((sessionConfig != null) &amp;&amp; sessionConfig.getSessionTimeoutSet()) ? sessionConfig.getSessionTimeout() : servletContainer.getDefaultSessionTimeout();
        SessionManagementProvider provider = this.getDistributableWebDeploymentProvider(deploymentUnit, metaData);
        SessionManagerFactoryConfiguration configuration = new SessionManagerFactoryConfiguration() {

            @Override
            public String getServerName() {
                return serverInstanceName;
            }

            @Override
            public String getDeploymentName() {
                return deploymentName;
            }

            @Override
            public DeploymentUnit getDeploymentUnit() {
                return deploymentUnit;
            }

            @Override
            public Integer getMaxActiveSessions() {
                return (maxActiveSessions != null) &amp;&amp; (maxActiveSessions &gt; 0) ? maxActiveSessions : null;
            }

            @Override
            public Duration getDefaultSessionTimeout() {
                return Duration.ofMinutes(defaultSessionTimeout);
            }
        };
        for (CapabilityServiceConfigurator configurator : provider.getSessionManagerFactoryServiceConfigurators(sessionManagerFactoryServiceName, configuration)) {
            configurator.configure(capabilitySupport).build(serviceTarget).install();
        }
        for (CapabilityServiceConfigurator configurator : provider.getSessionAffinityServiceConfigurators(sessionConfigWrapperFactoryServiceName, configuration)) {
            configurator.configure(capabilitySupport).build(serviceTarget).install();
        }
    }
    UndertowDeploymentInfoService undertowDeploymentInfoService = UndertowDeploymentInfoService.builder().setAttributes(deploymentUnit.getAttachmentList(ServletContextAttribute.ATTACHMENT_KEY)).setContextPath(pathName).setDeploymentName(deploymentName).setDeploymentRoot(deploymentRoot).setMergedMetaData(warMetaData.getMergedJBossWebMetaData()).setModule(module).setScisMetaData(scisMetaData).setJaccContextId(jaccContextId).setSecurityDomain(securityDomainName).setTldInfo(createTldsInfo(tldsMetaData, tldsMetaData == null ? null : tldsMetaData.getSharedTlds(deploymentUnit))).setSetupActions(setupActions).setSharedSessionManagerConfig(sharedSessionManagerConfig).setOverlays(warMetaData.getOverlays()).setExpressionFactoryWrappers(deploymentUnit.getAttachmentList(ExpressionFactoryWrapper.ATTACHMENT_KEY)).setPredicatedHandlers(deploymentUnit.getAttachment(UndertowHandlersDeploymentProcessor.PREDICATED_HANDLERS)).setInitialHandlerChainWrappers(deploymentUnit.getAttachmentList(UndertowAttachments.UNDERTOW_INITIAL_HANDLER_CHAIN_WRAPPERS)).setInnerHandlerChainWrappers(deploymentUnit.getAttachmentList(UndertowAttachments.UNDERTOW_INNER_HANDLER_CHAIN_WRAPPERS)).setOuterHandlerChainWrappers(deploymentUnit.getAttachmentList(UndertowAttachments.UNDERTOW_OUTER_HANDLER_CHAIN_WRAPPERS)).setThreadSetupActions(deploymentUnit.getAttachmentList(UndertowAttachments.UNDERTOW_THREAD_SETUP_ACTIONS)).setServletExtensions(deploymentUnit.getAttachmentList(UndertowAttachments.UNDERTOW_SERVLET_EXTENSIONS)).setExplodedDeployment(ExplodedDeploymentMarker.isExplodedDeployment(deploymentUnit)).setWebSocketDeploymentInfo(deploymentUnit.getAttachment(UndertowAttachments.WEB_SOCKET_DEPLOYMENT_INFO)).setTempDir(warMetaData.getTempDir()).setExternalResources(deploymentUnit.getAttachmentList(UndertowAttachments.EXTERNAL_RESOURCES)).setAllowSuspendedRequests(deploymentUnit.getAttachmentList(UndertowAttachments.ALLOW_REQUEST_WHEN_SUSPENDED)).createUndertowDeploymentInfoService(deploymentInfo, undertowService, sessionManagerFactory, sessionConfigWrapperFactory, servletContainerService, componentRegistryDependency, host, controlPoint, suspendController, serverEnvironment, securityDomain, mechanismFactorySupplier, applySecurityFunction);
    builder.setInstance(undertowDeploymentInfoService);
    final Set&lt;String&gt; seenExecutors = new HashSet&lt;String&gt;();
    if (metaData.getExecutorName() != null) {
        final Supplier&lt;Executor&gt; executor = builder.requires(IOServices.WORKER.append(metaData.getExecutorName()));
        undertowDeploymentInfoService.addInjectedExecutor(metaData.getExecutorName(), executor);
        seenExecutors.add(metaData.getExecutorName());
    }
    if (metaData.getServlets() != null) {
        for (JBossServletMetaData servlet : metaData.getServlets()) {
            if (servlet.getExecutorName() != null &amp;&amp; !seenExecutors.contains(servlet.getExecutorName())) {
                final Supplier&lt;Executor&gt; executor = builder.requires(IOServices.WORKER.append(servlet.getExecutorName()));
                undertowDeploymentInfoService.addInjectedExecutor(servlet.getExecutorName(), executor);
                seenExecutors.add(servlet.getExecutorName());
            }
        }
    }
    try {
        builder.install();
    } catch (DuplicateServiceException e) {
        throw UndertowLogger.ROOT_LOGGER.duplicateHostContextDeployments(deploymentInfoServiceName, e.getMessage());
    }
    final ServiceBuilder&lt;?&gt; udsBuilder = serviceTarget.addService(deploymentServiceName);
    final Consumer&lt;UndertowDeploymentService&gt; sConsumer = udsBuilder.provides(deploymentServiceName, legacyDeploymentServiceName);
    final Supplier&lt;ServletContainerService&gt; cSupplier = udsBuilder.requires(UndertowService.SERVLET_CONTAINER.append(defaultContainer));
    final Supplier&lt;ExecutorService&gt; seSupplier = Services.requireServerExecutor(udsBuilder);
    final Supplier&lt;Host&gt; hSupplier = udsBuilder.requires(hostServiceName);
    final Supplier&lt;DeploymentInfo&gt; diSupplier = udsBuilder.requires(deploymentInfoServiceName);
    for (final ServiceName webDependency : deploymentUnit.getAttachmentList(Attachments.WEB_DEPENDENCIES)) {
        udsBuilder.requires(webDependency);
    }
    for (final ServiceName dependentComponent : dependentComponents) {
        udsBuilder.requires(dependentComponent);
    }
    udsBuilder.setInstance(new UndertowDeploymentService(sConsumer, cSupplier, seSupplier, hSupplier, diSupplier, injectionContainer, true));
    udsBuilder.install();
    deploymentUnit.addToAttachmentList(Attachments.DEPLOYMENT_COMPLETE_SERVICES, deploymentServiceName);
    final boolean elytronJacc = capabilitySupport.hasCapability(ELYTRON_JACC_CAPABILITY_NAME);
    if (elytronJacc) {
        WarJACCDeployer deployer = new WarJACCDeployer();
        JaccService&lt;WarMetaData&gt; jaccService = deployer.deploy(deploymentUnit, jaccContextId);
        if (jaccService != null) {
            final ServiceName jaccServiceName = deploymentUnit.getServiceName().append(JaccService.SERVICE_NAME);
            ServiceBuilder&lt;?&gt; jaccBuilder = serviceTarget.addService(jaccServiceName, jaccService);
            if (parentDeploymentUnit != null) {
                jaccBuilder.addDependency(parentDeploymentUnit.getServiceName().append(JaccService.SERVICE_NAME), PolicyConfiguration.class, jaccService.getParentPolicyInjector());
            }
            jaccBuilder.requires(capabilitySupport.getCapabilityServiceName(elytronJacc ? ELYTRON_JACC_CAPABILITY_NAME : LEGACY_JACC_CAPABILITY_NAME));
            jaccBuilder.requires(deploymentServiceName);
            jaccBuilder.setInitialMode(Mode.PASSIVE).install();
        }
    }
    final DeploymentResourceSupport deploymentResourceSupport = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_RESOURCE_SUPPORT);
    final ModelNode node = deploymentResourceSupport.getDeploymentSubsystemModel(UndertowExtension.SUBSYSTEM_NAME);
    node.get(DeploymentDefinition.CONTEXT_ROOT.getName()).set(&quot;&quot;.equals(pathName) ? &quot;/&quot; : pathName);
    node.get(DeploymentDefinition.VIRTUAL_HOST.getName()).set(hostName);
    node.get(DeploymentDefinition.SERVER.getName()).set(serverInstanceName);
    processManagement(deploymentUnit, metaData);
}
</code></pre></div></td>
</tr>
<tr>
    <td>17</td><td>4927.5</td><td>51</td><td>185</td>
    <td><div class="code-container"><pre><code class="language-java">public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {
    final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();
    if (!JaxrsDeploymentMarker.isJaxrsDeployment(deploymentUnit)) {
        return;
    }
    if (!DeploymentTypeMarker.isType(DeploymentType.WAR, deploymentUnit)) {
        return;
    }
    final DeploymentUnit parent = deploymentUnit.getParent() == null ? deploymentUnit : deploymentUnit.getParent();
    final WarMetaData warMetaData = deploymentUnit.getAttachment(WarMetaData.ATTACHMENT_KEY);
    final JBossWebMetaData webdata = warMetaData.getMergedJBossWebMetaData();
    setConfigParameters(phaseContext, webdata);
    final ResteasyDeploymentData resteasy = deploymentUnit.getAttachment(JaxrsAttachments.RESTEASY_DEPLOYMENT_DATA);
    if (resteasy == null)
        return;
    final Module module = deploymentUnit.getAttachment(Attachments.MODULE);
    if (module != null) {
        final CapabilityServiceSupport support = deploymentUnit.getAttachment(Attachments.CAPABILITY_SERVICE_SUPPORT);
        final WildFlyConfigurationFactory configurationFactory = WildFlyConfigurationFactory.getInstance();
        configurationFactory.register(module.getClassLoader(), useMicroProfileConfig(module, support));
    }
    final List&lt;ParamValueMetaData&gt; params = webdata.getContextParams();
    boolean entityExpandEnabled = false;
    if (params != null) {
        Iterator&lt;ParamValueMetaData&gt; it = params.iterator();
        while (it.hasNext()) {
            final ParamValueMetaData param = it.next();
            if (param.getParamName().equals(ResteasyContextParameters.RESTEASY_EXPAND_ENTITY_REFERENCES)) {
                entityExpandEnabled = true;
            }
        }
    }
    if (!entityExpandEnabled) {
        setContextParameter(webdata, ResteasyContextParameters.RESTEASY_EXPAND_ENTITY_REFERENCES, &quot;false&quot;);
    }
    final Map&lt;ModuleIdentifier, ResteasyDeploymentData&gt; attachmentMap = parent.getAttachment(JaxrsAttachments.ADDITIONAL_RESTEASY_DEPLOYMENT_DATA);
    final List&lt;ResteasyDeploymentData&gt; additionalData = new ArrayList&lt;ResteasyDeploymentData&gt;();
    final ModuleSpecification moduleSpec = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);
    if (moduleSpec != null &amp;&amp; attachmentMap != null) {
        final Set&lt;ModuleIdentifier&gt; identifiers = new HashSet&lt;ModuleIdentifier&gt;();
        for (ModuleDependency dep : moduleSpec.getAllDependencies()) {
            if (!identifiers.contains(dep.getIdentifier())) {
                identifiers.add(dep.getIdentifier());
                if (attachmentMap.containsKey(dep.getIdentifier())) {
                    additionalData.add(attachmentMap.get(dep.getIdentifier()));
                }
            }
        }
        resteasy.merge(additionalData);
    }
    if (!resteasy.getScannedResourceClasses().isEmpty()) {
        StringBuilder buf = null;
        for (String resource : resteasy.getScannedResourceClasses()) {
            if (buf == null) {
                buf = new StringBuilder();
                buf.append(resource);
            } else {
                buf.append(&quot;,&quot;).append(resource);
            }
        }
        String resources = buf.toString();
        JAXRS_LOGGER.debugf(&quot;Adding Jakarta RESTful Web Services resource classes: %s&quot;, resources);
        setContextParameter(webdata, ResteasyContextParameters.RESTEASY_SCANNED_RESOURCES, resources);
    }
    if (!resteasy.getScannedProviderClasses().isEmpty()) {
        StringBuilder buf = null;
        for (String provider : resteasy.getScannedProviderClasses()) {
            if (buf == null) {
                buf = new StringBuilder();
                buf.append(provider);
            } else {
                buf.append(&quot;,&quot;).append(provider);
            }
        }
        String providers = buf.toString();
        JAXRS_LOGGER.debugf(&quot;Adding Jakarta RESTful Web Services provider classes: %s&quot;, providers);
        setContextParameter(webdata, ResteasyContextParameters.RESTEASY_SCANNED_PROVIDERS, providers);
    }
    if (!resteasy.getScannedJndiComponentResources().isEmpty()) {
        StringBuilder buf = null;
        for (String resource : resteasy.getScannedJndiComponentResources()) {
            if (buf == null) {
                buf = new StringBuilder();
                buf.append(resource);
            } else {
                buf.append(&quot;,&quot;).append(resource);
            }
        }
        String providers = buf.toString();
        JAXRS_LOGGER.debugf(&quot;Adding Jakarta RESTful Web Services jndi component resource classes: %s&quot;, providers);
        setContextParameter(webdata, ResteasyContextParameters.RESTEASY_SCANNED_JNDI_RESOURCES, providers);
    }
    if (!resteasy.isUnwrappedExceptionsParameterSet()) {
        setContextParameter(webdata, ResteasyContextParameters.RESTEASY_UNWRAPPED_EXCEPTIONS, &quot;jakarta.ejb.EJBException&quot;);
    }
    if (findContextParam(webdata, ResteasyContextParameters.RESTEASY_PREFER_JACKSON_OVER_JSONB) == null) {
        final String prop = WildFlySecurityManager.getPropertyPrivileged(ResteasyContextParameters.RESTEASY_PREFER_JACKSON_OVER_JSONB, null);
        if (prop != null) {
            setContextParameter(webdata, ResteasyContextParameters.RESTEASY_PREFER_JACKSON_OVER_JSONB, prop);
        } else {
            setContextParameter(webdata, ResteasyContextParameters.RESTEASY_PREFER_JACKSON_OVER_JSONB, Boolean.toString(hasJacksonAnnotations(deploymentUnit)));
        }
    }
    boolean managementAdded = false;
    if (!resteasy.getScannedApplicationClasses().isEmpty() || resteasy.hasBootClasses() || resteasy.isDispatcherCreated()) {
        addManagement(deploymentUnit, resteasy);
        managementAdded = true;
    }
    final String value = webdata.getContextParams().stream().filter(contextValue -&gt; &quot;resteasy.server.tracing.type&quot;.equals(contextValue.getParamName())).map(ParamValueMetaData::getParamValue).findFirst().orElse(null);
    if (value != null &amp;&amp; !&quot;OFF&quot;.equals(value)) {
        JAXRS_LOGGER.tracingEnabled(deploymentUnit.getName());
    }
    if (resteasy.hasBootClasses() || resteasy.isDispatcherCreated())
        return;
    Set&lt;Class&lt;? extends Application&gt;&gt; applicationClassSet = new HashSet&lt;&gt;();
    for (Class&lt;? extends Application&gt; clazz : resteasy.getScannedApplicationClasses()) {
        if (clazz.isAnnotationPresent(ApplicationPath.class) || servletMappingsExist(webdata, clazz.getName())) {
            applicationClassSet.add(clazz);
        }
    }
    if (applicationClassSet.isEmpty()) {
        JBossServletMetaData servlet = new JBossServletMetaData();
        servlet.setName(JAX_RS_SERVLET_NAME);
        servlet.setServletClass(HttpServlet30Dispatcher.class.getName());
        servlet.setAsyncSupported(true);
        addServlet(webdata, servlet);
        setServletMappingPrefix(webdata, JAX_RS_SERVLET_NAME, servlet);
    } else {
        for (Class&lt;? extends Application&gt; applicationClass : applicationClassSet) {
            String servletName = null;
            servletName = applicationClass.getName();
            JBossServletMetaData servlet = new JBossServletMetaData();
            servlet.setLoadOnStartup(&quot;&quot; + 0);
            servlet.setName(servletName);
            servlet.setServletClass(HttpServlet30Dispatcher.class.getName());
            servlet.setAsyncSupported(true);
            setServletInitParam(servlet, SERVLET_INIT_PARAM, applicationClass.getName());
            addServlet(webdata, servlet);
            if (!servletMappingsExist(webdata, servletName)) {
                try {
                    List&lt;String&gt; patterns = new ArrayList&lt;String&gt;();
                    String pathValue = URLDecoder.decode(applicationClass.getAnnotation(ApplicationPath.class).value().trim(), &quot;UTF-8&quot;);
                    if (!pathValue.startsWith(&quot;/&quot;)) {
                        pathValue = &quot;/&quot; + pathValue;
                    }
                    String prefix = pathValue;
                    if (pathValue.endsWith(&quot;/&quot;)) {
                        pathValue += &quot;*&quot;;
                    } else {
                        pathValue += &quot;/*&quot;;
                    }
                    patterns.add(pathValue);
                    setServletInitParam(servlet, &quot;resteasy.servlet.mapping.prefix&quot;, prefix);
                    ServletMappingMetaData mapping = new ServletMappingMetaData();
                    mapping.setServletName(servletName);
                    mapping.setUrlPatterns(patterns);
                    if (webdata.getServletMappings() == null) {
                        webdata.setServletMappings(new ArrayList&lt;ServletMappingMetaData&gt;());
                    }
                    webdata.getServletMappings().add(mapping);
                } catch (UnsupportedEncodingException e) {
                    throw new RuntimeException(e);
                }
            } else {
                setServletMappingPrefix(webdata, servletName, servlet);
            }
        }
    }
    if (!managementAdded &amp;&amp; webdata.getServletMappings() != null) {
        for (ServletMappingMetaData servletMapMeta : webdata.getServletMappings()) {
            if (JAX_RS_SERVLET_NAME.equals(servletMapMeta.getServletName())) {
                addManagement(deploymentUnit, resteasy);
                break;
            }
        }
    }
    if (deploymentUnit.getParent() == null &amp;&amp; (webdata.getServletMappings() == null || webdata.getServletMappings().isEmpty())) {
        JAXRS_LOGGER.noServletDeclaration(deploymentUnit.getName());
    }
}
</code></pre></div></td>
</tr>
<tr>
    <td>18</td><td>3516.36</td><td>47</td><td>208</td>
    <td><div class="code-container"><pre><code class="language-java">private void parseDataSource_7_0(final XMLExtendedStreamReader reader, final List&lt;ModelNode&gt; list, final ModelNode parentAddress) throws XMLStreamException, ParserException, ValidateException {
    String poolName = null;
    final ModelNode operation = new ModelNode();
    operation.get(OP).set(ADD);
    final int count = reader.getAttributeCount();
    for (int i = 0; i &lt; count; i++) {
        if (!isNoNamespaceAttribute(reader, i)) {
            throw unexpectedAttribute(reader, i);
        }
        final DataSource.Attribute attribute = DataSource.Attribute.forName(reader.getAttributeLocalName(i));
        switch(attribute) {
            case ENABLED:
                {
                    final String value = rawAttributeText(reader, ENABLED.getXmlName());
                    if (value != null) {
                        ENABLED.parseAndSetParameter(value, operation, reader);
                    }
                    break;
                }
            case JNDI_NAME:
                {
                    final String jndiName = rawAttributeText(reader, JNDI_NAME.getXmlName());
                    JNDI_NAME.parseAndSetParameter(jndiName, operation, reader);
                    break;
                }
            case POOL_NAME:
                {
                    poolName = rawAttributeText(reader, POOLNAME_NAME);
                    break;
                }
            case USE_JAVA_CONTEXT:
                {
                    final String value = rawAttributeText(reader, USE_JAVA_CONTEXT.getXmlName());
                    if (value != null) {
                        USE_JAVA_CONTEXT.parseAndSetParameter(value, operation, reader);
                    }
                    break;
                }
            case SPY:
                {
                    final String value = rawAttributeText(reader, SPY.getXmlName());
                    if (value != null) {
                        SPY.parseAndSetParameter(value, operation, reader);
                    }
                    break;
                }
            case USE_CCM:
                {
                    final String value = rawAttributeText(reader, USE_CCM.getXmlName());
                    if (value != null) {
                        USE_CCM.parseAndSetParameter(value, operation, reader);
                    }
                    break;
                }
            case JTA:
                {
                    final String value = rawAttributeText(reader, JTA.getXmlName());
                    if (value != null) {
                        JTA.parseAndSetParameter(value, operation, reader);
                    }
                    break;
                }
            case CONNECTABLE:
                {
                    final String value = rawAttributeText(reader, CONNECTABLE.getXmlName());
                    if (value != null) {
                        CONNECTABLE.parseAndSetParameter(value, operation, reader);
                    }
                    break;
                }
            case MCP:
                {
                    final String value = rawAttributeText(reader, MCP.getXmlName());
                    if (value != null) {
                        MCP.parseAndSetParameter(value, operation, reader);
                    }
                    break;
                }
            case ENLISTMENT_TRACE:
                {
                    final String value = rawAttributeText(reader, ENLISTMENT_TRACE.getXmlName());
                    ENLISTMENT_TRACE.parseAndSetParameter(value, operation, reader);
                    break;
                }
            case TRACKING:
                {
                    final String value = rawAttributeText(reader, TRACKING.getXmlName());
                    if (value != null) {
                        TRACKING.parseAndSetParameter(value, operation, reader);
                    }
                    break;
                }
            default:
                if (Constants.STATISTICS_ENABLED.getName().equals(reader.getAttributeLocalName(i))) {
                    final String value = rawAttributeText(reader, Constants.STATISTICS_ENABLED.getXmlName());
                    if (value != null) {
                        Constants.STATISTICS_ENABLED.parseAndSetParameter(value, operation, reader);
                    }
                    break;
                } else {
                    throw ParseUtils.unexpectedAttribute(reader, i);
                }
        }
    }
    final ModelNode dsAddress = parentAddress.clone();
    dsAddress.add(DATA_SOURCE, poolName);
    dsAddress.protect();
    operation.get(OP_ADDR).set(dsAddress);
    List&lt;ModelNode&gt; configPropertiesOperations = new ArrayList&lt;ModelNode&gt;(0);
    while (reader.hasNext()) {
        switch(reader.nextTag()) {
            case END_ELEMENT:
                {
                    if (DataSources.Tag.forName(reader.getLocalName()) == DataSources.Tag.DATASOURCE) {
                        list.add(operation);
                        list.addAll(configPropertiesOperations);
                        return;
                    } else {
                        if (DataSource.Tag.forName(reader.getLocalName()) == DataSource.Tag.UNKNOWN) {
                            throw new ParserException(bundle.unexpectedEndTag(reader.getLocalName()));
                        }
                    }
                    break;
                }
            case START_ELEMENT:
                {
                    switch(DataSource.Tag.forName(reader.getLocalName())) {
                        case CONNECTION_PROPERTY:
                            {
                                String name = rawAttributeText(reader, &quot;name&quot;);
                                String value = rawElementText(reader);
                                final ModelNode configOperation = new ModelNode();
                                configOperation.get(OP).set(ADD);
                                final ModelNode configAddress = dsAddress.clone();
                                configAddress.add(CONNECTION_PROPERTIES.getName(), name);
                                configAddress.protect();
                                configOperation.get(OP_ADDR).set(configAddress);
                                CONNECTION_PROPERTY_VALUE.parseAndSetParameter(value, configOperation, reader);
                                configPropertiesOperations.add(configOperation);
                                break;
                            }
                        case CONNECTION_URL:
                            {
                                String value = rawElementText(reader);
                                CONNECTION_URL.parseAndSetParameter(value, operation, reader);
                                break;
                            }
                        case DRIVER_CLASS:
                            {
                                String value = rawElementText(reader);
                                DRIVER_CLASS.parseAndSetParameter(value, operation, reader);
                                break;
                            }
                        case DATASOURCE_CLASS:
                            {
                                String value = rawElementText(reader);
                                DATASOURCE_CLASS.parseAndSetParameter(value, operation, reader);
                                break;
                            }
                        case DRIVER:
                            {
                                String value = rawElementText(reader);
                                DATASOURCE_DRIVER.parseAndSetParameter(value, operation, reader);
                                break;
                            }
                        case POOL:
                            {
                                parsePool(reader, operation);
                                break;
                            }
                        case NEW_CONNECTION_SQL:
                            {
                                String value = rawElementText(reader);
                                NEW_CONNECTION_SQL.parseAndSetParameter(value, operation, reader);
                                break;
                            }
                        case URL_DELIMITER:
                            {
                                String value = rawElementText(reader);
                                URL_DELIMITER.parseAndSetParameter(value, operation, reader);
                                break;
                            }
                        case URL_SELECTOR_STRATEGY_CLASS_NAME:
                            {
                                String value = rawElementText(reader);
                                URL_SELECTOR_STRATEGY_CLASS_NAME.parseAndSetParameter(value, operation, reader);
                                break;
                            }
                        case TRANSACTION_ISOLATION:
                            {
                                String value = rawElementText(reader);
                                TRANSACTION_ISOLATION.parseAndSetParameter(value, operation, reader);
                                break;
                            }
                        case SECURITY:
                            {
                                switch(Namespace.forUri(reader.getNamespaceURI())) {
                                    case DATASOURCES_4_0:
                                        parseDsSecurity(reader, operation);
                                        break;
                                    case DATASOURCES_5_0:
                                    case DATASOURCES_6_0:
                                    case DATASOURCES_7_0:
                                        parseDsSecurity_5_0(reader, operation);
                                        break;
                                    default:
                                        parseDsSecurity_7_1(reader, operation);
                                }
                                break;
                            }
                        case STATEMENT:
                            {
                                parseStatementSettings(reader, operation);
                                break;
                            }
                        case TIMEOUT:
                            {
                                parseTimeOutSettings(reader, operation);
                                break;
                            }
                        case VALIDATION:
                            {
                                parseValidationSetting_7_0(reader, operation);
                                break;
                            }
                        default:
                            throw new ParserException(bundle.unexpectedElement(reader.getLocalName()));
                    }
                    break;
                }
        }
    }
    throw new ParserException(bundle.unexpectedEndOfDocument());
}
</code></pre></div></td>
</tr>
<tr>
    <td>19</td><td>3292.48</td><td>74</td><td>127</td>
    <td><div class="code-container"><pre><code class="language-java">private boolean isAttributeExcluded(PathAddress address, String attrName, ModelNode attrDesc, ModelNode resourceNoDefaults) {
    if (!attrDesc.get(ACCESS_TYPE).isDefined() || !attrDesc.get(ACCESS_TYPE).asString().equalsIgnoreCase(&quot;read-write&quot;)) {
        return true;
    }
    if (attrDesc.get(STORAGE).isDefined() &amp;&amp; !attrDesc.get(STORAGE).asString().equalsIgnoreCase(&quot;configuration&quot;)) {
        return true;
    }
    if (attrDesc.get(ModelDescriptionConstants.DEPRECATED).isDefined()) {
        return true;
    }
    if (&quot;default-web-module&quot;.equals(attrName)) {
        if (address.size() &gt; 1) {
            PathElement subPe = address.getElement(0);
            if (&quot;subsystem&quot;.equals(subPe.getKey()) &amp;&amp; &quot;web&quot;.equals(subPe.getValue()) &amp;&amp; &quot;virtual-server&quot;.equals(address.getLastElement().getKey())) {
                return true;
            }
        }
    } else if (&quot;policy-modules&quot;.equals(attrName) || &quot;login-modules&quot;.equals(attrName)) {
        if (address.size() &gt; 2) {
            PathElement subPe = address.getElement(0);
            if (&quot;subsystem&quot;.equals(subPe.getKey()) &amp;&amp; &quot;security&quot;.equals(subPe.getValue()) &amp;&amp; &quot;security-domain&quot;.equals(address.getElement(1).getKey())) {
                return true;
            }
        }
    } else if (&quot;virtual-nodes&quot;.equals(attrName)) {
        if (address.size() == 3) {
            PathElement subPe = address.getElement(0);
            PathElement containerPe = address.getElement(1);
            PathElement distPe = address.getElement(2);
            if (&quot;subsystem&quot;.equals(subPe.getKey()) &amp;&amp; &quot;infinispan&quot;.equals(subPe.getValue()) &amp;&amp; &quot;cache-container&quot;.equals(containerPe.getKey()) &amp;&amp; &quot;distributed-cache&quot;.equals(distPe.getKey())) {
                return true;
            }
        }
    } else if (address.size() &gt; 0 &amp;&amp; &quot;transactions&quot;.equals(address.getLastElement().getValue()) &amp;&amp; &quot;subsystem&quot;.equals(address.getLastElement().getKey())) {
        if (attrName.contains(&quot;jdbc&quot;)) {
            return !resourceNoDefaults.hasDefined(&quot;use-jdbc-store&quot;) || !resourceNoDefaults.get(&quot;use-jdbc-store&quot;).asBoolean();
        } else if (attrName.contains(&quot;journal&quot;)) {
            return !resourceNoDefaults.hasDefined(&quot;use-journal-store&quot;) || !resourceNoDefaults.get(&quot;use-journal-store&quot;).asBoolean();
        }
    } else if (&quot;security-application&quot;.equals(attrName)) {
        if (address.size() == 3) {
            PathElement subPe = address.getElement(0);
            PathElement raPe = address.getElement(1);
            PathElement connPe = address.getElement(2);
            if (&quot;subsystem&quot;.equals(subPe.getKey()) &amp;&amp; &quot;resource-adapters&quot;.equals(subPe.getValue()) &amp;&amp; &quot;resource-adapter&quot;.equals(raPe.getKey()) &amp;&amp; &quot;connection-definitions&quot;.equals(connPe.getKey())) {
                return true;
            }
        }
    } else if (attrName.startsWith(&quot;wm-security&quot;)) {
        if (address.size() == 2) {
            PathElement subPe = address.getElement(0);
            PathElement raPe = address.getElement(1);
            if (&quot;subsystem&quot;.equals(subPe.getKey()) &amp;&amp; &quot;resource-adapters&quot;.equals(subPe.getValue()) &amp;&amp; &quot;resource-adapter&quot;.equals(raPe.getKey())) {
                return true;
            }
        }
    } else if (&quot;transaction-support&quot;.equals(attrName)) {
        if (address.size() == 2) {
            PathElement subPe = address.getElement(0);
            PathElement raPe = address.getElement(1);
            if (&quot;subsystem&quot;.equals(subPe.getKey()) &amp;&amp; &quot;resource-adapters&quot;.equals(subPe.getValue()) &amp;&amp; &quot;resource-adapter&quot;.equals(raPe.getKey())) {
                return true;
            }
        }
    } else if (&quot;pool-fair&quot;.equals(attrName) || &quot;pad-xid&quot;.equals(attrName) || &quot;interleaving&quot;.equals(attrName) || &quot;no-tx-separate-pool&quot;.equals(attrName) || &quot;wrap-xa-resource&quot;.equals(attrName)) {
        if (address.size() == 3) {
            PathElement subPe = address.getElement(0);
            PathElement raPe = address.getElement(1);
            PathElement connPe = address.getElement(2);
            if (&quot;subsystem&quot;.equals(subPe.getKey()) &amp;&amp; &quot;resource-adapters&quot;.equals(subPe.getValue()) &amp;&amp; &quot;resource-adapter&quot;.equals(raPe.getKey()) &amp;&amp; &quot;connection-definitions&quot;.equals(connPe.getKey())) {
                return true;
            }
        }
    } else if (&quot;fixed-source-port&quot;.equals(attrName)) {
        if (address.size() == 2) {
            PathElement socketBindingGroupPe = address.getElement(0);
            PathElement remoteDestPe = address.getElement(1);
            if (&quot;socket-binding-group&quot;.equals(socketBindingGroupPe.getKey()) &amp;&amp; &quot;remote-destination-outbound-socket-binding&quot;.equals(remoteDestPe.getKey())) {
                return true;
            }
        }
    } else if (&quot;console-enabled&quot;.equals(attrName)) {
        if (address.size() == 2) {
            PathElement coreServicePe = address.getElement(0);
            PathElement mngmtIfPe = address.getElement(1);
            if (&quot;core-service&quot;.equals(coreServicePe.getKey()) &amp;&amp; &quot;management&quot;.equals(coreServicePe.getValue()) &amp;&amp; &quot;management-interface&quot;.equals(mngmtIfPe.getKey()) &amp;&amp; &quot;http-interface&quot;.equals(mngmtIfPe.getValue())) {
                return true;
            }
        }
    } else if (&quot;async-registration&quot;.equals(attrName)) {
        if (address.size() &gt; 0) {
            PathElement coreServicePe = address.getElement(0);
            if (&quot;subsystem&quot;.equals(coreServicePe.getKey()) &amp;&amp; &quot;xts&quot;.equals(coreServicePe.getValue())) {
                return true;
            }
        }
    } else if (&quot;path&quot;.equals(attrName) &amp;&amp; address.size() == 1 &amp;&amp; &quot;path&quot;.equals(address.getElement(0).getKey())) {
        try {
            return readAttribute(address, &quot;read-only&quot;).asBoolean();
        } catch (IOException | MgmtOperationException e) {
            throw new RuntimeException(e);
        }
    }
    return false;
}
</code></pre></div></td>
</tr>
<tr>
    <td>20</td><td>4435.88</td><td>54</td><td>143</td>
    <td><div class="code-container"><pre><code class="language-java">private void writeConDef(XMLExtendedStreamWriter streamWriter, ModelNode conDef, final String poolName, final boolean isXa) throws XMLStreamException {
    streamWriter.writeStartElement(Activation.Tag.CONNECTION_DEFINITION.getLocalName());
    CLASS_NAME.marshallAsAttribute(conDef, streamWriter);
    JNDI_NAME.marshallAsAttribute(conDef, streamWriter);
    ENABLED.marshallAsAttribute(conDef, streamWriter);
    CONNECTABLE.marshallAsAttribute(conDef, streamWriter);
    TRACKING.marshallAsAttribute(conDef, streamWriter);
    USE_JAVA_CONTEXT.marshallAsAttribute(conDef, streamWriter);
    streamWriter.writeAttribute(&quot;pool-name&quot;, poolName);
    USE_CCM.marshallAsAttribute(conDef, streamWriter);
    SHARABLE.marshallAsAttribute(conDef, streamWriter);
    ENLISTMENT.marshallAsAttribute(conDef, streamWriter);
    MCP.marshallAsAttribute(conDef, streamWriter);
    ENLISTMENT_TRACE.marshallAsAttribute(conDef, streamWriter);
    writeNewConfigProperties(streamWriter, conDef);
    boolean poolRequired = INITIAL_POOL_SIZE.isMarshallable(conDef) || MAX_POOL_SIZE.isMarshallable(conDef) || MIN_POOL_SIZE.isMarshallable(conDef) || POOL_USE_STRICT_MIN.isMarshallable(conDef) || POOL_PREFILL.isMarshallable(conDef) || POOL_FAIR.isMarshallable(conDef) || POOL_FLUSH_STRATEGY.isMarshallable(conDef);
    final boolean capacityRequired = CAPACITY_INCREMENTER_CLASS.isMarshallable(conDef) || CAPACITY_INCREMENTER_PROPERTIES.isMarshallable(conDef) || CAPACITY_DECREMENTER_CLASS.isMarshallable(conDef) || CAPACITY_DECREMENTER_PROPERTIES.isMarshallable(conDef);
    poolRequired = poolRequired || capacityRequired;
    if (poolRequired) {
        if (isXa) {
            streamWriter.writeStartElement(ConnectionDefinition.Tag.XA_POOL.getLocalName());
            MIN_POOL_SIZE.marshallAsElement(conDef, streamWriter);
            INITIAL_POOL_SIZE.marshallAsElement(conDef, streamWriter);
            MAX_POOL_SIZE.marshallAsElement(conDef, streamWriter);
            POOL_PREFILL.marshallAsElement(conDef, streamWriter);
            POOL_FAIR.marshallAsElement(conDef, streamWriter);
            POOL_USE_STRICT_MIN.marshallAsElement(conDef, streamWriter);
            POOL_FLUSH_STRATEGY.marshallAsElement(conDef, streamWriter);
            SAME_RM_OVERRIDE.marshallAsElement(conDef, streamWriter);
            if (conDef.hasDefined(INTERLEAVING.getName()) &amp;&amp; conDef.get(INTERLEAVING.getName()).getType().equals(ModelType.BOOLEAN) &amp;&amp; conDef.get(INTERLEAVING.getName()).asBoolean()) {
                streamWriter.writeEmptyElement(INTERLEAVING.getXmlName());
            } else {
                INTERLEAVING.marshallAsElement(conDef, streamWriter);
            }
            if (conDef.hasDefined(NOTXSEPARATEPOOL.getName()) &amp;&amp; conDef.get(NOTXSEPARATEPOOL.getName()).getType().equals(ModelType.BOOLEAN) &amp;&amp; conDef.get(NOTXSEPARATEPOOL.getName()).asBoolean()) {
                streamWriter.writeEmptyElement(NOTXSEPARATEPOOL.getXmlName());
            } else {
                NOTXSEPARATEPOOL.marshallAsElement(conDef, streamWriter);
            }
            PAD_XID.marshallAsElement(conDef, streamWriter);
            WRAP_XA_RESOURCE.marshallAsElement(conDef, streamWriter);
        } else {
            streamWriter.writeStartElement(ConnectionDefinition.Tag.POOL.getLocalName());
            MIN_POOL_SIZE.marshallAsElement(conDef, streamWriter);
            INITIAL_POOL_SIZE.marshallAsElement(conDef, streamWriter);
            MAX_POOL_SIZE.marshallAsElement(conDef, streamWriter);
            POOL_PREFILL.marshallAsElement(conDef, streamWriter);
            POOL_USE_STRICT_MIN.marshallAsElement(conDef, streamWriter);
            POOL_FLUSH_STRATEGY.marshallAsElement(conDef, streamWriter);
        }
        if (capacityRequired) {
            streamWriter.writeStartElement(Pool.Tag.CAPACITY.getLocalName());
            if (conDef.hasDefined(CAPACITY_INCREMENTER_CLASS.getName())) {
                streamWriter.writeStartElement(Capacity.Tag.INCREMENTER.getLocalName());
                CAPACITY_INCREMENTER_CLASS.marshallAsAttribute(conDef, streamWriter);
                CAPACITY_INCREMENTER_PROPERTIES.marshallAsElement(conDef, streamWriter);
                streamWriter.writeEndElement();
            }
            if (conDef.hasDefined(CAPACITY_DECREMENTER_CLASS.getName())) {
                streamWriter.writeStartElement(Capacity.Tag.DECREMENTER.getLocalName());
                CAPACITY_DECREMENTER_CLASS.marshallAsAttribute(conDef, streamWriter);
                CAPACITY_DECREMENTER_PROPERTIES.marshallAsElement(conDef, streamWriter);
                streamWriter.writeEndElement();
            }
            streamWriter.writeEndElement();
        }
        streamWriter.writeEndElement();
    }
    if (conDef.hasDefined(APPLICATION.getName()) || conDef.hasDefined(SECURITY_DOMAIN.getName()) || conDef.hasDefined(SECURITY_DOMAIN_AND_APPLICATION.getName()) || conDef.hasDefined(ELYTRON_ENABLED.getName())) {
        streamWriter.writeStartElement(ConnectionDefinition.Tag.SECURITY.getLocalName());
        if (conDef.hasDefined(APPLICATION.getName()) &amp;&amp; conDef.get(APPLICATION.getName()).getType().equals(ModelType.BOOLEAN) &amp;&amp; conDef.get(APPLICATION.getName()).asBoolean()) {
            streamWriter.writeEmptyElement(APPLICATION.getXmlName());
        } else {
            APPLICATION.marshallAsElement(conDef, streamWriter);
        }
        SECURITY_DOMAIN.marshallAsElement(conDef, streamWriter);
        SECURITY_DOMAIN_AND_APPLICATION.marshallAsElement(conDef, streamWriter);
        ELYTRON_ENABLED.marshallAsElement(conDef, streamWriter);
        AUTHENTICATION_CONTEXT.marshallAsElement(conDef, streamWriter);
        AUTHENTICATION_CONTEXT_AND_APPLICATION.marshallAsElement(conDef, streamWriter);
        streamWriter.writeEndElement();
    }
    if (conDef.hasDefined(BLOCKING_TIMEOUT_WAIT_MILLIS.getName()) || conDef.hasDefined(IDLETIMEOUTMINUTES.getName()) || conDef.hasDefined(ALLOCATION_RETRY.getName()) || conDef.hasDefined(ALLOCATION_RETRY_WAIT_MILLIS.getName()) || conDef.hasDefined(XA_RESOURCE_TIMEOUT.getName())) {
        streamWriter.writeStartElement(ConnectionDefinition.Tag.TIMEOUT.getLocalName());
        BLOCKING_TIMEOUT_WAIT_MILLIS.marshallAsElement(conDef, streamWriter);
        IDLETIMEOUTMINUTES.marshallAsElement(conDef, streamWriter);
        ALLOCATION_RETRY.marshallAsElement(conDef, streamWriter);
        ALLOCATION_RETRY_WAIT_MILLIS.marshallAsElement(conDef, streamWriter);
        XA_RESOURCE_TIMEOUT.marshallAsElement(conDef, streamWriter);
        streamWriter.writeEndElement();
    }
    if (conDef.hasDefined(BACKGROUNDVALIDATION.getName()) || conDef.hasDefined(BACKGROUNDVALIDATIONMILLIS.getName()) || conDef.hasDefined(USE_FAST_FAIL.getName()) || conDef.hasDefined(VALIDATE_ON_MATCH.getName())) {
        streamWriter.writeStartElement(ConnectionDefinition.Tag.VALIDATION.getLocalName());
        BACKGROUNDVALIDATION.marshallAsElement(conDef, streamWriter);
        BACKGROUNDVALIDATIONMILLIS.marshallAsElement(conDef, streamWriter);
        USE_FAST_FAIL.marshallAsElement(conDef, streamWriter);
        VALIDATE_ON_MATCH.marshallAsElement(conDef, streamWriter);
        streamWriter.writeEndElement();
    }
    if (conDef.hasDefined(RECOVERY_USERNAME.getName()) || conDef.hasDefined(RECOVERY_PASSWORD.getName()) || conDef.hasDefined(RECOVERY_SECURITY_DOMAIN.getName()) || conDef.hasDefined(RECOVER_PLUGIN_CLASSNAME.getName()) || conDef.hasDefined(RECOVER_PLUGIN_PROPERTIES.getName()) || conDef.hasDefined(NO_RECOVERY.getName()) || conDef.hasDefined(ELYTRON_ENABLED.getName())) {
        streamWriter.writeStartElement(ConnectionDefinition.Tag.RECOVERY.getLocalName());
        NO_RECOVERY.marshallAsAttribute(conDef, streamWriter);
        if (conDef.hasDefined(RECOVERY_USERNAME.getName()) || conDef.hasDefined(RECOVERY_PASSWORD.getName()) || conDef.hasDefined(RECOVERY_CREDENTIAL_REFERENCE.getName()) || conDef.hasDefined(RECOVERY_SECURITY_DOMAIN.getName()) || conDef.hasDefined(RECOVERY_ELYTRON_ENABLED.getName())) {
            streamWriter.writeStartElement(Recovery.Tag.RECOVER_CREDENTIAL.getLocalName());
            RECOVERY_USERNAME.marshallAsAttribute(conDef, streamWriter);
            RECOVERY_PASSWORD.marshallAsAttribute(conDef, streamWriter);
            RECOVERY_CREDENTIAL_REFERENCE.marshallAsElement(conDef, streamWriter);
            RECOVERY_SECURITY_DOMAIN.marshallAsElement(conDef, streamWriter);
            RECOVERY_ELYTRON_ENABLED.marshallAsElement(conDef, streamWriter);
            RECOVERY_AUTHENTICATION_CONTEXT.marshallAsElement(conDef, streamWriter);
            streamWriter.writeEndElement();
        }
        if (conDef.hasDefined(RECOVER_PLUGIN_CLASSNAME.getName()) || conDef.hasDefined(RECOVER_PLUGIN_PROPERTIES.getName())) {
            streamWriter.writeStartElement(Recovery.Tag.RECOVER_PLUGIN.getLocalName());
            RECOVER_PLUGIN_CLASSNAME.marshallAsAttribute(conDef, streamWriter);
            if (conDef.hasDefined(RECOVER_PLUGIN_PROPERTIES.getName())) {
                for (Property property : conDef.get(RECOVER_PLUGIN_PROPERTIES.getName()).asPropertyList()) {
                    writeProperty(streamWriter, conDef, property.getName(), property.getValue().asString(), org.jboss.jca.common.api.metadata.common.Extension.Tag.CONFIG_PROPERTY.getLocalName());
                }
            }
            streamWriter.writeEndElement();
        }
        streamWriter.writeEndElement();
    }
    streamWriter.writeEndElement();
}
</code></pre></div></td>
</tr>
<tr>
    <td>21</td><td>6103.05</td><td>16</td><td>195</td>
    <td><div class="code-container"><pre><code class="language-java">private void testFailover(Lifecycle lifecycle, URL baseURL1, URL baseURL2, URL baseURL3) throws Exception {
    URI uri1 = SimpleServlet.createURI(baseURL1);
    URI uri2 = SimpleServlet.createURI(baseURL2);
    URI uri3 = SimpleServlet.createURI(baseURL3);
    this.establishTopology(baseURL1, THREE_NODES);
    int value = 1;
    String lastOwner;
    try (CloseableHttpClient client = TestHttpClientUtils.promiscuousCookieHttpClient()) {
        try (CloseableHttpResponse response = client.execute(new HttpGet(uri1))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertEquals(value++, Integer.parseInt(response.getFirstHeader(SimpleServlet.VALUE_HEADER).getValue()));
            Map.Entry&lt;String, String&gt; entry = parseSessionRoute(response);
            Assert.assertNotNull(entry);
            Assert.assertEquals(NODE_1, entry.getValue());
            lastOwner = entry.getValue();
            Assert.assertEquals(entry.getKey(), response.getFirstHeader(SimpleServlet.SESSION_ID_HEADER).getValue());
        }
        this.nonTxWait.run();
        try (CloseableHttpResponse response = client.execute(new HttpGet(uri2))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertEquals(value++, Integer.parseInt(response.getFirstHeader(SimpleServlet.VALUE_HEADER).getValue()));
            Map.Entry&lt;String, String&gt; entry = parseSessionRoute(response);
            if (!this.cacheMode.needsStateTransfer()) {
                Assert.assertNotNull(entry);
                Assert.assertEquals(NODE_2, entry.getValue());
                lastOwner = entry.getValue();
            } else {
                Assert.assertNull(entry);
            }
        }
        this.nonTxWait.run();
        try (CloseableHttpResponse response = client.execute(new HttpGet(uri3))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertEquals(value++, Integer.parseInt(response.getFirstHeader(SimpleServlet.VALUE_HEADER).getValue()));
            Map.Entry&lt;String, String&gt; entry = parseSessionRoute(response);
            if (!this.cacheMode.needsStateTransfer()) {
                Assert.assertNotNull(entry);
                Assert.assertEquals(NODE_3, entry.getValue());
                lastOwner = entry.getValue();
            } else {
                Assert.assertNull(entry);
            }
        }
        this.nonTxWait.run();
        lifecycle.stop(NODE_1);
        this.establishTopology(baseURL2, NODE_2, NODE_3);
        try (CloseableHttpResponse response = client.execute(new HttpGet(uri2))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertEquals(value++, Integer.parseInt(response.getFirstHeader(SimpleServlet.VALUE_HEADER).getValue()));
            Map.Entry&lt;String, String&gt; entry = parseSessionRoute(response);
            Assert.assertNotNull(entry);
            Assert.assertNotEquals(lastOwner, entry.getValue());
            lastOwner = entry.getValue();
            Assert.assertEquals(entry.getKey(), response.getFirstHeader(SimpleServlet.SESSION_ID_HEADER).getValue());
        }
        try (CloseableHttpResponse response = client.execute(new HttpGet(uri2))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertEquals(value++, Integer.parseInt(response.getFirstHeader(SimpleServlet.VALUE_HEADER).getValue()));
            Map.Entry&lt;String, String&gt; entry = parseSessionRoute(response);
            if (entry != null) {
                Assert.assertNotEquals(lastOwner, entry.getValue());
                lastOwner = entry.getValue();
                Assert.assertEquals(entry.getKey(), response.getFirstHeader(SimpleServlet.SESSION_ID_HEADER).getValue());
            }
        }
        this.nonTxWait.run();
        try (CloseableHttpResponse response = client.execute(new HttpGet(uri3))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertEquals(value++, Integer.parseInt(response.getFirstHeader(SimpleServlet.VALUE_HEADER).getValue()));
            Map.Entry&lt;String, String&gt; entry = parseSessionRoute(response);
            if (!this.cacheMode.needsStateTransfer()) {
                Assert.assertNotNull(entry);
                Assert.assertEquals(NODE_3, entry.getValue());
            } else {
                Assert.assertNull(entry);
            }
        }
        try (CloseableHttpResponse response = client.execute(new HttpGet(uri3))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertEquals(value++, Integer.parseInt(response.getFirstHeader(SimpleServlet.VALUE_HEADER).getValue()));
            Map.Entry&lt;String, String&gt; entry = parseSessionRoute(response);
            Assert.assertNull(entry);
        }
        lifecycle.start(NODE_1);
        this.establishTopology(baseURL2, THREE_NODES);
        try (CloseableHttpResponse response = client.execute(new HttpGet(uri2))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertEquals(value++, Integer.parseInt(response.getFirstHeader(SimpleServlet.VALUE_HEADER).getValue()));
            Map.Entry&lt;String, String&gt; entry = parseSessionRoute(response);
            if (!this.cacheMode.needsStateTransfer()) {
                Assert.assertNotNull(entry);
                Assert.assertEquals(NODE_2, entry.getValue());
            } else if (entry != null) {
                Assert.assertNotEquals(lastOwner, entry.getValue());
                lastOwner = entry.getValue();
                Assert.assertEquals(entry.getKey(), response.getFirstHeader(SimpleServlet.SESSION_ID_HEADER).getValue());
            }
        }
        try (CloseableHttpResponse response = client.execute(new HttpGet(uri2))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertEquals(value++, Integer.parseInt(response.getFirstHeader(SimpleServlet.VALUE_HEADER).getValue()));
            Map.Entry&lt;String, String&gt; entry = parseSessionRoute(response);
            Assert.assertNull(entry);
        }
        this.nonTxWait.run();
        try (CloseableHttpResponse response = client.execute(new HttpGet(uri3))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertEquals(value++, Integer.parseInt(response.getFirstHeader(SimpleServlet.VALUE_HEADER).getValue()));
            Map.Entry&lt;String, String&gt; entry = parseSessionRoute(response);
            if (!this.cacheMode.needsStateTransfer()) {
                Assert.assertNotNull(entry);
                Assert.assertEquals(NODE_3, entry.getValue());
            } else {
                Assert.assertNull(entry);
            }
        }
        this.nonTxWait.run();
        lifecycle.stop(NODE_2);
        this.establishTopology(baseURL1, NODE_1, NODE_3);
        try (CloseableHttpResponse response = client.execute(new HttpGet(uri1))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertEquals(value++, Integer.parseInt(response.getFirstHeader(SimpleServlet.VALUE_HEADER).getValue()));
            Map.Entry&lt;String, String&gt; entry = parseSessionRoute(response);
            if (entry != null) {
                Assert.assertNotEquals(lastOwner, entry.getValue());
                lastOwner = entry.getValue();
                Assert.assertEquals(entry.getKey(), response.getFirstHeader(SimpleServlet.SESSION_ID_HEADER).getValue());
            }
        }
        try (CloseableHttpResponse response = client.execute(new HttpGet(uri1))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertEquals(value++, Integer.parseInt(response.getFirstHeader(SimpleServlet.VALUE_HEADER).getValue()));
            Map.Entry&lt;String, String&gt; entry = parseSessionRoute(response);
            if (entry != null) {
                Assert.assertNotEquals(lastOwner, entry.getValue());
                lastOwner = entry.getValue();
                Assert.assertEquals(entry.getKey(), response.getFirstHeader(SimpleServlet.SESSION_ID_HEADER).getValue());
            }
        }
        this.nonTxWait.run();
        try (CloseableHttpResponse response = client.execute(new HttpGet(uri3))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertEquals(value++, Integer.parseInt(response.getFirstHeader(SimpleServlet.VALUE_HEADER).getValue()));
            Map.Entry&lt;String, String&gt; entry = parseSessionRoute(response);
            if (!this.cacheMode.needsStateTransfer()) {
                Assert.assertNotNull(entry);
                Assert.assertEquals(NODE_3, entry.getValue());
            } else {
                if (entry != null) {
                    Assert.assertNotEquals(lastOwner, entry.getValue());
                    lastOwner = entry.getValue();
                    Assert.assertEquals(entry.getKey(), response.getFirstHeader(SimpleServlet.SESSION_ID_HEADER).getValue());
                }
            }
        }
        try (CloseableHttpResponse response = client.execute(new HttpGet(uri3))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertEquals(value++, Integer.parseInt(response.getFirstHeader(SimpleServlet.VALUE_HEADER).getValue()));
            Map.Entry&lt;String, String&gt; entry = parseSessionRoute(response);
            if (entry != null) {
                Assert.assertNotEquals(lastOwner, entry.getValue());
                lastOwner = entry.getValue();
                Assert.assertEquals(entry.getKey(), response.getFirstHeader(SimpleServlet.SESSION_ID_HEADER).getValue());
            }
        }
        lifecycle.start(NODE_2);
        this.establishTopology(baseURL1, THREE_NODES);
        this.nonTxWait.run();
        try (CloseableHttpResponse response = client.execute(new HttpGet(uri1))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertEquals(value++, Integer.parseInt(response.getFirstHeader(SimpleServlet.VALUE_HEADER).getValue()));
            Map.Entry&lt;String, String&gt; entry = parseSessionRoute(response);
            if (!this.cacheMode.needsStateTransfer()) {
                Assert.assertNotNull(entry);
                Assert.assertEquals(NODE_1, entry.getValue());
            } else if (entry != null) {
                Assert.assertNotEquals(lastOwner, entry.getValue());
                Assert.assertEquals(entry.getKey(), response.getFirstHeader(SimpleServlet.SESSION_ID_HEADER).getValue());
            }
        }
        try (CloseableHttpResponse response = client.execute(new HttpGet(uri1))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertEquals(value, Integer.parseInt(response.getFirstHeader(SimpleServlet.VALUE_HEADER).getValue()));
            Map.Entry&lt;String, String&gt; entry = parseSessionRoute(response);
            if (entry != null) {
                Assert.assertNotEquals(lastOwner, entry.getValue());
                lastOwner = entry.getValue();
                Assert.assertEquals(entry.getKey(), response.getFirstHeader(SimpleServlet.SESSION_ID_HEADER).getValue());
            }
        }
        try (CloseableHttpResponse response = client.execute(new HttpDelete(uri1))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
        }
    }
}
</code></pre></div></td>
</tr>
<tr>
    <td>22</td><td>4143.97</td><td>36</td><td>141</td>
    <td><div class="code-container"><pre><code class="language-java">protected void testComponent(String type, String name, boolean expectTimer) throws Exception {
    ModelNode address = getComponentAddress(type, name).toModelNode();
    address.protect();
    ModelNode resourceDescription = executeOperation(managementClient, ModelDescriptionConstants.READ_RESOURCE_DESCRIPTION_OPERATION, address);
    ModelNode resource = executeOperation(managementClient, ModelDescriptionConstants.READ_RESOURCE_OPERATION, address);
    assertTrue(resourceDescription.get(ATTRIBUTES, COMPONENT_CLASS_NAME).isDefined());
    assertEquals(ModelType.STRING, resourceDescription.get(ATTRIBUTES, COMPONENT_CLASS_NAME, DESCRIPTION).getType());
    assertEquals(ModelType.STRING, resourceDescription.get(ATTRIBUTES, COMPONENT_CLASS_NAME, TYPE).asType());
    final ModelNode componentClassNameNode = resource.get(COMPONENT_CLASS_NAME);
    assertTrue(componentClassNameNode.isDefined());
    final String componentClassName = componentClassNameNode.asString();
    validateSecurity(address, resourceDescription, resource);
    if (!STATEFUL.equals(type) &amp;&amp; !SINGLETON.equals(type)) {
        validatePool(address, resourceDescription, resource);
    } else {
        for (String attr : POOL_ATTRIBUTES) {
            assertFalse(resourceDescription.get(ModelDescriptionConstants.ATTRIBUTES).has(attr));
            assertFalse(resource.has(attr));
        }
    }
    if (STATELESS.equals(type) || SINGLETON.equals(type) || MESSAGE_DRIVEN.equals(type)) {
        validateTimer(address, resourceDescription, resource, expectTimer);
        assertEquals(TransactionManagementType.CONTAINER.name(), resource.get(TRANSACTION_TYPE).asString());
    } else {
        assertFalse(resourceDescription.get(ModelDescriptionConstants.ATTRIBUTES).has(TIMER_ATTRIBUTE));
        assertFalse(resource.has(TIMER_ATTRIBUTE));
        assertEquals(TransactionManagementType.BEAN.name(), resource.get(TRANSACTION_TYPE).asString());
        if (componentClassName.equals(&quot;org.jboss.as.test.integration.ejb.management.deployments.ManagedStatefulBean&quot;)) {
            assertTrue(resource.get(PASSIVATION_CAPABLE).asBoolean());
            assertFalse(resource.get(AFTER_BEGIN_METHOD).isDefined());
            assertFalse(resource.get(BEFORE_COMPLETION_METHOD).isDefined());
            assertFalse(resource.get(AFTER_COMPLETION_METHOD).isDefined());
        } else {
            assertFalse(resource.get(PASSIVATION_CAPABLE).asBoolean());
            assertEquals(&quot;2 HOURS&quot;, resource.get(STATEFUL_TIMEOUT).asString());
            assertEquals(&quot;private void afterBegin()&quot;, resource.get(AFTER_BEGIN_METHOD).asString());
            assertEquals(&quot;private void beforeCompletion()&quot;, resource.get(BEFORE_COMPLETION_METHOD).asString());
            assertEquals(&quot;private void afterCompletion()&quot;, resource.get(AFTER_COMPLETION_METHOD).asString());
            final ModelNode removeMethodsNode = resource.get(REMOVE_METHODS);
            final List&lt;ModelNode&gt; removeMethodsList = removeMethodsNode.asList();
            assertTrue(removeMethodsList.size() == 1 || removeMethodsList.size() == 3);
            for (ModelNode m : removeMethodsList) {
                final String beanMethod = m.get(BEAN_METHOD).asString();
                final boolean retainIfException = m.get(RETAIN_IF_EXCEPTION).asBoolean();
                if (beanMethod.contains(&quot;void removeTrue()&quot;)) {
                    assertTrue(retainIfException);
                } else if (beanMethod.contains(&quot;void removeFalse()&quot;) || beanMethod.contains(&quot;void remove()&quot;)) {
                    assertFalse(retainIfException);
                } else {
                    fail(&quot;Unknown stateful bean remove method: &quot; + beanMethod);
                }
            }
        }
    }
    if (SINGLETON.equals(type)) {
        final ModelNode concurrencyTypeNode = resource.get(CONCURRENCY_MANAGEMENT_TYPE);
        final ModelNode initOnStartUpNode = resource.get(INIT_ON_STARTUP);
        final ModelNode dependsOnNode = resource.get(DEPENDS_ON);
        if (componentClassName.equals(&quot;org.jboss.as.test.integration.ejb.management.deployments.ManagedSingletonBean&quot;)) {
            assertFalse(initOnStartUpNode.asBoolean());
            assertFalse(dependsOnNode.isDefined());
            assertFalse(concurrencyTypeNode.isDefined());
        } else {
            assertTrue(initOnStartUpNode.asBoolean());
            assertEquals(ConcurrencyManagementType.BEAN.name(), concurrencyTypeNode.asString());
            final List&lt;ModelNode&gt; dependsOnList = dependsOnNode.asList();
            assertEquals(1, dependsOnList.size());
            for (ModelNode d : dependsOnList) {
                if (!d.asString().equals(&quot;ManagedSingletonBean&quot;)) {
                    fail(&quot;Unknown value of depends-on: &quot; + d.asString());
                }
            }
        }
    }
    if (MESSAGE_DRIVEN.equals(type)) {
        assertEquals(&quot;jakarta.jms.MessageListener&quot;, resource.get(MESSAGING_TYPE).asString());
        if (componentClassName.equals(&quot;org.jboss.as.test.integration.ejb.management.deployments.NoTimerMDB&quot;)) {
            assertEquals(&quot;jakarta.jms.Queue&quot;, resource.get(MESSAGE_DESTINATION_TYPE).asString());
            assertEquals(&quot;queue/NoTimerMDB-queue&quot;, resource.get(MESSAGE_DESTINATION_LINK).asString());
        }
        final ModelNode activationConfigNode = resource.get(ACTIVATION_CONFIG);
        assertTrue(activationConfigNode.isDefined());
        final List&lt;Property&gt; activationConfigProps = activationConfigNode.asPropertyList();
        assertTrue(activationConfigProps.size() &gt;= 2);
        for (Property p : activationConfigProps) {
            final String pName = p.getName();
            final String pValue = p.getValue().asString();
            switch(pName) {
                case &quot;destinationType&quot;:
                    assertEquals(&quot;jakarta.jms.Queue&quot;, pValue);
                    break;
                case &quot;destination&quot;:
                    assertTrue(pValue.startsWith(&quot;java:/queue/&quot;));
                    break;
                case &quot;acknowledgeMode&quot;:
                    assertEquals(&quot;Auto-acknowledge&quot;, pValue);
                    break;
                default:
                    fail(&quot;Unknown activation config property: &quot; + pName);
                    break;
            }
        }
    } else {
        if (expectTimer) {
            final ModelNode asyncMethodsNode = resource.get(ASYNC_METHODS);
            final List&lt;ModelNode&gt; asyncMethodsList = asyncMethodsNode.asList();
            assertEquals(1, asyncMethodsList.size());
            for (ModelNode m : asyncMethodsList) {
                if (!m.asString().contains(&quot;void async(int, int)&quot;)) {
                    fail(&quot;Unknown async methods: &quot; + m.asString());
                }
            }
        }
        final ModelNode businessRemoteNode = resource.get(BUSINESS_REMOTE);
        final List&lt;ModelNode&gt; businessRemoteList = businessRemoteNode.asList();
        assertEquals(1, businessRemoteList.size());
        for (ModelNode r : businessRemoteList) {
            if (!r.asString().equals(&quot;org.jboss.as.test.integration.ejb.management.deployments.BusinessInterface&quot;)) {
                fail(&quot;Unknown business remote interface: &quot; + r.asString());
            }
        }
        final ModelNode businessLocalNode = resource.get(BUSINESS_LOCAL);
        final List&lt;ModelNode&gt; businessLocalList = businessLocalNode.asList();
        assertEquals(1, businessLocalList.size());
        for (ModelNode l : businessLocalList) {
            if (!l.asString().equals(componentClassName)) {
                fail(&quot;Unknown business local interface: &quot; + l.asString());
            }
        }
        final ModelNode jndiNamesNode = resource.get(JNDI_NAMES);
        final List&lt;ModelNode&gt; jndiNamesList = jndiNamesNode.asList();
        assertTrue(jndiNamesList.size() &gt;= 6);
        for (ModelNode j : jndiNamesList) {
            final String n = j.asString();
            if (!(n.startsWith(&quot;java:global/&quot;) || n.startsWith(&quot;java:app/&quot;) || n.startsWith(&quot;java:module/&quot;) || n.startsWith(&quot;ejb:/&quot;) || n.startsWith(&quot;java:jboss/&quot;))) {
                fail(&quot;Unknown jndi name for &quot; + name + &quot;: &quot; + n);
            }
        }
    }
}
</code></pre></div></td>
</tr>
<tr>
    <td>23</td><td>5453.27</td><td>28</td><td>140</td>
    <td><div class="code-container"><pre><code class="language-java">public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {
    final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();
    final DeploymentUnit parent = Utils.getRootDeploymentUnit(deploymentUnit);
    final ServiceTarget serviceTarget = phaseContext.getServiceTarget();
    final ResourceRoot deploymentRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT);
    if (!WeldDeploymentMarker.isPartOfWeldDeployment(deploymentUnit)) {
        if (deploymentUnit.getParent() == null &amp;&amp; CdiAnnotationMarker.cdiAnnotationsPresent(deploymentUnit)) {
            WeldLogger.DEPLOYMENT_LOGGER.cdiAnnotationsButNotBeanArchive(deploymentUnit.getName());
        }
        return;
    }
    final ServiceName weldBootstrapServiceName = parent.getServiceName().append(WeldBootstrapService.SERVICE_NAME);
    final ServiceName weldBootstrapServiceInternalName = parent.getServiceName().append(WeldBootstrapService.INTERNAL_SERVICE_NAME);
    ServiceName weldStartServiceName = parent.getServiceName().append(WeldStartService.SERVICE_NAME);
    deploymentUnit.addToAttachmentList(Attachments.WEB_DEPENDENCIES, weldStartServiceName);
    final Set&lt;ServiceName&gt; dependencies = new HashSet&lt;ServiceName&gt;();
    if (deploymentUnit.getParent() != null) {
        return;
    }
    WeldLogger.DEPLOYMENT_LOGGER.startingServicesForCDIDeployment(phaseContext.getDeploymentUnit().getName());
    final Module module = deploymentUnit.getAttachment(Attachments.MODULE);
    final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);
    final Set&lt;BeanDeploymentArchiveImpl&gt; beanDeploymentArchives = new HashSet&lt;BeanDeploymentArchiveImpl&gt;();
    final Map&lt;ModuleIdentifier, BeanDeploymentModule&gt; bdmsByIdentifier = new HashMap&lt;ModuleIdentifier, BeanDeploymentModule&gt;();
    final Map&lt;ModuleIdentifier, ModuleSpecification&gt; moduleSpecByIdentifier = new HashMap&lt;ModuleIdentifier, ModuleSpecification&gt;();
    final Map&lt;ModuleIdentifier, EEModuleDescriptor&gt; eeModuleDescriptors = new HashMap&lt;&gt;();
    final BeanDeploymentModule rootBeanDeploymentModule = deploymentUnit.getAttachment(WeldAttachments.BEAN_DEPLOYMENT_MODULE);
    putIfValueNotNull(eeModuleDescriptors, module.getIdentifier(), rootBeanDeploymentModule.getModuleDescriptor());
    bdmsByIdentifier.put(module.getIdentifier(), rootBeanDeploymentModule);
    moduleSpecByIdentifier.put(module.getIdentifier(), moduleSpecification);
    beanDeploymentArchives.addAll(rootBeanDeploymentModule.getBeanDeploymentArchives());
    final List&lt;DeploymentUnit&gt; subDeployments = deploymentUnit.getAttachmentList(Attachments.SUB_DEPLOYMENTS);
    final Set&lt;ClassLoader&gt; subDeploymentLoaders = new HashSet&lt;ClassLoader&gt;();
    final ServiceLoader&lt;DeploymentUnitDependenciesProvider&gt; dependenciesProviders = ServiceLoader.load(DeploymentUnitDependenciesProvider.class, WildFlySecurityManager.getClassLoaderPrivileged(WeldDeploymentProcessor.class));
    List&lt;ClassLoader&gt; loaders = new ArrayList&lt;&gt;(subDeployments.size() + 2);
    loaders.add(WildFlySecurityManager.getClassLoaderPrivileged(WeldDeploymentProcessor.class));
    loaders.add(module.getClassLoader());
    for (DeploymentUnit subDeployment : subDeployments) {
        loaders.add(subDeployment.getAttachment(Attachments.MODULE).getClassLoader());
    }
    Iterable&lt;ModuleServicesProvider&gt; moduleServicesProviders = ServiceLoader.load(ModuleServicesProvider.class, new CompositeClassLoader(loaders));
    getDependencies(deploymentUnit, dependencies, dependenciesProviders);
    for (DeploymentUnit subDeployment : subDeployments) {
        getDependencies(subDeployment, dependencies, dependenciesProviders);
        final Module subDeploymentModule = subDeployment.getAttachment(Attachments.MODULE);
        if (subDeploymentModule == null) {
            continue;
        }
        subDeploymentLoaders.add(subDeploymentModule.getClassLoader());
        final ModuleSpecification subDeploymentModuleSpec = subDeployment.getAttachment(Attachments.MODULE_SPECIFICATION);
        final BeanDeploymentModule bdm = subDeployment.getAttachment(WeldAttachments.BEAN_DEPLOYMENT_MODULE);
        if (bdm == null) {
            continue;
        }
        beanDeploymentArchives.addAll(bdm.getBeanDeploymentArchives());
        bdmsByIdentifier.put(subDeploymentModule.getIdentifier(), bdm);
        moduleSpecByIdentifier.put(subDeploymentModule.getIdentifier(), subDeploymentModuleSpec);
        putIfValueNotNull(eeModuleDescriptors, subDeploymentModule.getIdentifier(), bdm.getModuleDescriptor());
        final ResourceRoot subDeploymentRoot = subDeployment.getAttachment(Attachments.DEPLOYMENT_ROOT);
        for (Entry&lt;Class&lt;? extends Service&gt;, Service&gt; entry : ServiceLoaders.loadModuleServices(moduleServicesProviders, deploymentUnit, subDeployment, subDeploymentModule, subDeploymentRoot).entrySet()) {
            bdm.addService(entry.getKey(), Reflections.cast(entry.getValue()));
        }
    }
    for (Map.Entry&lt;ModuleIdentifier, BeanDeploymentModule&gt; entry : bdmsByIdentifier.entrySet()) {
        final ModuleSpecification bdmSpec = moduleSpecByIdentifier.get(entry.getKey());
        final BeanDeploymentModule bdm = entry.getValue();
        if (bdm == rootBeanDeploymentModule) {
            continue;
        }
        for (ModuleDependency dependency : bdmSpec.getSystemDependenciesSet()) {
            BeanDeploymentModule other = bdmsByIdentifier.get(dependency.getIdentifier());
            if (other != null &amp;&amp; other != bdm) {
                bdm.addBeanDeploymentModule(other);
            }
        }
    }
    Map&lt;Class&lt;? extends Service&gt;, Service&gt; rootModuleServices = ServiceLoaders.loadModuleServices(moduleServicesProviders, deploymentUnit, deploymentUnit, module, deploymentRoot);
    for (Entry&lt;Class&lt;? extends Service&gt;, Service&gt; entry : rootModuleServices.entrySet()) {
        rootBeanDeploymentModule.addService(entry.getKey(), Reflections.cast(entry.getValue()));
    }
    for (final BeanDeploymentArchiveImpl additional : deploymentUnit.getAttachmentList(WeldAttachments.ADDITIONAL_BEAN_DEPLOYMENT_MODULES)) {
        beanDeploymentArchives.add(additional);
        for (Entry&lt;Class&lt;? extends Service&gt;, Service&gt; entry : rootModuleServices.entrySet()) {
            additional.getServices().add(entry.getKey(), Reflections.cast(entry.getValue()));
        }
    }
    final Collection&lt;Metadata&lt;Extension&gt;&gt; extensions = WeldPortableExtensions.getPortableExtensions(deploymentUnit).getExtensions();
    final WeldDeployment deployment = new WeldDeployment(beanDeploymentArchives, extensions, module, subDeploymentLoaders, deploymentUnit, rootBeanDeploymentModule, eeModuleDescriptors);
    installBootstrapConfigurationService(deployment, parent);
    final ServiceBuilder&lt;?&gt; weldBootstrapServiceBuilder = serviceTarget.addService(weldBootstrapServiceInternalName);
    final Consumer&lt;WeldBootstrapService&gt; weldBootstrapServiceConsumer = weldBootstrapServiceBuilder.provides(weldBootstrapServiceInternalName);
    weldBootstrapServiceBuilder.requires(TCCLSingletonService.SERVICE_NAME);
    final Supplier&lt;ExecutorServices&gt; executorServicesSupplier = weldBootstrapServiceBuilder.requires(WeldExecutorServices.SERVICE_NAME);
    final Supplier&lt;ExecutorService&gt; serverExecutorSupplier = weldBootstrapServiceBuilder.requires(Services.JBOSS_SERVER_EXECUTOR);
    Supplier&lt;SecurityServices&gt; securityServicesSupplier = null;
    Supplier&lt;TransactionServices&gt; weldTransactionServicesSupplier = null;
    final ServiceLoader&lt;BootstrapDependencyInstaller&gt; installers = ServiceLoader.load(BootstrapDependencyInstaller.class, WildFlySecurityManager.getClassLoaderPrivileged(WeldDeploymentProcessor.class));
    for (BootstrapDependencyInstaller installer : installers) {
        ServiceName serviceName = installer.install(serviceTarget, deploymentUnit, jtsEnabled);
        if (serviceName == null) {
            continue;
        }
        if (ServiceNames.WELD_SECURITY_SERVICES_SERVICE_NAME.getSimpleName().equals(serviceName.getSimpleName())) {
            securityServicesSupplier = weldBootstrapServiceBuilder.requires(serviceName);
        } else if (ServiceNames.WELD_TRANSACTION_SERVICES_SERVICE_NAME.getSimpleName().equals(serviceName.getSimpleName())) {
            weldTransactionServicesSupplier = weldBootstrapServiceBuilder.requires(serviceName);
        }
    }
    ServiceName deploymentServiceName = Utils.getRootDeploymentUnit(deploymentUnit).getServiceName();
    final WeldBootstrapService weldBootstrapService = new WeldBootstrapService(deployment, WildFlyWeldEnvironment.INSTANCE, deploymentUnit.getName(), weldBootstrapServiceConsumer, executorServicesSupplier, serverExecutorSupplier, securityServicesSupplier, weldTransactionServicesSupplier, deploymentServiceName, weldBootstrapServiceName);
    for (Entry&lt;Class&lt;? extends Service&gt;, Service&gt; entry : rootModuleServices.entrySet()) {
        weldBootstrapService.addWeldService(entry.getKey(), Reflections.cast(entry.getValue()));
    }
    weldBootstrapServiceBuilder.setInstance(weldBootstrapService);
    weldBootstrapServiceBuilder.install();
    final List&lt;SetupAction&gt; setupActions = getSetupActions(deploymentUnit);
    ServiceBuilder&lt;?&gt; startService = serviceTarget.addService(weldStartServiceName);
    for (final ServiceName dependency : dependencies) {
        startService.requires(dependency);
    }
    startService.requires(JndiNamingDependencyProcessor.serviceName(deploymentUnit));
    final CapabilityServiceSupport capabilities = deploymentUnit.getAttachment(Attachments.CAPABILITY_SERVICE_SUPPORT);
    boolean tx = capabilities.hasCapability(&quot;org.wildfly.transactions&quot;);
    for (final ServiceName jndiSubsystemDependency : getJNDISubsytemDependencies(tx)) {
        startService.requires(jndiSubsystemDependency);
    }
    final EarMetaData earConfig = deploymentUnit.getAttachment(org.jboss.as.ee.structure.Attachments.EAR_METADATA);
    if (earConfig == null || !earConfig.getInitializeInOrder()) {
        for (DeploymentUnit sub : subDeployments) {
            startService.requires(JndiNamingDependencyProcessor.serviceName(sub));
        }
    }
    final Supplier&lt;WeldBootstrapService&gt; bootstrapSupplier = startService.requires(weldBootstrapServiceName);
    startService.setInstance(new WeldStartService(bootstrapSupplier, setupActions, module.getClassLoader(), deploymentServiceName));
    startService.install();
}
</code></pre></div></td>
</tr>
<tr>
    <td>24</td><td>3427.05</td><td>31</td><td>132</td>
    <td><div class="code-container"><pre><code class="language-java">public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {
    final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();
    if (!WeldDeploymentMarker.isPartOfWeldDeployment(deploymentUnit)) {
        return;
    }
    if (deploymentUnit.getParent() != null) {
        return;
    }
    final Set&lt;String&gt; componentClassNames = new HashSet&lt;&gt;();
    final ServiceLoader&lt;ComponentSupport&gt; supportServices = ServiceLoader.load(ComponentSupport.class, WildFlySecurityManager.getClassLoaderPrivileged(ExternalBeanArchiveProcessor.class));
    final String beanArchiveIdPrefix = deploymentUnit.getName() + &quot;.external.&quot;;
    final Set&lt;AnnotationType&gt; beanDefiningAnnotations = new HashSet&lt;&gt;(deploymentUnit.getAttachment(WeldAttachments.BEAN_DEFINING_ANNOTATIONS));
    List&lt;DeploymentUnit&gt; subDeployments = deploymentUnit.getAttachmentList(Attachments.SUB_DEPLOYMENTS);
    List&lt;DeploymentUnit&gt; deploymentUnits = new ArrayList&lt;&gt;(subDeployments.size() + 1);
    deploymentUnits.add(deploymentUnit);
    deploymentUnits.addAll(subDeployments);
    List&lt;ClassLoader&gt; loaders = new ArrayList&lt;&gt;(deploymentUnits.size() + 1);
    loaders.add(WildFlySecurityManager.getClassLoaderPrivileged(WeldDeploymentProcessor.class));
    for (DeploymentUnit unit : deploymentUnits) {
        loaders.add(unit.getAttachment(Attachments.MODULE).getClassLoader());
    }
    BeansXmlParser parser = new PropertyReplacingBeansXmlParser(deploymentUnit, Utils.getRootDeploymentUnit(deploymentUnit).getAttachment(WeldConfiguration.ATTACHMENT_KEY).isLegacyEmptyBeansXmlTreatment());
    final HashSet&lt;URL&gt; existing = new HashSet&lt;URL&gt;();
    final Set&lt;String&gt; depUnitNames = new HashSet&lt;&gt;();
    final String prefix = &quot;deployment.&quot;;
    for (DeploymentUnit deployment : deploymentUnits) {
        depUnitNames.add(prefix + deployment.getName());
        try {
            final ExplicitBeanArchiveMetadataContainer weldDeploymentMetadata = deployment.getAttachment(ExplicitBeanArchiveMetadataContainer.ATTACHMENT_KEY);
            if (weldDeploymentMetadata != null) {
                for (ExplicitBeanArchiveMetadata md : weldDeploymentMetadata.getBeanArchiveMetadata().values()) {
                    existing.add(md.getBeansXmlFile().toURL());
                    if (md.getAdditionalBeansXmlFile() != null) {
                        existing.add(md.getAdditionalBeansXmlFile().toURL());
                    }
                }
            }
        } catch (MalformedURLException e) {
            throw new DeploymentUnitProcessingException(e);
        }
        EEModuleDescription moduleDesc = deployment.getAttachment(org.jboss.as.ee.component.Attachments.EE_MODULE_DESCRIPTION);
        if (moduleDesc != null) {
            for (ComponentDescription component : moduleDesc.getComponentDescriptions()) {
                for (ComponentSupport support : supportServices) {
                    if (!support.isDiscoveredExternalType(component)) {
                        componentClassNames.add(component.getComponentClassName());
                        break;
                    }
                }
            }
        }
    }
    Iterable&lt;ModuleServicesProvider&gt; moduleServicesProviders = ServiceLoader.load(ModuleServicesProvider.class, new CompositeClassLoader(loaders));
    Map&lt;String, Map&lt;URL, URL&gt;&gt; exportedResourcesCache = new HashMap&lt;&gt;();
    for (DeploymentUnit deployment : deploymentUnits) {
        final Module module = deployment.getAttachment(Attachments.MODULE);
        if (module == null) {
            return;
        }
        for (DependencySpec dep : module.getDependencies()) {
            if (!(dep instanceof ModuleDependencySpec)) {
                continue;
            }
            if (depUnitNames.contains(((ModuleDependencySpec) dep).getName())) {
                continue;
            }
            final Module dependency = loadModuleDependency(dep);
            if (dependency == null) {
                continue;
            }
            Map&lt;URL, URL&gt; resourcesMap = findExportedResources(dependency, exportedResourcesCache);
            if (!resourcesMap.isEmpty()) {
                List&lt;BeanDeploymentArchiveImpl&gt; moduleBdas = new ArrayList&lt;&gt;();
                for (Entry&lt;URL, URL&gt; entry : resourcesMap.entrySet()) {
                    URL beansXmlUrl = entry.getKey();
                    if (existing.contains(beansXmlUrl)) {
                        continue;
                    }
                    if (beansXmlUrl.toString().contains(&quot;jsf-impl-2.2&quot;)) {
                        continue;
                    }
                    if (beansXmlUrl.toString().contains(&quot;resteasy-cdi&quot;)) {
                        continue;
                    }
                    if (!dep.getImportFilter().accept(&quot;META-INF&quot;)) {
                        continue;
                    }
                    WeldLogger.DEPLOYMENT_LOGGER.debugf(&quot;Found external beans.xml: %s&quot;, beansXmlUrl.toString());
                    final BeansXml beansXml = parseBeansXml(beansXmlUrl, parser, deploymentUnit);
                    if (BeanDiscoveryMode.NONE.equals(beansXml.getBeanDiscoveryMode())) {
                        continue;
                    }
                    Map&lt;String, List&lt;String&gt;&gt; allAndBeanClasses = discover(beansXml.getBeanDiscoveryMode(), beansXmlUrl, entry.getValue(), beanDefiningAnnotations);
                    Collection&lt;String&gt; discoveredBeanClasses = allAndBeanClasses.get(BEAN_CLASSES);
                    Collection&lt;String&gt; allKnownClasses = allAndBeanClasses.get(ALL_KNOWN_CLASSES);
                    if (discoveredBeanClasses == null) {
                        continue;
                    }
                    discoveredBeanClasses.removeAll(componentClassNames);
                    final BeanDeploymentArchiveImpl bda = new BeanDeploymentArchiveImpl(new HashSet&lt;String&gt;(discoveredBeanClasses), new HashSet&lt;String&gt;(allKnownClasses), beansXml, dependency, beanArchiveIdPrefix + beansXmlUrl.toExternalForm(), BeanArchiveType.EXTERNAL);
                    WeldLogger.DEPLOYMENT_LOGGER.beanArchiveDiscovered(bda);
                    for (Entry&lt;Class&lt;? extends Service&gt;, Service&gt; moduleService : ServiceLoaders.loadModuleServices(moduleServicesProviders, deploymentUnit, deployment, module, null).entrySet()) {
                        bda.getServices().add(moduleService.getKey(), Reflections.cast(moduleService.getValue()));
                    }
                    deploymentUnit.addToAttachmentList(WeldAttachments.ADDITIONAL_BEAN_DEPLOYMENT_MODULES, bda);
                    moduleBdas.add(bda);
                    existing.add(beansXmlUrl);
                }
                for (BeanDeploymentArchiveImpl i : moduleBdas) {
                    for (BeanDeploymentArchiveImpl j : moduleBdas) {
                        if (i != j) {
                            i.addBeanDeploymentArchive(j);
                        }
                    }
                }
            }
        }
    }
}
</code></pre></div></td>
</tr>
<tr>
    <td>25</td><td>1259.55</td><td>29</td><td>178</td>
    <td><div class="code-container"><pre><code class="language-java">public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {
    final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();
    if (deploymentUnit.getParent() != null) {
        return;
    }
    final Module module = deploymentUnit.getAttachment(org.jboss.as.server.deployment.Attachments.MODULE);
    if (module == null) {
        return;
    }
    CapabilityServiceSupport capabilityServiceSupport = deploymentUnit.getAttachment(org.jboss.as.server.deployment.Attachments.CAPABILITY_SERVICE_SUPPORT);
    final List&lt;EJBClientInterceptor&gt; deploymentEjbClientInterceptors = getClassPathInterceptors(module.getClassLoader());
    List&lt;EJBClientInterceptor&gt; staticEjbClientInterceptors = deploymentUnit.getAttachment(org.jboss.as.ejb3.subsystem.Attachments.STATIC_EJB_CLIENT_INTERCEPTORS);
    List&lt;EJBClientInterceptor&gt; ejbClientInterceptors = new ArrayList&lt;&gt;();
    if (deploymentEjbClientInterceptors != null) {
        ejbClientInterceptors.addAll(deploymentEjbClientInterceptors);
    }
    if (staticEjbClientInterceptors != null) {
        ejbClientInterceptors.addAll(staticEjbClientInterceptors);
    }
    final boolean interceptorsDefined = ejbClientInterceptors != null &amp;&amp; !ejbClientInterceptors.isEmpty();
    final EJBClientDescriptorMetaData ejbClientDescriptorMetaData = deploymentUnit.getAttachment(Attachments.EJB_CLIENT_METADATA);
    if (ejbClientDescriptorMetaData == null &amp;&amp; !interceptorsDefined) {
        return;
    }
    final ServiceName ejbClientContextServiceName = EJBClientContextService.DEPLOYMENT_BASE_SERVICE_NAME.append(deploymentUnit.getName());
    final ServiceTarget serviceTarget = phaseContext.getServiceTarget();
    final EJBClientContextService service = new EJBClientContextService();
    final ServiceBuilder&lt;EJBClientContextService&gt; serviceBuilder = serviceTarget.addService(ejbClientContextServiceName, service);
    if (appclient) {
        serviceBuilder.addDependency(EJBClientContextService.APP_CLIENT_URI_SERVICE_NAME, URI.class, service.getAppClientUri());
        serviceBuilder.addDependency(EJBClientContextService.APP_CLIENT_EJB_PROPERTIES_SERVICE_NAME, String.class, service.getAppClientEjbProperties());
    }
    serviceBuilder.addDependency(EJBClientConfiguratorService.SERVICE_NAME, EJBClientConfiguratorService.class, service.getConfiguratorServiceInjector());
    if (ejbClientDescriptorMetaData != null) {
        checkDescriptorConfiguration(ejbClientDescriptorMetaData);
        final Injector&lt;RemotingProfileService&gt; profileServiceInjector = new Injector&lt;RemotingProfileService&gt;() {

            final Injector&lt;EJBTransportProvider&gt; injector = service.getLocalProviderInjector();

            boolean injected = false;

            public void inject(final RemotingProfileService value) throws InjectionException {
                final Supplier&lt;EJBTransportProvider&gt; transportSupplier = value.getLocalTransportProviderSupplier();
                final EJBTransportProvider provider = transportSupplier != null ? transportSupplier.get() : null;
                if (provider != null) {
                    injected = true;
                    injector.inject(provider);
                }
            }

            public void uninject() {
                if (injected) {
                    injected = false;
                    injector.uninject();
                }
            }
        };
        final String profile = ejbClientDescriptorMetaData.getProfile();
        final ServiceName profileServiceName;
        if (profile != null) {
            profileServiceName = capabilityServiceSupport.getCapabilityServiceName(REMOTING_PROFILE_CAPABILITY_NAME, profile);
            serviceBuilder.addDependency(profileServiceName, RemotingProfileService.class, profileServiceInjector);
            serviceBuilder.addDependency(profileServiceName, RemotingProfileService.class, service.getProfileServiceInjector());
        } else {
            profileServiceName = ejbClientContextServiceName.append(INTERNAL_REMOTING_PROFILE);
            final Map&lt;String, RemotingProfileService.RemotingConnectionSpec&gt; remotingConnectionMap = new HashMap&lt;&gt;();
            final List&lt;RemotingProfileService.HttpConnectionSpec&gt; httpConnections = new ArrayList&lt;&gt;();
            final ServiceBuilder&lt;?&gt; profileServiceBuilder = serviceTarget.addService(profileServiceName);
            final Consumer&lt;RemotingProfileService&gt; consumer = profileServiceBuilder.provides(profileServiceName);
            Supplier&lt;EJBTransportProvider&gt; localTransportProviderSupplier = null;
            if (ejbClientDescriptorMetaData.isLocalReceiverExcluded() != Boolean.TRUE) {
                final Boolean passByValue = ejbClientDescriptorMetaData.isLocalReceiverPassByValue();
                localTransportProviderSupplier = profileServiceBuilder.requires(passByValue == Boolean.FALSE ? LocalTransportProvider.BY_REFERENCE_SERVICE_NAME : LocalTransportProvider.BY_VALUE_SERVICE_NAME);
            }
            final Collection&lt;EJBClientDescriptorMetaData.RemotingReceiverConfiguration&gt; receiverConfigurations = ejbClientDescriptorMetaData.getRemotingReceiverConfigurations();
            for (EJBClientDescriptorMetaData.RemotingReceiverConfiguration receiverConfiguration : receiverConfigurations) {
                final String connectionRef = receiverConfiguration.getOutboundConnectionRef();
                final long connectTimeout = receiverConfiguration.getConnectionTimeout();
                final Properties channelCreationOptions = receiverConfiguration.getChannelCreationOptions();
                final OptionMap optionMap = getOptionMapFromProperties(channelCreationOptions, EJBClientDescriptorMetaDataProcessor.class.getClassLoader());
                final ServiceName internalServiceName = capabilityServiceSupport.getCapabilityServiceName(OUTBOUND_CONNECTION_CAPABILITY_NAME, connectionRef);
                final Supplier&lt;OutboundConnection&gt; supplier = profileServiceBuilder.requires(internalServiceName);
                final RemotingProfileService.RemotingConnectionSpec connectionSpec = new RemotingProfileService.RemotingConnectionSpec(connectionRef, supplier, optionMap, connectTimeout);
                remotingConnectionMap.put(connectionRef, connectionSpec);
            }
            for (EJBClientDescriptorMetaData.HttpConnectionConfiguration httpConfigurations : ejbClientDescriptorMetaData.getHttpConnectionConfigurations()) {
                final String uri = httpConfigurations.getUri();
                RemotingProfileService.HttpConnectionSpec httpConnectionSpec = new RemotingProfileService.HttpConnectionSpec(uri);
                httpConnections.add(httpConnectionSpec);
            }
            final RemotingProfileService profileService = new RemotingProfileService(consumer, localTransportProviderSupplier, Collections.emptyList(), remotingConnectionMap, httpConnections);
            profileServiceBuilder.setInstance(profileService);
            profileServiceBuilder.install();
            serviceBuilder.addDependency(profileServiceName, RemotingProfileService.class, profileServiceInjector);
            serviceBuilder.addDependency(profileServiceName, RemotingProfileService.class, service.getProfileServiceInjector());
        }
        final String deploymentNodeSelectorClassName = ejbClientDescriptorMetaData.getDeploymentNodeSelector();
        if (deploymentNodeSelectorClassName != null) {
            final DeploymentNodeSelector deploymentNodeSelector;
            try {
                deploymentNodeSelector = module.getClassLoader().loadClass(deploymentNodeSelectorClassName).asSubclass(DeploymentNodeSelector.class).getConstructor().newInstance();
            } catch (Exception e) {
                throw EjbLogger.ROOT_LOGGER.failedToCreateDeploymentNodeSelector(e, deploymentNodeSelectorClassName);
            }
            service.setDeploymentNodeSelector(deploymentNodeSelector);
        }
        final long invocationTimeout = ejbClientDescriptorMetaData.getInvocationTimeout();
        service.setInvocationTimeout(invocationTimeout);
        final int defaultCompression = ejbClientDescriptorMetaData.getDefaultCompression();
        service.setDefaultCompression(defaultCompression);
        final Collection&lt;EJBClientDescriptorMetaData.ClusterConfig&gt; clusterConfigs = ejbClientDescriptorMetaData.getClusterConfigs();
        if (!clusterConfigs.isEmpty()) {
            final List&lt;EJBClientCluster&gt; clientClusters = new ArrayList&lt;&gt;(clusterConfigs.size());
            AuthenticationContext clustersAuthenticationContext = AuthenticationContext.empty();
            for (EJBClientDescriptorMetaData.ClusterConfig clusterConfig : clusterConfigs) {
                MatchRule defaultRule = MatchRule.ALL.matchAbstractType(&quot;ejb&quot;, &quot;jboss&quot;);
                AuthenticationConfiguration defaultAuthenticationConfiguration = AuthenticationConfiguration.empty();
                final EJBClientCluster.Builder clientClusterBuilder = new EJBClientCluster.Builder();
                final String clusterName = clusterConfig.getClusterName();
                clientClusterBuilder.setName(clusterName);
                defaultRule = defaultRule.matchProtocol(&quot;cluster&quot;);
                defaultRule = defaultRule.matchUrnName(clusterName);
                final long maxAllowedConnectedNodes = clusterConfig.getMaxAllowedConnectedNodes();
                clientClusterBuilder.setMaximumConnectedNodes(maxAllowedConnectedNodes);
                final String clusterNodeSelectorClassName = clusterConfig.getNodeSelector();
                if (clusterNodeSelectorClassName != null) {
                    final ClusterNodeSelector clusterNodeSelector;
                    try {
                        clusterNodeSelector = module.getClassLoader().loadClass(clusterNodeSelectorClassName).asSubclass(ClusterNodeSelector.class).getConstructor().newInstance();
                    } catch (Exception e) {
                        throw EjbLogger.ROOT_LOGGER.failureDuringLoadOfClusterNodeSelector(clusterNodeSelectorClassName, clusterName, e);
                    }
                    clientClusterBuilder.setClusterNodeSelector(clusterNodeSelector);
                }
                final Properties clusterChannelCreationOptions = clusterConfig.getChannelCreationOptions();
                final OptionMap clusterChannelCreationOptionMap = getOptionMapFromProperties(clusterChannelCreationOptions, EJBClientDescriptorMetaDataProcessor.class.getClassLoader());
                final Properties clusterConnectionOptions = clusterConfig.getConnectionOptions();
                final OptionMap clusterConnectionOptionMap = getOptionMapFromProperties(clusterConnectionOptions, EJBClientDescriptorMetaDataProcessor.class.getClassLoader());
                final long clusterConnectTimeout = clusterConfig.getConnectTimeout();
                clientClusterBuilder.setConnectTimeoutMilliseconds(clusterConnectTimeout);
                if (clusterConnectionOptionMap != null) {
                    RemotingOptions.mergeOptionsIntoAuthenticationConfiguration(clusterConnectionOptionMap, defaultAuthenticationConfiguration);
                }
                clustersAuthenticationContext = clustersAuthenticationContext.with(defaultRule, defaultAuthenticationConfiguration);
                final Collection&lt;EJBClientDescriptorMetaData.ClusterNodeConfig&gt; clusterNodeConfigs = clusterConfig.getClusterNodeConfigs();
                for (EJBClientDescriptorMetaData.ClusterNodeConfig clusterNodeConfig : clusterNodeConfigs) {
                    MatchRule nodeRule = MatchRule.ALL.matchAbstractType(&quot;ejb&quot;, &quot;jboss&quot;);
                    AuthenticationConfiguration nodeAuthenticationConfiguration = AuthenticationConfiguration.empty();
                    final String nodeName = clusterNodeConfig.getNodeName();
                    nodeRule = nodeRule.matchProtocol(&quot;node&quot;);
                    nodeRule = nodeRule.matchUrnName(nodeName);
                    final Properties channelCreationOptions = clusterNodeConfig.getChannelCreationOptions();
                    final Properties connectionOptions = clusterNodeConfig.getConnectionOptions();
                    final OptionMap connectionOptionMap = getOptionMapFromProperties(connectionOptions, EJBClientDescriptorMetaDataProcessor.class.getClassLoader());
                    final long connectTimeout = clusterNodeConfig.getConnectTimeout();
                    if (connectionOptionMap != null) {
                        RemotingOptions.mergeOptionsIntoAuthenticationConfiguration(connectionOptionMap, nodeAuthenticationConfiguration);
                    }
                    clustersAuthenticationContext = clustersAuthenticationContext.with(0, nodeRule, nodeAuthenticationConfiguration);
                }
                final EJBClientCluster clientCluster = clientClusterBuilder.build();
                clientClusters.add(clientCluster);
            }
            service.setClientClusters(clientClusters);
            service.setClustersAuthenticationContext(clustersAuthenticationContext);
        }
        deploymentUnit.putAttachment(EjbDeploymentAttachmentKeys.EJB_REMOTING_PROFILE_SERVICE_NAME, profileServiceName);
    } else {
        if (!appclient) {
            serviceBuilder.addDependency(LocalTransportProvider.DEFAULT_LOCAL_TRANSPORT_PROVIDER_SERVICE_NAME, EJBTransportProvider.class, service.getLocalProviderInjector());
        }
    }
    if (interceptorsDefined) {
        service.setClientInterceptors(ejbClientInterceptors);
    }
    serviceBuilder.install();
    EjbLogger.DEPLOYMENT_LOGGER.debugf(&quot;Deployment unit %s will use %s as the EJB client context service&quot;, deploymentUnit, ejbClientContextServiceName);
    phaseContext.addDeploymentDependency(ejbClientContextServiceName, EjbDeploymentAttachmentKeys.EJB_CLIENT_CONTEXT_SERVICE);
    deploymentUnit.putAttachment(EjbDeploymentAttachmentKeys.EJB_CLIENT_CONTEXT_SERVICE_NAME, ejbClientContextServiceName);
}
</code></pre></div></td>
</tr>
<tr>
    <td>26</td><td>3165.61</td><td>30</td><td>111</td>
    <td><div class="code-container"><pre><code class="language-java">public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {
    final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();
    final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);
    final ServiceModuleLoader loader = deploymentUnit.getAttachment(Attachments.SERVICE_MODULE_LOADER);
    if (!DeploymentTypeMarker.isType(DeploymentType.WAR, deploymentUnit)) {
        return;
    }
    WarMetaData warMetaData = deploymentUnit.getAttachment(WarMetaData.ATTACHMENT_KEY);
    assert warMetaData != null;
    final Module module = deploymentUnit.getAttachment(Attachments.MODULE);
    if (module == null) {
        throw UndertowLogger.ROOT_LOGGER.failedToResolveModule(deploymentUnit);
    }
    final ClassLoader classLoader = module.getClassLoader();
    ScisMetaData scisMetaData = deploymentUnit.getAttachment(ScisMetaData.ATTACHMENT_KEY);
    if (scisMetaData == null) {
        scisMetaData = new ScisMetaData();
        deploymentUnit.putAttachment(ScisMetaData.ATTACHMENT_KEY, scisMetaData);
    }
    Set&lt;ServletContainerInitializer&gt; scis = scisMetaData.getScis();
    Set&lt;Class&lt;? extends ServletContainerInitializer&gt;&gt; sciClasses = new HashSet&lt;&gt;();
    if (scis == null) {
        scis = new LinkedHashSet&lt;&gt;();
        scisMetaData.setScis(scis);
    }
    Map&lt;ServletContainerInitializer, Set&lt;Class&lt;?&gt;&gt;&gt; handlesTypes = scisMetaData.getHandlesTypes();
    if (handlesTypes == null) {
        handlesTypes = new HashMap&lt;ServletContainerInitializer, Set&lt;Class&lt;?&gt;&gt;&gt;();
        scisMetaData.setHandlesTypes(handlesTypes);
    }
    for (ModuleDependency dependency : moduleSpecification.getAllDependencies()) {
        if (!dependency.isImportServices()) {
            continue;
        }
        try {
            Module depModule = loader.loadModule(dependency.getIdentifier());
            ServiceLoader&lt;ServletContainerInitializer&gt; serviceLoader = depModule.loadService(ServletContainerInitializer.class);
            for (ServletContainerInitializer service : serviceLoader) {
                if (sciClasses.add(service.getClass())) {
                    scis.add(service);
                }
            }
        } catch (ModuleLoadException e) {
            if (!dependency.isOptional()) {
                throw UndertowLogger.ROOT_LOGGER.errorLoadingSCIFromModule(dependency.getIdentifier().toString(), e);
            }
        }
    }
    List&lt;String&gt; order = warMetaData.getOrder();
    Map&lt;String, VirtualFile&gt; localScis = warMetaData.getScis();
    if (order != null &amp;&amp; localScis != null) {
        for (String jar : order) {
            VirtualFile sci = localScis.get(jar);
            if (sci != null) {
                scis.addAll(loadSci(classLoader, sci, jar, true, sciClasses));
            }
        }
    }
    if (localScis != null) {
        VirtualFile warDeployedScis = localScis.get(&quot;classes&quot;);
        if (warDeployedScis != null) {
            scis.addAll(loadSci(classLoader, warDeployedScis, deploymentUnit.getName(), true, sciClasses));
        }
    }
    Map&lt;Class&lt;?&gt;, Set&lt;ServletContainerInitializer&gt;&gt; typesMap = new HashMap&lt;Class&lt;?&gt;, Set&lt;ServletContainerInitializer&gt;&gt;();
    for (ServletContainerInitializer service : scis) {
        try {
            if (service.getClass().isAnnotationPresent(HandlesTypes.class)) {
                HandlesTypes handlesTypesAnnotation = service.getClass().getAnnotation(HandlesTypes.class);
                Class&lt;?&gt;[] typesArray = handlesTypesAnnotation.value();
                if (typesArray != null) {
                    for (Class&lt;?&gt; type : typesArray) {
                        Set&lt;ServletContainerInitializer&gt; servicesSet = typesMap.get(type);
                        if (servicesSet == null) {
                            servicesSet = new HashSet&lt;ServletContainerInitializer&gt;();
                            typesMap.put(type, servicesSet);
                        }
                        servicesSet.add(service);
                        handlesTypes.put(service, new HashSet&lt;Class&lt;?&gt;&gt;());
                    }
                }
            }
        } catch (ArrayStoreException e) {
            throw UndertowLogger.ROOT_LOGGER.missingClassInAnnotation(HandlesTypes.class.getSimpleName(), service.getClass().getName());
        }
    }
    Class&lt;?&gt;[] typesArray = typesMap.keySet().toArray(new Class&lt;?&gt;[0]);
    final CompositeIndex index = deploymentUnit.getAttachment(Attachments.COMPOSITE_ANNOTATION_INDEX);
    if (index == null) {
        throw UndertowLogger.ROOT_LOGGER.unableToResolveAnnotationIndex(deploymentUnit);
    }
    final CompositeIndex parent;
    if (deploymentUnit.getParent() != null) {
        parent = deploymentUnit.getParent().getAttachment(Attachments.COMPOSITE_ANNOTATION_INDEX);
    } else {
        parent = null;
    }
    CompositeIndex parentIndex = deploymentUnit.getParent() == null ? null : deploymentUnit.getParent().getAttachment(Attachments.COMPOSITE_ANNOTATION_INDEX);
    for (Class&lt;?&gt; type : typesArray) {
        DotName className = DotName.createSimple(type.getName());
        Set&lt;ClassInfo&gt; classInfos = new HashSet&lt;&gt;();
        classInfos.addAll(processHandlesType(className, type, index, parent));
        if (parentIndex != null) {
            classInfos.addAll(processHandlesType(className, type, parentIndex, parent));
        }
        Set&lt;Class&lt;?&gt;&gt; classes = loadClassInfoSet(classInfos, classLoader);
        Set&lt;ServletContainerInitializer&gt; sciSet = typesMap.get(type);
        for (ServletContainerInitializer sci : sciSet) {
            handlesTypes.get(sci).addAll(classes);
        }
    }
}
</code></pre></div></td>
</tr>
<tr>
    <td>27</td><td>3699.78</td><td>1</td><td>155</td>
    <td><div class="code-container"><pre><code class="language-java">public void testSingletonService(@ArquillianResource(NodeServiceServlet.class) @OperateOnDeployment(DEPLOYMENT_1) URL baseURL1, @ArquillianResource(NodeServiceServlet.class) @OperateOnDeployment(DEPLOYMENT_2) URL baseURL2) throws IOException, URISyntaxException {
    stop(NODE_2);
    try (CloseableHttpClient client = TestHttpClientUtils.promiscuousCookieHttpClient()) {
        HttpResponse response = client.execute(new HttpGet(NodeServiceServlet.createURI(baseURL1, NodeServiceActivator.DEFAULT_SERVICE_NAME, NODE_1)));
        try {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertTrue(response.containsHeader(NodeServiceServlet.NODE_HEADER));
            Assert.assertEquals(NODE_1, response.getFirstHeader(NodeServiceServlet.NODE_HEADER).getValue());
        } finally {
            HttpClientUtils.closeQuietly(response);
        }
        response = client.execute(new HttpGet(NodeServiceServlet.createURI(baseURL1, NodeServiceActivator.QUORUM_SERVICE_NAME)));
        try {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertFalse(response.containsHeader(NodeServiceServlet.NODE_HEADER));
        } finally {
            HttpClientUtils.closeQuietly(response);
        }
        start(NODE_2);
        response = client.execute(new HttpGet(NodeServiceServlet.createURI(baseURL1, NodeServiceActivator.DEFAULT_SERVICE_NAME, NODE_1)));
        try {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertTrue(response.containsHeader(NodeServiceServlet.NODE_HEADER));
            Assert.assertEquals(NODE_2, response.getFirstHeader(NodeServiceServlet.NODE_HEADER).getValue());
        } finally {
            HttpClientUtils.closeQuietly(response);
        }
        response = client.execute(new HttpGet(NodeServiceServlet.createURI(baseURL1, NodeServiceActivator.QUORUM_SERVICE_NAME, NODE_2)));
        try {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertTrue(response.containsHeader(NodeServiceServlet.NODE_HEADER));
            Assert.assertEquals(NODE_2, response.getFirstHeader(NodeServiceServlet.NODE_HEADER).getValue());
        } finally {
            HttpClientUtils.closeQuietly(response);
        }
        response = client.execute(new HttpGet(NodeServiceServlet.createURI(baseURL2, NodeServiceActivator.DEFAULT_SERVICE_NAME, NODE_2)));
        try {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertTrue(response.containsHeader(NodeServiceServlet.NODE_HEADER));
            Assert.assertEquals(NODE_2, response.getFirstHeader(NodeServiceServlet.NODE_HEADER).getValue());
        } finally {
            HttpClientUtils.closeQuietly(response);
        }
        response = client.execute(new HttpGet(NodeServiceServlet.createURI(baseURL2, NodeServiceActivator.QUORUM_SERVICE_NAME, NODE_2)));
        try {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertTrue(response.containsHeader(NodeServiceServlet.NODE_HEADER));
            Assert.assertEquals(NODE_2, response.getFirstHeader(NodeServiceServlet.NODE_HEADER).getValue());
        } finally {
            HttpClientUtils.closeQuietly(response);
        }
        stop(NODE_2);
        response = client.execute(new HttpGet(NodeServiceServlet.createURI(baseURL1, NodeServiceActivator.DEFAULT_SERVICE_NAME, NODE_1)));
        try {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertTrue(response.containsHeader(NodeServiceServlet.NODE_HEADER));
            Assert.assertEquals(NODE_1, response.getFirstHeader(NodeServiceServlet.NODE_HEADER).getValue());
        } finally {
            HttpClientUtils.closeQuietly(response);
        }
        response = client.execute(new HttpGet(NodeServiceServlet.createURI(baseURL1, NodeServiceActivator.QUORUM_SERVICE_NAME)));
        try {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertFalse(response.containsHeader(NodeServiceServlet.NODE_HEADER));
        } finally {
            HttpClientUtils.closeQuietly(response);
        }
        start(NODE_2);
        response = client.execute(new HttpGet(NodeServiceServlet.createURI(baseURL1, NodeServiceActivator.DEFAULT_SERVICE_NAME, NODE_2)));
        try {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertTrue(response.containsHeader(NodeServiceServlet.NODE_HEADER));
            Assert.assertEquals(NODE_2, response.getFirstHeader(NodeServiceServlet.NODE_HEADER).getValue());
        } finally {
            HttpClientUtils.closeQuietly(response);
        }
        response = client.execute(new HttpGet(NodeServiceServlet.createURI(baseURL1, NodeServiceActivator.QUORUM_SERVICE_NAME, NODE_2)));
        try {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertTrue(response.containsHeader(NodeServiceServlet.NODE_HEADER));
            Assert.assertEquals(NODE_2, response.getFirstHeader(NodeServiceServlet.NODE_HEADER).getValue());
        } finally {
            HttpClientUtils.closeQuietly(response);
        }
        response = client.execute(new HttpGet(NodeServiceServlet.createURI(baseURL2, NodeServiceActivator.DEFAULT_SERVICE_NAME, NODE_2)));
        try {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertTrue(response.containsHeader(NodeServiceServlet.NODE_HEADER));
            Assert.assertEquals(NODE_2, response.getFirstHeader(NodeServiceServlet.NODE_HEADER).getValue());
        } finally {
            HttpClientUtils.closeQuietly(response);
        }
        response = client.execute(new HttpGet(NodeServiceServlet.createURI(baseURL2, NodeServiceActivator.QUORUM_SERVICE_NAME, NODE_2)));
        try {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertTrue(response.containsHeader(NodeServiceServlet.NODE_HEADER));
            Assert.assertEquals(NODE_2, response.getFirstHeader(NodeServiceServlet.NODE_HEADER).getValue());
        } finally {
            HttpClientUtils.closeQuietly(response);
        }
        stop(NODE_1);
        response = client.execute(new HttpGet(NodeServiceServlet.createURI(baseURL2, NodeServiceActivator.DEFAULT_SERVICE_NAME, NODE_2)));
        try {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertTrue(response.containsHeader(NodeServiceServlet.NODE_HEADER));
            Assert.assertEquals(NODE_2, response.getFirstHeader(NodeServiceServlet.NODE_HEADER).getValue());
        } finally {
            HttpClientUtils.closeQuietly(response);
        }
        response = client.execute(new HttpGet(NodeServiceServlet.createURI(baseURL2, NodeServiceActivator.QUORUM_SERVICE_NAME)));
        try {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertFalse(response.containsHeader(NodeServiceServlet.NODE_HEADER));
        } finally {
            HttpClientUtils.closeQuietly(response);
        }
        start(NODE_1);
        response = client.execute(new HttpGet(NodeServiceServlet.createURI(baseURL1, NodeServiceActivator.DEFAULT_SERVICE_NAME, NODE_2)));
        try {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertTrue(response.containsHeader(NodeServiceServlet.NODE_HEADER));
            Assert.assertEquals(NODE_2, response.getFirstHeader(NodeServiceServlet.NODE_HEADER).getValue());
        } finally {
            HttpClientUtils.closeQuietly(response);
        }
        response = client.execute(new HttpGet(NodeServiceServlet.createURI(baseURL1, NodeServiceActivator.QUORUM_SERVICE_NAME, NODE_2)));
        try {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertTrue(response.containsHeader(NodeServiceServlet.NODE_HEADER));
            Assert.assertEquals(NODE_2, response.getFirstHeader(NodeServiceServlet.NODE_HEADER).getValue());
        } finally {
            HttpClientUtils.closeQuietly(response);
        }
        response = client.execute(new HttpGet(NodeServiceServlet.createURI(baseURL2, NodeServiceActivator.DEFAULT_SERVICE_NAME, NODE_2)));
        try {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertTrue(response.containsHeader(NodeServiceServlet.NODE_HEADER));
            Assert.assertEquals(NODE_2, response.getFirstHeader(NodeServiceServlet.NODE_HEADER).getValue());
        } finally {
            HttpClientUtils.closeQuietly(response);
        }
        response = client.execute(new HttpGet(NodeServiceServlet.createURI(baseURL2, NodeServiceActivator.QUORUM_SERVICE_NAME, NODE_2)));
        try {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
            Assert.assertTrue(response.containsHeader(NodeServiceServlet.NODE_HEADER));
            Assert.assertEquals(NODE_2, response.getFirstHeader(NodeServiceServlet.NODE_HEADER).getValue());
        } finally {
            HttpClientUtils.closeQuietly(response);
        }
    }
}
</code></pre></div></td>
</tr>
<tr>
    <td>28</td><td>2808.32</td><td>26</td><td>98</td>
    <td><div class="code-container"><pre><code class="language-java">protected void processAnnotation(final DeploymentUnit unit, final EEModuleDescription moduleDescription) throws DeploymentUnitProcessingException {
    if (!DeploymentTypeMarker.isType(DeploymentType.WAR, unit)) {
        return;
    }
    final Map&lt;String, EEModuleClassDescription&gt; classDescriptionMap = new HashMap&lt;String, org.jboss.as.ee.component.EEModuleClassDescription&gt;();
    final CompositeIndex index = unit.getAttachment(Attachments.COMPOSITE_ANNOTATION_INDEX);
    for (EEModuleClassDescription classDescritpion : moduleDescription.getClassDescriptions()) {
        if (isJaxwsEndpoint(classDescritpion, index) &amp;&amp; !exclude(unit, classDescritpion)) {
            classDescriptionMap.put(classDescritpion.getClassName(), classDescritpion);
        }
    }
    final JBossWebMetaData jbossWebMD = getJBossWebMetaData(unit);
    final JAXWSDeployment jaxwsDeployment = getJaxwsDeployment(unit);
    if (jbossWebMD != null) {
        final Set&lt;String&gt; matchedEps = new HashSet&lt;String&gt;();
        for (final ServletMetaData servletMD : getServlets(jbossWebMD)) {
            final String endpointClassName = getEndpointClassName(servletMD);
            final String endpointName = getEndpointName(servletMD);
            if (classDescriptionMap.containsKey(endpointClassName) || matchedEps.contains(endpointClassName)) {
                final ComponentDescription pojoComponent = createComponentDescription(unit, endpointName, endpointClassName, endpointName);
                final ServiceName pojoViewName = registerView(pojoComponent, endpointClassName);
                final String urlPattern = getUrlPattern(endpointName, unit);
                jaxwsDeployment.addEndpoint(new POJOEndpoint(endpointName, endpointClassName, pojoViewName, urlPattern));
                classDescriptionMap.remove(endpointClassName);
                matchedEps.add(endpointClassName);
            } else {
                if (unit.getParent() != null &amp;&amp; DeploymentTypeMarker.isType(DeploymentType.EAR, unit.getParent())) {
                    final EEModuleDescription eeModuleDescription = unit.getParent().getAttachment(org.jboss.as.ee.component.Attachments.EE_MODULE_DESCRIPTION);
                    final CompositeIndex parentIndex = unit.getParent().getAttachment(Attachments.COMPOSITE_ANNOTATION_INDEX);
                    for (EEModuleClassDescription classDescription : eeModuleDescription.getClassDescriptions()) {
                        if (classDescription.getClassName().equals(endpointClassName) &amp;&amp; isJaxwsEndpoint(classDescription, parentIndex)) {
                            final ComponentDescription pojoComponent = createComponentDescription(unit, endpointName, endpointClassName, endpointName);
                            final ServiceName pojoViewName = registerView(pojoComponent, endpointClassName);
                            final String urlPattern = getUrlPattern(endpointName, unit);
                            jaxwsDeployment.addEndpoint(new POJOEndpoint(endpointName, endpointClassName, pojoViewName, urlPattern));
                        }
                    }
                }
            }
        }
    }
    for (EEModuleClassDescription classDescription : classDescriptionMap.values()) {
        ClassInfo classInfo = null;
        String serviceName = null;
        String urlPattern = null;
        EJBEndpoint ejbEndpoint = getWebserviceMetadataEJBEndpoint(jaxwsDeployment, classDescription.getClassName());
        if (ejbEndpoint != null) {
            urlPattern = UrlPatternUtils.getUrlPatternByPortComponentURI(getJBossWebserviceMetaDataPortComponent(unit, ejbEndpoint.getName()));
        }
        if (urlPattern == null) {
            final ClassAnnotationInformation&lt;WebContext, WebContextAnnotationInfo&gt; annotationWebContext = classDescription.getAnnotationInformation(WebContext.class);
            if (annotationWebContext != null) {
                WebContextAnnotationInfo wsInfo = annotationWebContext.getClassLevelAnnotations().get(0);
                if (wsInfo != null &amp;&amp; wsInfo.getUrlPattern().length() &gt; 0) {
                    urlPattern = wsInfo.getUrlPattern();
                }
            }
        }
        if (urlPattern == null) {
            final ClassAnnotationInformation&lt;WebService, WebServiceAnnotationInfo&gt; annotationInfo = classDescription.getAnnotationInformation(WebService.class);
            if (annotationInfo != null) {
                WebServiceAnnotationInfo wsInfo = annotationInfo.getClassLevelAnnotations().get(0);
                serviceName = wsInfo.getServiceName();
                classInfo = (ClassInfo) wsInfo.getTarget();
                urlPattern = UrlPatternUtils.getUrlPattern(classInfo.name().local(), serviceName);
                if (jaxwsDeployment.contains(urlPattern)) {
                    urlPattern = UrlPatternUtils.getUrlPattern(classInfo.name().local(), serviceName, wsInfo.getName());
                }
            }
            final ClassAnnotationInformation&lt;WebServiceProvider, WebServiceProviderAnnotationInfo&gt; annotationProviderInfo = classDescription.getAnnotationInformation(WebServiceProvider.class);
            if (annotationProviderInfo != null) {
                WebServiceProviderAnnotationInfo wsInfo = annotationProviderInfo.getClassLevelAnnotations().get(0);
                serviceName = wsInfo.getServiceName();
                classInfo = (ClassInfo) wsInfo.getTarget();
            }
        }
        if (classInfo != null) {
            final String endpointClassName = classDescription.getClassName();
            final ComponentDescription pojoComponent = createComponentDescription(unit, endpointClassName, endpointClassName, endpointClassName);
            final ServiceName pojoViewName = registerView(pojoComponent, endpointClassName);
            if (urlPattern == null) {
                urlPattern = UrlPatternUtils.getUrlPattern(classInfo.name().local(), serviceName);
            }
            jaxwsDeployment.addEndpoint(new POJOEndpoint(endpointClassName, pojoViewName, UrlPatternUtils.getUrlPattern(urlPattern)));
        }
    }
}
</code></pre></div></td>
</tr>
<tr>
    <td>29</td><td>2765.58</td><td>29</td><td>92</td>
    <td><div class="code-container"><pre><code class="language-java">public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {
    context.startSubsystemElement(Namespace.CURRENT.getUriString(), false);
    ModelNode node = context.getModelNode();
    writer.writeStartElement(Element.CORE_ENVIRONMENT.getLocalName());
    TransactionSubsystemRootResourceDefinition.NODE_IDENTIFIER.marshallAsAttribute(node, writer);
    writeProcessId(writer, node);
    writer.writeEndElement();
    if (TransactionSubsystemRootResourceDefinition.BINDING.isMarshallable(node) || TransactionSubsystemRootResourceDefinition.STATUS_BINDING.isMarshallable(node) || TransactionSubsystemRootResourceDefinition.RECOVERY_LISTENER.isMarshallable(node)) {
        writer.writeStartElement(Element.RECOVERY_ENVIRONMENT.getLocalName());
        TransactionSubsystemRootResourceDefinition.BINDING.marshallAsAttribute(node, writer);
        TransactionSubsystemRootResourceDefinition.STATUS_BINDING.marshallAsAttribute(node, writer);
        TransactionSubsystemRootResourceDefinition.RECOVERY_LISTENER.marshallAsAttribute(node, writer);
        writer.writeEndElement();
    }
    if (TransactionSubsystemRootResourceDefinition.STATISTICS_ENABLED.isMarshallable(node) || TransactionSubsystemRootResourceDefinition.ENABLE_TSM_STATUS.isMarshallable(node) || TransactionSubsystemRootResourceDefinition.DEFAULT_TIMEOUT.isMarshallable(node) || TransactionSubsystemRootResourceDefinition.MAXIMUM_TIMEOUT.isMarshallable(node)) {
        writer.writeStartElement(Element.COORDINATOR_ENVIRONMENT.getLocalName());
        TransactionSubsystemRootResourceDefinition.STATISTICS_ENABLED.marshallAsAttribute(node, writer);
        TransactionSubsystemRootResourceDefinition.ENABLE_TSM_STATUS.marshallAsAttribute(node, writer);
        TransactionSubsystemRootResourceDefinition.DEFAULT_TIMEOUT.marshallAsAttribute(node, writer);
        TransactionSubsystemRootResourceDefinition.MAXIMUM_TIMEOUT.marshallAsAttribute(node, writer);
        writer.writeEndElement();
    }
    if (TransactionSubsystemRootResourceDefinition.OBJECT_STORE_RELATIVE_TO.isMarshallable(node) || TransactionSubsystemRootResourceDefinition.OBJECT_STORE_PATH.isMarshallable(node)) {
        writer.writeStartElement(Element.OBJECT_STORE.getLocalName());
        TransactionSubsystemRootResourceDefinition.OBJECT_STORE_PATH.marshallAsAttribute(node, writer);
        TransactionSubsystemRootResourceDefinition.OBJECT_STORE_RELATIVE_TO.marshallAsAttribute(node, writer);
        writer.writeEndElement();
    }
    if (node.hasDefined(CommonAttributes.JTS) &amp;&amp; node.get(CommonAttributes.JTS).asBoolean()) {
        writer.writeStartElement(Element.JTS.getLocalName());
        writer.writeEndElement();
    }
    if (node.hasDefined(CommonAttributes.USE_JOURNAL_STORE) &amp;&amp; node.get(CommonAttributes.USE_JOURNAL_STORE).asBoolean()) {
        writer.writeStartElement(Element.USE_JOURNAL_STORE.getLocalName());
        TransactionSubsystemRootResourceDefinition.JOURNAL_STORE_ENABLE_ASYNC_IO.marshallAsAttribute(node, writer);
        writer.writeEndElement();
    }
    if (node.hasDefined(CommonAttributes.USE_JDBC_STORE) &amp;&amp; node.get(CommonAttributes.USE_JDBC_STORE).asBoolean()) {
        writer.writeStartElement(Element.JDBC_STORE.getLocalName());
        TransactionSubsystemRootResourceDefinition.JDBC_STORE_DATASOURCE.marshallAsAttribute(node, writer);
        if (TransactionSubsystemRootResourceDefinition.JDBC_ACTION_STORE_TABLE_PREFIX.isMarshallable(node) || TransactionSubsystemRootResourceDefinition.JDBC_ACTION_STORE_DROP_TABLE.isMarshallable(node)) {
            writer.writeEmptyElement(Element.JDBC_ACTION_STORE.getLocalName());
            TransactionSubsystemRootResourceDefinition.JDBC_ACTION_STORE_TABLE_PREFIX.marshallAsAttribute(node, writer);
            TransactionSubsystemRootResourceDefinition.JDBC_ACTION_STORE_DROP_TABLE.marshallAsAttribute(node, writer);
        }
        if (TransactionSubsystemRootResourceDefinition.JDBC_COMMUNICATION_STORE_TABLE_PREFIX.isMarshallable(node) || TransactionSubsystemRootResourceDefinition.JDBC_COMMUNICATION_STORE_DROP_TABLE.isMarshallable(node)) {
            writer.writeEmptyElement(Element.JDBC_COMMUNICATION_STORE.getLocalName());
            TransactionSubsystemRootResourceDefinition.JDBC_COMMUNICATION_STORE_TABLE_PREFIX.marshallAsAttribute(node, writer);
            TransactionSubsystemRootResourceDefinition.JDBC_COMMUNICATION_STORE_DROP_TABLE.marshallAsAttribute(node, writer);
        }
        if (TransactionSubsystemRootResourceDefinition.JDBC_STATE_STORE_TABLE_PREFIX.isMarshallable(node) || TransactionSubsystemRootResourceDefinition.JDBC_STATE_STORE_DROP_TABLE.isMarshallable(node)) {
            writer.writeEmptyElement(Element.JDBC_STATE_STORE.getLocalName());
            TransactionSubsystemRootResourceDefinition.JDBC_STATE_STORE_TABLE_PREFIX.marshallAsAttribute(node, writer);
            TransactionSubsystemRootResourceDefinition.JDBC_STATE_STORE_DROP_TABLE.marshallAsAttribute(node, writer);
        }
        writer.writeEndElement();
    }
    if (node.hasDefined(CommonAttributes.CM_RESOURCE) &amp;&amp; !node.get(CommonAttributes.CM_RESOURCE).asList().isEmpty()) {
        writer.writeStartElement(Element.CM_RESOURCES.getLocalName());
        for (Property cmr : node.get(CommonAttributes.CM_RESOURCE).asPropertyList()) {
            writer.writeStartElement(CommonAttributes.CM_RESOURCE);
            writer.writeAttribute(Attribute.JNDI_NAME.getLocalName(), cmr.getName());
            if (cmr.getValue().hasDefined(CMResourceResourceDefinition.CM_TABLE_NAME.getName()) || cmr.getValue().hasDefined(CMResourceResourceDefinition.CM_TABLE_BATCH_SIZE.getName()) || cmr.getValue().hasDefined(CMResourceResourceDefinition.CM_TABLE_IMMEDIATE_CLEANUP.getName())) {
                writer.writeStartElement(Element.CM_TABLE.getLocalName());
                CMResourceResourceDefinition.CM_TABLE_NAME.marshallAsAttribute(cmr.getValue(), writer);
                CMResourceResourceDefinition.CM_TABLE_BATCH_SIZE.marshallAsAttribute(cmr.getValue(), writer);
                CMResourceResourceDefinition.CM_TABLE_IMMEDIATE_CLEANUP.marshallAsAttribute(cmr.getValue(), writer);
                writer.writeEndElement();
            }
            writer.writeEndElement();
        }
        writer.writeEndElement();
    }
    if (TransactionSubsystemRootResourceDefinition.STALE_TRANSACTION_TIME.isMarshallable(node)) {
        writer.writeStartElement(Element.CLIENT.getLocalName());
        TransactionSubsystemRootResourceDefinition.STALE_TRANSACTION_TIME.marshallAsAttribute(node, writer);
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
</code></pre></div></td>
</tr>
<tr>
    <td>30</td><td>2195.23</td><td>29</td><td>82</td>
    <td><div class="code-container"><pre><code class="language-java">public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {
    final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();
    if (!DeploymentTypeMarker.isType(DeploymentType.WAR, deploymentUnit)) {
        return;
    }
    final WarMetaData warMetaData = deploymentUnit.getAttachment(WarMetaData.ATTACHMENT_KEY);
    if (warMetaData == null || warMetaData.getMergedJBossWebMetaData() == null) {
        return;
    }
    TldsMetaData tldsMetaData = deploymentUnit.getAttachment(TldsMetaData.ATTACHMENT_KEY);
    if (tldsMetaData == null) {
        tldsMetaData = new TldsMetaData();
        deploymentUnit.putAttachment(TldsMetaData.ATTACHMENT_KEY, tldsMetaData);
    }
    Map&lt;String, TldMetaData&gt; tlds = new HashMap&lt;String, TldMetaData&gt;();
    tldsMetaData.setTlds(tlds);
    final List&lt;TldMetaData&gt; uniqueTlds = new ArrayList&lt;&gt;();
    final VirtualFile deploymentRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT).getRoot();
    final List&lt;VirtualFile&gt; testRoots = new ArrayList&lt;VirtualFile&gt;();
    testRoots.add(deploymentRoot);
    testRoots.add(deploymentRoot.getChild(WEB_INF));
    testRoots.add(deploymentRoot.getChild(META_INF));
    for (ResourceRoot root : deploymentUnit.getAttachmentList(Attachments.RESOURCE_ROOTS)) {
        testRoots.add(root.getRoot());
        testRoots.add(root.getRoot().getChild(META_INF));
        testRoots.add(root.getRoot().getChild(META_INF).getChild(RESOURCES));
    }
    JspConfigMetaData merged = warMetaData.getMergedJBossWebMetaData().getJspConfig();
    if (merged != null &amp;&amp; merged.getTaglibs() != null) {
        for (final TaglibMetaData tld : merged.getTaglibs()) {
            boolean found = false;
            for (final VirtualFile root : testRoots) {
                VirtualFile child = root.getChild(tld.getTaglibLocation());
                if (child.exists()) {
                    if (isTldFile(child)) {
                        TldMetaData value = processTld(deploymentRoot, child, tlds, uniqueTlds);
                        if (!tlds.containsKey(tld.getTaglibUri())) {
                            tlds.put(tld.getTaglibUri(), value);
                        }
                    }
                    found = true;
                    break;
                }
            }
            if (!found) {
                UndertowLogger.ROOT_LOGGER.tldNotFound(tld.getTaglibLocation());
            }
        }
    }
    List&lt;ResourceRoot&gt; resourceRoots = deploymentUnit.getAttachmentList(Attachments.RESOURCE_ROOTS);
    for (ResourceRoot resourceRoot : resourceRoots) {
        if (resourceRoot.getRoot().getName().toLowerCase(Locale.ENGLISH).endsWith(&quot;.jar&quot;)) {
            VirtualFile webFragment = resourceRoot.getRoot().getChild(META_INF);
            if (webFragment.exists() &amp;&amp; webFragment.isDirectory()) {
                processTlds(deploymentRoot, webFragment.getChildren(), tlds, uniqueTlds);
            }
        }
    }
    VirtualFile webInf = deploymentRoot.getChild(WEB_INF);
    if (webInf.exists() &amp;&amp; webInf.isDirectory()) {
        for (VirtualFile file : webInf.getChildren()) {
            if (isTldFile(file)) {
                processTld(deploymentRoot, file, tlds, uniqueTlds);
            } else if (file.isDirectory() &amp;&amp; !CLASSES.equals(file.getName()) &amp;&amp; !LIB.equals(file.getName())) {
                processTlds(deploymentRoot, file.getChildren(), tlds, uniqueTlds);
            }
        }
    }
    JBossWebMetaData mergedMd = warMetaData.getMergedJBossWebMetaData();
    if (mergedMd.getListeners() == null) {
        mergedMd.setListeners(new ArrayList&lt;ListenerMetaData&gt;());
    }
    final ArrayList&lt;TldMetaData&gt; allTlds = new ArrayList&lt;&gt;(uniqueTlds);
    allTlds.addAll(tldsMetaData.getSharedTlds(deploymentUnit));
    for (final TldMetaData tld : allTlds) {
        if (tld.getListeners() != null) {
            for (ListenerMetaData l : tld.getListeners()) {
                mergedMd.getListeners().add(l);
            }
        }
    }
}
</code></pre></div></td>
</tr>
<tr>
    <td>31</td><td>2084.03</td><td>23</td><td>82</td>
    <td><div class="code-container"><pre><code class="language-java">public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {
    ClassLoader old = WildFlySecurityManager.getCurrentContextClassLoaderPrivileged();
    try {
        WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(WebParsingDeploymentProcessor.class);
        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();
        if (!DeploymentTypeMarker.isType(DeploymentType.WAR, deploymentUnit)) {
            return;
        }
        final ResourceRoot deploymentRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT);
        final VirtualFile alternateDescriptor = deploymentRoot.getAttachment(org.jboss.as.ee.structure.Attachments.ALTERNATE_WEB_DEPLOYMENT_DESCRIPTOR);
        final VirtualFile webXml;
        if (alternateDescriptor != null) {
            webXml = alternateDescriptor;
        } else {
            webXml = deploymentRoot.getRoot().getChild(WEB_XML);
        }
        final WarMetaData warMetaData = deploymentUnit.getAttachment(WarMetaData.ATTACHMENT_KEY);
        assert warMetaData != null;
        if (webXml.exists()) {
            InputStream is = null;
            try {
                is = webXml.openStream();
                final XMLInputFactory inputFactory = XMLInputFactory.newInstance();
                MetaDataElementParser.DTDInfo dtdInfo = new MetaDataElementParser.DTDInfo();
                inputFactory.setXMLResolver(dtdInfo);
                final XMLStreamReader xmlReader = inputFactory.createXMLStreamReader(is);
                WebMetaData webMetaData = WebMetaDataParser.parse(xmlReader, dtdInfo, SpecDescriptorPropertyReplacement.propertyReplacer(deploymentUnit));
                if (schemaValidation &amp;&amp; webMetaData.getSchemaLocation() != null) {
                    XMLSchemaValidator validator = new XMLSchemaValidator(new XMLResourceResolver());
                    InputStream xmlInput = webXml.openStream();
                    ClassLoader oldCl = Thread.currentThread().getContextClassLoader();
                    try {
                        Thread.currentThread().setContextClassLoader(WebMetaDataParser.class.getClassLoader());
                        if (webMetaData.is23())
                            validator.validate(&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;, xmlInput);
                        else if (webMetaData.is24())
                            validator.validate(&quot;http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&quot;, xmlInput);
                        else if (webMetaData.is25())
                            validator.validate(&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;, xmlInput);
                        else if (webMetaData.is30())
                            validator.validate(&quot;http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;, xmlInput);
                        else if (webMetaData.is31())
                            validator.validate(&quot;http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;, xmlInput);
                        else if (webMetaData.getVersion() != null &amp;&amp; webMetaData.getVersion().equals(&quot;4.0&quot;))
                            validator.validate(&quot;http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;, xmlInput);
                        else if (webMetaData.getVersion() != null &amp;&amp; webMetaData.getVersion().equals(&quot;5.0&quot;))
                            validator.validate(&quot;https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;, xmlInput);
                        else if (webMetaData.getVersion() != null &amp;&amp; webMetaData.getVersion().equals(&quot;6.0&quot;))
                            validator.validate(&quot;https://jakarta.ee/xml/ns/jakartaee/web-app_6_0.xsd&quot;, xmlInput);
                        else
                            validator.validate(&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.2//EN&quot;, xmlInput);
                    } catch (SAXException e) {
                        throw new DeploymentUnitProcessingException(&quot;Failed to validate &quot; + webXml, e);
                    } finally {
                        xmlInput.close();
                        Thread.currentThread().setContextClassLoader(oldCl);
                    }
                }
                warMetaData.setWebMetaData(webMetaData);
            } catch (XMLStreamException e) {
                Integer lineNumber = null;
                Integer columnNumber = null;
                if (e.getLocation() != null) {
                    lineNumber = e.getLocation().getLineNumber();
                    columnNumber = e.getLocation().getColumnNumber();
                }
                throw new DeploymentUnitProcessingException(UndertowLogger.ROOT_LOGGER.failToParseXMLDescriptor(webXml.toString(), lineNumber, columnNumber), e);
            } catch (IOException e) {
                throw new DeploymentUnitProcessingException(UndertowLogger.ROOT_LOGGER.failToParseXMLDescriptor(webXml.toString()), e);
            } finally {
                try {
                    if (is != null) {
                        is.close();
                    }
                } catch (IOException e) {
                }
            }
        }
    } finally {
        WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(old);
    }
}
</code></pre></div></td>
</tr>
<tr>
    <td>32</td><td>3621.75</td><td>1</td><td>86</td>
    <td><div class="code-container"><pre><code class="language-java">public void test(@ArquillianResource @OperateOnDeployment(DEPLOYMENT_1) ManagementClient client1, @ArquillianResource @OperateOnDeployment(DEPLOYMENT_2) ManagementClient client2, @ArquillianResource(TraceServlet.class) @OperateOnDeployment(DEPLOYMENT_1) URL baseURL1, @ArquillianResource(TraceServlet.class) @OperateOnDeployment(DEPLOYMENT_2) URL baseURL2) throws Exception {
    this.deploy(SINGLETON_DEPLOYMENT_1);
    Thread.sleep(DELAY);
    this.deploy(SINGLETON_DEPLOYMENT_2);
    Thread.sleep(DELAY);
    String primaryProviderRequest = String.format(&quot;/subsystem=singleton/singleton-policy=default/deployment=%s:read-attribute(name=primary-provider)&quot;, this.deploymentName);
    String isPrimaryRequest = String.format(&quot;/subsystem=singleton/singleton-policy=default/deployment=%s:read-attribute(name=is-primary)&quot;, this.deploymentName);
    String getProvidersRequest = String.format(&quot;/subsystem=singleton/singleton-policy=default/deployment=%s:read-attribute(name=providers)&quot;, this.deploymentName);
    Assert.assertEquals(NODE_1, execute(client1, primaryProviderRequest).asStringOrNull());
    Assert.assertTrue(execute(client1, isPrimaryRequest).asBoolean(false));
    Assert.assertEquals(List.of(NODE_1, NODE_2), execute(client1, getProvidersRequest).asList().stream().map(ModelNode::asString).sorted().collect(Collectors.toList()));
    Assert.assertEquals(NODE_1, execute(client2, primaryProviderRequest).asStringOrNull());
    Assert.assertFalse(execute(client2, isPrimaryRequest).asBoolean(true));
    Assert.assertEquals(List.of(NODE_1, NODE_2), execute(client2, getProvidersRequest).asList().stream().map(ModelNode::asString).sorted().collect(Collectors.toList()));
    URI uri1 = TraceServlet.createURI(new URL(baseURL1.getProtocol(), baseURL1.getHost(), baseURL1.getPort(), &quot;/&quot; + this.moduleName + &quot;/&quot;));
    URI uri2 = TraceServlet.createURI(new URL(baseURL2.getProtocol(), baseURL2.getHost(), baseURL2.getPort(), &quot;/&quot; + this.moduleName + &quot;/&quot;));
    try (CloseableHttpClient client = TestHttpClientUtils.promiscuousCookieHttpClient()) {
        try (CloseableHttpResponse response = client.execute(new HttpGet(uri1))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
        }
        try (CloseableHttpResponse response = client.execute(new HttpGet(uri2))) {
            Assert.assertEquals(HttpServletResponse.SC_NOT_FOUND, response.getStatusLine().getStatusCode());
        }
        this.undeploy(SINGLETON_DEPLOYMENT_1);
        Thread.sleep(DELAY);
        Assert.assertEquals(NODE_2, execute(client2, primaryProviderRequest).asStringOrNull());
        Assert.assertTrue(execute(client2, isPrimaryRequest).asBoolean(false));
        Assert.assertEquals(Collections.singletonList(NODE_2), execute(client2, getProvidersRequest).asList().stream().map(ModelNode::asString).collect(Collectors.toList()));
        try (CloseableHttpResponse response = client.execute(new HttpGet(uri1))) {
            Assert.assertEquals(HttpServletResponse.SC_NOT_FOUND, response.getStatusLine().getStatusCode());
        }
        try (CloseableHttpResponse response = client.execute(new HttpGet(uri2))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
        }
        this.deploy(SINGLETON_DEPLOYMENT_1);
        Thread.sleep(DELAY);
        Assert.assertEquals(NODE_1, execute(client1, primaryProviderRequest).asStringOrNull());
        Assert.assertTrue(execute(client1, isPrimaryRequest).asBoolean(false));
        Assert.assertEquals(List.of(NODE_1, NODE_2), execute(client1, getProvidersRequest).asList().stream().map(ModelNode::asString).sorted().collect(Collectors.toList()));
        Assert.assertEquals(NODE_1, execute(client2, primaryProviderRequest).asStringOrNull());
        Assert.assertFalse(execute(client2, isPrimaryRequest).asBoolean(true));
        Assert.assertEquals(List.of(NODE_1, NODE_2), execute(client2, getProvidersRequest).asList().stream().map(ModelNode::asString).sorted().collect(Collectors.toList()));
        try (CloseableHttpResponse response = client.execute(new HttpGet(uri1))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
        }
        try (CloseableHttpResponse response = client.execute(new HttpGet(uri2))) {
            Assert.assertEquals(HttpServletResponse.SC_NOT_FOUND, response.getStatusLine().getStatusCode());
        }
        this.undeploy(SINGLETON_DEPLOYMENT_2);
        Thread.sleep(DELAY);
        Assert.assertEquals(NODE_1, execute(client1, primaryProviderRequest).asStringOrNull());
        Assert.assertTrue(execute(client1, isPrimaryRequest).asBoolean(false));
        Assert.assertEquals(Collections.singletonList(NODE_1), execute(client1, getProvidersRequest).asList().stream().map(ModelNode::asString).collect(Collectors.toList()));
        try (CloseableHttpResponse response = client.execute(new HttpGet(uri1))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
        }
        try (CloseableHttpResponse response = client.execute(new HttpGet(uri2))) {
            Assert.assertEquals(HttpServletResponse.SC_NOT_FOUND, response.getStatusLine().getStatusCode());
        }
        this.deploy(SINGLETON_DEPLOYMENT_2);
        Thread.sleep(DELAY);
        Assert.assertEquals(NODE_1, execute(client1, primaryProviderRequest).asStringOrNull());
        Assert.assertTrue(execute(client1, isPrimaryRequest).asBoolean(false));
        Assert.assertEquals(List.of(NODE_1, NODE_2), execute(client1, getProvidersRequest).asList().stream().map(ModelNode::asString).sorted().collect(Collectors.toList()));
        Assert.assertEquals(NODE_1, execute(client2, primaryProviderRequest).asStringOrNull());
        Assert.assertFalse(execute(client2, isPrimaryRequest).asBoolean(true));
        Assert.assertEquals(List.of(NODE_1, NODE_2), execute(client2, getProvidersRequest).asList().stream().map(ModelNode::asString).sorted().collect(Collectors.toList()));
        try (CloseableHttpResponse response = client.execute(new HttpGet(uri1))) {
            Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());
        }
        try (CloseableHttpResponse response = client.execute(new HttpGet(uri2))) {
            Assert.assertEquals(HttpServletResponse.SC_NOT_FOUND, response.getStatusLine().getStatusCode());
        }
    } finally {
        this.undeploy(SINGLETON_DEPLOYMENT_1);
        Thread.sleep(DELAY);
        this.undeploy(SINGLETON_DEPLOYMENT_2);
        Thread.sleep(DELAY);
    }
}
</code></pre></div></td>
</tr>
<tr>
    <td>33</td><td>3614.14</td><td>5</td><td>74</td>
    <td><div class="code-container"><pre><code class="language-java">public void testRuntime() throws Exception {
    if (!this.schema.since(UndertowSubsystemSchema.VERSION_14_0))
        return;
    KernelServicesBuilder builder = createKernelServicesBuilder(new RuntimeInitialization(this.values)).setSubsystemXml(getSubsystemXml());
    KernelServices mainServices = builder.build();
    if (!mainServices.isSuccessfulBoot()) {
        Throwable t = mainServices.getBootError();
        Assert.fail(&quot;Boot unsuccessful: &quot; + (t != null ? t.toString() : &quot;no boot error provided&quot;));
    }
    PredicateHandlerWrapper connectionLimiterService = (PredicateHandlerWrapper) this.values.get(UndertowService.FILTER.append(&quot;limit-connections&quot;)).get();
    HttpHandler connectionLimiterHandler = connectionLimiterService.wrap(Predicates.truePredicate(), new PathHandler());
    Assert.assertNotNull(&quot;handler should have been created&quot;, connectionLimiterHandler);
    PredicateHandlerWrapper headersService = (PredicateHandlerWrapper) this.values.get(UndertowService.FILTER.append(&quot;headers&quot;)).get();
    HttpHandler headerHandler = headersService.wrap(Predicates.truePredicate(), new PathHandler());
    Assert.assertNotNull(&quot;handler should have been created&quot;, headerHandler);
    PredicateHandlerWrapper modClusterService = (PredicateHandlerWrapper) this.values.get(UndertowService.FILTER.append(&quot;mod-cluster&quot;)).get();
    Assert.assertNotNull(modClusterService);
    HttpHandler modClusterHandler = modClusterService.wrap(Predicates.truePredicate(), new PathHandler());
    Assert.assertNotNull(&quot;handler should have been created&quot;, modClusterHandler);
    UndertowService undertowService = (UndertowService) this.values.get(UndertowRootDefinition.UNDERTOW_CAPABILITY.getCapabilityServiceName()).get();
    Assert.assertEquals(&quot;some-id&quot;, undertowService.getInstanceId());
    Assert.assertTrue(undertowService.isStatisticsEnabled());
    Assert.assertEquals(&quot;some-server&quot;, undertowService.getDefaultServer());
    Assert.assertEquals(&quot;myContainer&quot;, undertowService.getDefaultContainer());
    Assert.assertEquals(&quot;default-virtual-host&quot;, undertowService.getDefaultVirtualHost());
    Assert.assertEquals(1, undertowService.getServers().size());
    Server server = undertowService.getServers().iterator().next();
    Assert.assertEquals(&quot;other-host&quot;, server.getDefaultHost());
    Host host = (Host) this.values.get(HostDefinition.HOST_CAPABILITY.getCapabilityServiceName(&quot;some-server&quot;, &quot;other-host&quot;)).get();
    Assert.assertEquals(2, server.getHosts().size());
    Assert.assertEquals(&quot;some-server&quot;, server.getName());
    Assert.assertEquals(3, host.getAllAliases().size());
    Assert.assertTrue(host.getAllAliases().contains(&quot;default-alias&quot;));
    LocationService locationService = (LocationService) this.values.get(LocationDefinition.LOCATION_CAPABILITY.getCapabilityServiceName(&quot;some-server&quot;, &quot;default-virtual-host&quot;, &quot;/&quot;)).get();
    Assert.assertNotNull(locationService);
    JSPConfig jspConfig = ((ServletContainerService) this.values.get(ServletContainerDefinition.SERVLET_CONTAINER_CAPABILITY.getCapabilityServiceName(&quot;myContainer&quot;)).get()).getJspConfig();
    Assert.assertNotNull(jspConfig);
    Assert.assertNotNull(jspConfig.createJSPServletInfo());
    UndertowFilter gzipFilterRef = (UndertowFilter) this.values.get(UndertowService.filterRefName(&quot;some-server&quot;, &quot;other-host&quot;, &quot;/&quot;, &quot;static-gzip&quot;)).get();
    HttpHandler gzipHandler = gzipFilterRef.wrap(new PathHandler());
    Assert.assertNotNull(&quot;handler should have been created&quot;, gzipHandler);
    Assert.assertEquals(1, host.getFilters().size());
    ModelNode op = Util.createOperation(&quot;write-attribute&quot;, PathAddress.pathAddress(UndertowRootDefinition.PATH_ELEMENT).append(&quot;servlet-container&quot;, &quot;myContainer&quot;).append(&quot;setting&quot;, &quot;websockets&quot;));
    op.get(&quot;name&quot;).set(&quot;buffer-pool&quot;);
    op.get(&quot;value&quot;).set(&quot;default&quot;);
    ModelNode res = ModelTestUtils.checkOutcome(mainServices.executeOperation(op));
    Assert.assertNotNull(res);
    op = Util.createOperation(&quot;write-attribute&quot;, PathAddress.pathAddress(UndertowRootDefinition.PATH_ELEMENT).append(&quot;server&quot;, &quot;some-server&quot;).append(&quot;http-listener&quot;, &quot;default&quot;));
    op.get(&quot;name&quot;).set(&quot;enabled&quot;);
    op.get(&quot;value&quot;).set(&quot;${env.val:true}&quot;);
    res = ModelTestUtils.checkOutcome(mainServices.executeOperation(op));
    Assert.assertNotNull(res);
    Host defaultHost = (Host) this.values.get(UndertowService.DEFAULT_HOST).get();
    Assert.assertNotNull(&quot;Default host should exist&quot;, defaultHost);
    Server defaultServer = (Server) this.values.get(UndertowService.DEFAULT_SERVER).get();
    Assert.assertNotNull(&quot;Default host should exist&quot;, defaultServer);
    AccessLogService accessLogService = (AccessLogService) this.values.get(AccessLogDefinition.ACCESS_LOG_CAPABILITY.getCapabilityServiceName(&quot;some-server&quot;, &quot;default-virtual-host&quot;)).get();
    Assert.assertNotNull(accessLogService);
    Assert.assertFalse(accessLogService.isRotate());
    if (this.schema.since(UndertowSubsystemSchema.VERSION_13_0)) {
        PathAddress address = PathAddress.pathAddress(UndertowRootDefinition.PATH_ELEMENT, PathElement.pathElement(Constants.APPLICATION_SECURITY_DOMAIN, &quot;other&quot;), SingleSignOnDefinition.PATH_ELEMENT);
        ModelNode result = mainServices.executeOperation(Util.getWriteAttributeOperation(address, SingleSignOnDefinition.Attribute.PATH.getName(), new ModelNode(&quot;/modified-path&quot;)));
        assertEquals(ModelDescriptionConstants.SUCCESS, result.get(ModelDescriptionConstants.OUTCOME).asString());
        assertTrue(&quot;It is expected that reload is required after the operation.&quot;, result.get(ModelDescriptionConstants.RESPONSE_HEADERS).get(ModelDescriptionConstants.OPERATION_REQUIRES_RELOAD).asBoolean());
    }
}
</code></pre></div></td>
</tr>
<tr>
    <td>34</td><td>1442.11</td><td>18</td><td>76</td>
    <td><div class="code-container"><pre><code class="language-java">public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {
    final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();
    final EEModuleDescription module = deploymentUnit.getAttachment(Attachments.EE_MODULE_DESCRIPTION);
    final EEApplicationClasses applicationClasses = deploymentUnit.getAttachment(Attachments.EE_APPLICATION_CLASSES_DESCRIPTION);
    if (!DeploymentTypeMarker.isType(DeploymentType.WAR, deploymentUnit)) {
        return;
    }
    WarMetaData warMetaData = deploymentUnit.getAttachment(WarMetaData.ATTACHMENT_KEY);
    if (warMetaData == null) {
        WeldLogger.DEPLOYMENT_LOGGER.debug(&quot;Not installing Weld web tier integration as no war metadata found&quot;);
        return;
    }
    JBossWebMetaData webMetaData = warMetaData.getMergedJBossWebMetaData();
    if (webMetaData == null) {
        WeldLogger.DEPLOYMENT_LOGGER.debug(&quot;Not installing Weld web tier integration as no merged web metadata found&quot;);
        return;
    }
    if (!WeldDeploymentMarker.isWeldDeployment(deploymentUnit)) {
        if (WeldDeploymentMarker.isPartOfWeldDeployment(deploymentUnit)) {
            createDependency(deploymentUnit, warMetaData);
        }
        return;
    }
    createDependency(deploymentUnit, warMetaData);
    List&lt;ListenerMetaData&gt; listeners = webMetaData.getListeners();
    if (listeners == null) {
        listeners = new ArrayList&lt;ListenerMetaData&gt;();
        webMetaData.setListeners(listeners);
    } else {
        final ListIterator&lt;ListenerMetaData&gt; iterator = listeners.listIterator();
        while (iterator.hasNext()) {
            final ListenerMetaData listener = iterator.next();
            if (listener.getListenerClass().trim().equals(WELD_SERVLET_LISTENER)) {
                WeldLogger.DEPLOYMENT_LOGGER.debugf(&quot;Removing weld servlet listener %s from web config, as it is not needed in EE6 environments&quot;, WELD_SERVLET_LISTENER);
                iterator.remove();
                break;
            }
        }
    }
    listeners.add(0, INITIAL_LISTENER_METADATA);
    listeners.add(TERMINAL_LISTENER_MEDATADA);
    registerAsComponent(WELD_INITIAL_LISTENER, deploymentUnit);
    registerAsComponent(WELD_TERMINAL_LISTENER, deploymentUnit);
    deploymentUnit.addToAttachmentList(ExpressionFactoryWrapper.ATTACHMENT_KEY, WeldJspExpressionFactoryWrapper.INSTANCE);
    if (webMetaData.getContextParams() == null) {
        webMetaData.setContextParams(new ArrayList&lt;ParamValueMetaData&gt;());
    }
    final List&lt;ParamValueMetaData&gt; contextParams = webMetaData.getContextParams();
    setupWeldContextIgnores(contextParams, InitParameters.CONTEXT_IGNORE_FORWARD);
    setupWeldContextIgnores(contextParams, InitParameters.CONTEXT_IGNORE_INCLUDE);
    if (webMetaData.getFilterMappings() != null) {
        boolean filterMappingFound = false;
        for (FilterMappingMetaData mapping : webMetaData.getFilterMappings()) {
            if (CONVERSATION_FILTER_NAME.equals(mapping.getFilterName())) {
                filterMappingFound = true;
                break;
            }
        }
        if (filterMappingFound) {
            boolean filterFound = false;
            if (webMetaData.getFilters() == null) {
                webMetaData.setFilters(new FiltersMetaData());
            }
            for (FilterMetaData filter : webMetaData.getFilters()) {
                if (CONVERSATION_FILTER_CLASS.equals(filter.getFilterClass())) {
                    filterFound = true;
                    break;
                }
            }
            if (!filterFound) {
                webMetaData.getFilters().add(conversationFilterMetadata);
                registerAsComponent(CONVERSATION_FILTER_CLASS, deploymentUnit);
                webMetaData.getContextParams().add(CONVERSATION_FILTER_INITIALIZED);
            }
        }
    }
}
</code></pre></div></td>
</tr>
<tr>
    <td>35</td><td>3189.26</td><td>3</td><td>63</td>
    <td><div class="code-container"><pre><code class="language-java">public void testSubsystem() throws Exception {
    KernelServicesBuilder builder = createKernelServicesBuilder(createAdditionalInitialization()).setSubsystemXml(getSubsystemXml());
    KernelServices mainServices = builder.build();
    if (!mainServices.isSuccessfulBoot()) {
        Assert.fail(mainServices.getBootError().toString());
    }
    ServerConfig serverConfig = ServerConfigFactoryImpl.getConfig();
    Assert.assertTrue(serverConfig.isModifySOAPAddress());
    Assert.assertEquals(&quot;localhost&quot;, serverConfig.getWebServiceHost());
    Assert.assertEquals(9895, serverConfig.getWebServicePort());
    Assert.assertEquals(9944, serverConfig.getWebServiceSecurePort());
    Assert.assertEquals(&quot;https&quot;, serverConfig.getWebServiceUriScheme());
    serverConfig.reloadClientConfigs();
    ClientConfig clCfg = serverConfig.getClientConfig(&quot;My-Client-Config&quot;);
    Assert.assertNotNull(clCfg);
    Assert.assertEquals(1, clCfg.getProperties().size());
    Assert.assertEquals(&quot;bar3&quot;, clCfg.getProperties().get(&quot;foo3&quot;));
    Assert.assertEquals(2, clCfg.getPreHandlerChains().size());
    Map&lt;String, UnifiedHandlerChainMetaData&gt; map = new HashMap&lt;String, UnifiedHandlerChainMetaData&gt;();
    for (UnifiedHandlerChainMetaData uhc : clCfg.getPreHandlerChains()) {
        map.put(uhc.getId(), uhc);
    }
    Assert.assertTrue(map.get(&quot;my-handlers&quot;).getHandlers().isEmpty());
    Assert.assertEquals(&quot;##SOAP11_HTTP ##SOAP11_HTTP_MTOM ##SOAP12_HTTP ##SOAP12_HTTP_MTOM&quot;, map.get(&quot;my-handlers&quot;).getProtocolBindings());
    Assert.assertEquals(1, map.get(&quot;my-handlers2&quot;).getHandlers().size());
    Assert.assertEquals(&quot;MyHandler&quot;, map.get(&quot;my-handlers2&quot;).getHandlers().get(0).getHandlerName());
    Assert.assertEquals(&quot;org.jboss.ws.common.invocation.MyHandler&quot;, map.get(&quot;my-handlers2&quot;).getHandlers().get(0).getHandlerClass());
    Assert.assertEquals(&quot;##SOAP11_HTTP ##SOAP11_HTTP_MTOM ##SOAP12_HTTP ##SOAP12_HTTP_MTOM&quot;, map.get(&quot;my-handlers&quot;).getProtocolBindings());
    Assert.assertEquals(1, clCfg.getPostHandlerChains().size());
    Assert.assertEquals(&quot;my-handlers2&quot;, clCfg.getPostHandlerChains().get(0).getId());
    Assert.assertEquals(1, clCfg.getPostHandlerChains().get(0).getHandlers().size());
    Assert.assertEquals(&quot;MyHandler2&quot;, clCfg.getPostHandlerChains().get(0).getHandlers().get(0).getHandlerName());
    Assert.assertEquals(&quot;org.jboss.ws.common.invocation.MyHandler2&quot;, clCfg.getPostHandlerChains().get(0).getHandlers().get(0).getHandlerClass());
    Assert.assertEquals(&quot;##SOAP11_HTTP ##SOAP11_HTTP_MTOM ##SOAP12_HTTP ##SOAP12_HTTP_MTOM&quot;, clCfg.getPostHandlerChains().get(0).getProtocolBindings());
    serverConfig.reloadEndpointConfigs();
    EndpointConfig epCfg = serverConfig.getEndpointConfig(&quot;Standard-Endpoint-Config&quot;);
    Assert.assertNotNull(epCfg);
    Assert.assertTrue(epCfg.getProperties().isEmpty());
    Assert.assertTrue(epCfg.getPreHandlerChains().isEmpty());
    Assert.assertTrue(epCfg.getPostHandlerChains().isEmpty());
    epCfg = serverConfig.getEndpointConfig(&quot;Recording-Endpoint-Config&quot;);
    Assert.assertNotNull(epCfg);
    Assert.assertEquals(2, epCfg.getProperties().size());
    Assert.assertEquals(&quot;bar&quot;, epCfg.getProperties().get(&quot;foo&quot;));
    Assert.assertEquals(&quot;bar2&quot;, epCfg.getProperties().get(&quot;foo2&quot;));
    Assert.assertEquals(1, epCfg.getPreHandlerChains().size());
    Assert.assertEquals(&quot;recording-handlers&quot;, epCfg.getPreHandlerChains().get(0).getId());
    Assert.assertEquals(2, epCfg.getPreHandlerChains().get(0).getHandlers().size());
    Assert.assertEquals(&quot;RecordingHandler&quot;, epCfg.getPreHandlerChains().get(0).getHandlers().get(0).getHandlerName());
    Assert.assertEquals(&quot;org.jboss.ws.common.invocation.RecordingServerHandler&quot;, epCfg.getPreHandlerChains().get(0).getHandlers().get(0).getHandlerClass());
    Assert.assertEquals(&quot;AnotherRecordingHandler&quot;, epCfg.getPreHandlerChains().get(0).getHandlers().get(1).getHandlerName());
    Assert.assertEquals(&quot;org.jboss.ws.common.invocation.RecordingServerHandler&quot;, epCfg.getPreHandlerChains().get(0).getHandlers().get(1).getHandlerClass());
    Assert.assertEquals(&quot;##SOAP11_HTTP ##SOAP11_HTTP_MTOM ##SOAP12_HTTP ##SOAP12_HTTP_MTOM&quot;, epCfg.getPreHandlerChains().get(0).getProtocolBindings());
    Assert.assertEquals(1, epCfg.getPostHandlerChains().size());
    Assert.assertEquals(&quot;recording-handlers2&quot;, epCfg.getPostHandlerChains().get(0).getId());
    Assert.assertEquals(2, epCfg.getPostHandlerChains().get(0).getHandlers().size());
    Assert.assertEquals(&quot;RecordingHandler2&quot;, epCfg.getPostHandlerChains().get(0).getHandlers().get(0).getHandlerName());
    Assert.assertEquals(&quot;org.jboss.ws.common.invocation.RecordingServerHandler&quot;, epCfg.getPostHandlerChains().get(0).getHandlers().get(0).getHandlerClass());
    Assert.assertEquals(&quot;AnotherRecordingHandler2&quot;, epCfg.getPostHandlerChains().get(0).getHandlers().get(1).getHandlerName());
    Assert.assertEquals(&quot;org.jboss.ws.common.invocation.RecordingServerHandler&quot;, epCfg.getPostHandlerChains().get(0).getHandlers().get(1).getHandlerClass());
    Assert.assertEquals(&quot;##SOAP11_HTTP ##SOAP11_HTTP_MTOM ##SOAP12_HTTP ##SOAP12_HTTP_MTOM&quot;, epCfg.getPostHandlerChains().get(0).getProtocolBindings());
}
</code></pre></div></td>
</tr>
<tr>
    <td>36</td><td>2502.0</td><td>9</td><td>57</td>
    <td><div class="code-container"><pre><code class="language-java">protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model) throws OperationFailedException {
    final PathAddress address = context.getCurrentAddress();
    final PathAddress serverAddress = address.getParent();
    final PathAddress subsystemAddress = serverAddress.getParent();
    final ModelNode subsystemModel = Resource.Tools.readModel(context.readResourceFromRoot(subsystemAddress, false), 0);
    final ModelNode serverModel = Resource.Tools.readModel(context.readResourceFromRoot(serverAddress, false), 0);
    final String name = address.getLastElement().getValue();
    final List&lt;String&gt; aliases = HostDefinition.ALIAS.unwrap(context, model);
    final String defaultWebModule = HostDefinition.DEFAULT_WEB_MODULE.resolveModelAttribute(context, model).asString();
    final String defaultServerName = UndertowRootDefinition.DEFAULT_SERVER.resolveModelAttribute(context, subsystemModel).asString();
    final String defaultHostName = ServerDefinition.DEFAULT_HOST.resolveModelAttribute(context, serverModel).asString();
    final String serverName = serverAddress.getLastElement().getValue();
    final boolean isDefaultHost = defaultServerName.equals(serverName) &amp;&amp; name.equals(defaultHostName);
    final int defaultResponseCode = HostDefinition.DEFAULT_RESPONSE_CODE.resolveModelAttribute(context, model).asInt();
    final boolean enableConsoleRedirect = !HostDefinition.DISABLE_CONSOLE_REDIRECT.resolveModelAttribute(context, model).asBoolean();
    Boolean queueRequestsOnStart = null;
    if (model.hasDefined(HostDefinition.QUEUE_REQUESTS_ON_START.getName())) {
        queueRequestsOnStart = HostDefinition.QUEUE_REQUESTS_ON_START.resolveModelAttribute(context, model).asBoolean();
    }
    if (!defaultWebModule.equals(HostDefinition.DEFAULT_WEB_MODULE_DEFAULT) || DefaultDeploymentMappingProvider.instance().getMapping(HostDefinition.DEFAULT_WEB_MODULE_DEFAULT) == null) {
        DefaultDeploymentMappingProvider.instance().addMapping(defaultWebModule, serverName, name);
    }
    final ServiceName virtualHostServiceName = HostDefinition.HOST_CAPABILITY.fromBaseCapability(address).getCapabilityServiceName();
    final CapabilityServiceBuilder&lt;?&gt; csb = context.getCapabilityServiceTarget().addCapability(HostDefinition.HOST_CAPABILITY);
    Consumer&lt;Host&gt; hostConsumer;
    if (isDefaultHost) {
        addCommonHost(context, aliases, serverName, virtualHostServiceName);
        hostConsumer = csb.provides(HostDefinition.HOST_CAPABILITY, UndertowService.DEFAULT_HOST);
    } else {
        hostConsumer = csb.provides(HostDefinition.HOST_CAPABILITY);
    }
    final Supplier&lt;Server&gt; sSupplier = csb.requiresCapability(Capabilities.CAPABILITY_SERVER, Server.class, serverName);
    final Supplier&lt;UndertowService&gt; usSupplier = csb.requiresCapability(Capabilities.CAPABILITY_UNDERTOW, UndertowService.class);
    final Supplier&lt;ControlledProcessStateService&gt; cpssSupplier = csb.requires(ControlledProcessStateService.SERVICE_NAME);
    final Supplier&lt;SuspendController&gt; scSupplier = csb.requires(context.getCapabilityServiceName(Capabilities.REF_SUSPEND_CONTROLLER, SuspendController.class));
    csb.setInstance(new Host(hostConsumer, sSupplier, usSupplier, cpssSupplier, scSupplier, name, aliases == null ? new LinkedList&lt;&gt;() : aliases, defaultWebModule, defaultResponseCode, queueRequestsOnStart));
    csb.setInitialMode(Mode.ON_DEMAND);
    csb.install();
    if (enableConsoleRedirect) {
        final ServiceName consoleRedirectName = UndertowService.consoleRedirectServiceName(serverName, name);
        if (context.getProcessType() == ProcessType.STANDALONE_SERVER) {
            final ServiceBuilder&lt;?&gt; sb = context.getServiceTarget().addService(consoleRedirectName);
            final Supplier&lt;HttpManagement&gt; hmSupplier = sb.requires(UndertowHttpManagementService.SERVICE_NAME);
            final Supplier&lt;Host&gt; hSupplier = sb.requires(virtualHostServiceName);
            sb.setInstance(new ConsoleRedirectService(hmSupplier, hSupplier));
            sb.setInitialMode(Mode.PASSIVE);
            sb.install();
        } else {
            final ServiceBuilder&lt;?&gt; sb = context.getServiceTarget().addService(consoleRedirectName);
            final Supplier&lt;Host&gt; hSupplier = sb.requires(virtualHostServiceName);
            sb.setInstance(new ConsoleRedirectService(null, hSupplier));
            sb.setInitialMode(Mode.PASSIVE);
            sb.install();
        }
    }
}
</code></pre></div></td>
</tr>
<tr>
    <td>37</td><td>2249.19</td><td>2</td><td>63</td>
    <td><div class="code-container"><pre><code class="language-java">public void initialize(final ExtensionContext context) {
    final boolean registerRuntimeOnly = context.isRuntimeOnlyRegistrationValid();
    final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, CURRENT_MODEL_VERSION);
    subsystem.registerXMLElementWriter(new WSSubsystemWriter());
    ResourceBuilder propertyResource = ResourceBuilder.Factory.create(PROPERTY_PATH, getResourceDescriptionResolver(Constants.PROPERTY)).setAddOperation(PropertyAdd.INSTANCE).setRemoveOperation(ReloadRequiredRemoveStepHandler.INSTANCE).addReadWriteAttribute(Attributes.VALUE, null, new ReloadRequiredWriteAttributeHandler(Attributes.VALUE));
    ResourceBuilder handlerBuilder = ResourceBuilder.Factory.create(HANDLER_PATH, getResourceDescriptionResolver(HANDLER)).setAddOperation(HandlerAdd.INSTANCE).setRemoveOperation(ReloadRequiredRemoveStepHandler.INSTANCE).addReadWriteAttribute(Attributes.CLASS, null, new ReloadRequiredWriteAttributeHandler(Attributes.CLASS));
    ResourceBuilder preHandler = ResourceBuilder.Factory.create(PRE_HANDLER_CHAIN_PATH, getResourceDescriptionResolver(Constants.PRE_HANDLER_CHAIN)).setAddOperation(HandlerChainAdd.INSTANCE).setRemoveOperation(ReloadRequiredRemoveStepHandler.INSTANCE).addReadWriteAttribute(Attributes.PROTOCOL_BINDINGS, null, new ReloadRequiredWriteAttributeHandler(Attributes.PROTOCOL_BINDINGS)).pushChild(handlerBuilder).pop();
    ResourceBuilder postHandler = ResourceBuilder.Factory.create(POST_HANDLER_CHAIN_PATH, getResourceDescriptionResolver(Constants.POST_HANDLER_CHAIN)).setAddOperation(HandlerChainAdd.INSTANCE).setRemoveOperation(ReloadRequiredRemoveStepHandler.INSTANCE).addReadWriteAttribute(Attributes.PROTOCOL_BINDINGS, null, new ReloadRequiredWriteAttributeHandler(Attributes.PROTOCOL_BINDINGS)).pushChild(handlerBuilder).pop();
    ResourceDefinition epConfigsDef = ResourceBuilder.Factory.create(ENDPOINT_CONFIG_PATH, getResourceDescriptionResolver(ENDPOINT_CONFIG)).setAddOperation(EndpointConfigAdd.INSTANCE).setRemoveOperation(ReloadRequiredRemoveStepHandler.INSTANCE).pushChild(propertyResource).pop().pushChild(preHandler).pop().pushChild(postHandler).pop().build();
    ResourceDefinition clConfigsDef = ResourceBuilder.Factory.create(CLIENT_CONFIG_PATH, getResourceDescriptionResolver(CLIENT_CONFIG)).setAddOperation(ClientConfigAdd.INSTANCE).setRemoveOperation(ReloadRequiredRemoveStepHandler.INSTANCE).pushChild(propertyResource).pop().pushChild(preHandler).pop().pushChild(postHandler).pop().build();
    ResourceDefinition subsystemResource = ResourceBuilder.Factory.createSubsystemRoot(SUBSYSTEM_PATH, getResourceDescriptionResolver(), WSSubsystemAdd.INSTANCE, WSSubsystemRemove.INSTANCE).addReadWriteAttribute(Attributes.WSDL_HOST, null, new WSServerConfigAttributeHandler(Attributes.WSDL_HOST)).addReadWriteAttribute(Attributes.WSDL_PORT, null, new WSServerConfigAttributeHandler(Attributes.WSDL_PORT)).addReadWriteAttribute(Attributes.WSDL_SECURE_PORT, null, new WSServerConfigAttributeHandler(Attributes.WSDL_SECURE_PORT)).addReadWriteAttribute(Attributes.WSDL_URI_SCHEME, null, new WSServerConfigAttributeHandler(Attributes.WSDL_URI_SCHEME)).addReadWriteAttribute(Attributes.WSDL_PATH_REWRITE_RULE, null, new WSServerConfigAttributeHandler(Attributes.WSDL_PATH_REWRITE_RULE)).addReadWriteAttribute(Attributes.MODIFY_WSDL_ADDRESS, null, new WSServerConfigAttributeHandler(Attributes.MODIFY_WSDL_ADDRESS)).addReadWriteAttribute(Attributes.STATISTICS_ENABLED, null, new WSServerConfigAttributeHandler(Attributes.STATISTICS_ENABLED)).build();
    ManagementResourceRegistration subsystemRegistration = subsystem.registerSubsystemModel(subsystemResource);
    subsystemRegistration.registerSubModel(epConfigsDef);
    subsystemRegistration.registerSubModel(clConfigsDef);
    if (registerRuntimeOnly) {
        subsystem.registerDeploymentModel(ResourceBuilder.Factory.create(SUBSYSTEM_PATH, getResourceDescriptionResolver(&quot;deployment&quot;)).noFeature().setRuntime().pushChild(ENDPOINT_PATH).addMetrics(WSEndpointMetrics.INSTANCE, WSEndpointMetrics.ATTRIBUTES).addReadOnlyAttribute(ENDPOINT_CLASS).addReadOnlyAttribute(ENDPOINT_CONTEXT).addReadOnlyAttribute(ENDPOINT_NAME).addReadOnlyAttribute(ENDPOINT_TYPE).addReadOnlyAttribute(ENDPOINT_WSDL).build());
    }
}
</code></pre></div></td>
</tr>
<tr>
    <td>38</td><td>1593.71</td><td>14</td><td>52</td>
    <td><div class="code-container"><pre><code class="language-java">public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {
    final DeploymentUnit unit = phaseContext.getDeploymentUnit();
    if (DeploymentTypeMarker.isType(DeploymentType.EAR, unit)) {
        return;
    }
    final List&lt;AnnotationInstance&gt; webServiceAnnotations = getAnnotations(unit, WEB_SERVICE_ANNOTATION);
    Map&lt;String, List&lt;AnnotationInstance&gt;&gt; map = new HashMap&lt;String, List&lt;AnnotationInstance&gt;&gt;();
    for (AnnotationInstance webServiceAnnotation : webServiceAnnotations) {
        final AnnotationValue wsdlLocation = webServiceAnnotation.value(WSDL_LOCATION);
        final AnnotationValue port = webServiceAnnotation.value(PORT_NAME);
        final AnnotationValue service = webServiceAnnotation.value(SERVICE_NAME);
        if (wsdlLocation != null &amp;&amp; port != null &amp;&amp; service != null) {
            String key = wsdlLocation.asString();
            List&lt;AnnotationInstance&gt; annotations = map.get(key);
            if (annotations == null) {
                annotations = new LinkedList&lt;AnnotationInstance&gt;();
                map.put(key, annotations);
            }
            annotations.add(webServiceAnnotation);
        }
    }
    List&lt;JMSEndpointMetaData&gt; list = new LinkedList&lt;JMSEndpointMetaData&gt;();
    if (!map.isEmpty()) {
        for (String wsdlLocation : map.keySet()) {
            try {
                final ResourceRoot resourceRoot = getWsdlResourceRoot(unit, wsdlLocation);
                if (resourceRoot == null)
                    continue;
                final VirtualFile wsdlLocationFile = resourceRoot.getRoot().getChild(wsdlLocation);
                final URL url = wsdlLocationFile.toURL();
                SOAPAddressWSDLParser parser = new SOAPAddressWSDLParser(url);
                for (AnnotationInstance ai : map.get(wsdlLocation)) {
                    String port = ai.value(PORT_NAME).asString();
                    String service = ai.value(SERVICE_NAME).asString();
                    AnnotationValue targetNS = ai.value(TARGET_NAMESPACE);
                    String tns = targetNS != null ? targetNS.asString() : null;
                    QName serviceName = new QName(tns, service);
                    QName portName = new QName(tns, port);
                    String soapAddress = parser.filterSoapAddress(serviceName, portName, SOAPAddressWSDLParser.SOAP_OVER_JMS_NS);
                    if (soapAddress != null) {
                        ClassInfo webServiceClassInfo = (ClassInfo) ai.target();
                        String beanClassName = webServiceClassInfo.name().toString();
                        list.add(new JMSEndpointMetaData(beanClassName, port, beanClassName, wsdlLocation, soapAddress));
                    }
                }
            } catch (Exception ignore) {
                WSLogger.ROOT_LOGGER.cannotReadWsdl(wsdlLocation);
            }
        }
    }
    unit.putAttachment(JMS_ENDPOINT_METADATA_KEY, new JMSEndpointsMetaData(list));
}
</code></pre></div></td>
</tr>
<tr>
    <td>39</td><td>729.48</td><td>8</td><td>63</td>
    <td><div class="code-container"><pre><code class="language-java">protected void performBoottime(OperationContext context, ModelNode operation, ModelNode model) throws OperationFailedException {
    final String hostName = HOST_NAME.resolveModelAttribute(context, model).asString();
    final ModelNode coordinatorURLAttribute = ENVIRONMENT_URL.resolveModelAttribute(context, model);
    String coordinatorURL = coordinatorURLAttribute.isDefined() ? coordinatorURLAttribute.asString() : null;
    if (coordinatorURL != null) {
        Pattern urlPattern = Pattern.compile(&quot;^([a-zA-Z]+://)(.*):([^/]*)(/.*)$&quot;);
        Matcher urlMatcher = urlPattern.matcher(coordinatorURL);
        if (urlMatcher.matches()) {
            String address = NetworkUtils.formatPossibleIpv6Address(urlMatcher.group(2));
            coordinatorURL = String.format(&quot;%s%s:%s%s&quot;, urlMatcher.group(1), address, urlMatcher.group(3), urlMatcher.group(4));
        }
    }
    if (coordinatorURL != null) {
        XtsAsLogger.ROOT_LOGGER.debugf(&quot;nodeIdentifier=%s%n&quot;, coordinatorURL);
    }
    final boolean isDefaultContextPropagation = DEFAULT_CONTEXT_PROPAGATION.resolveModelAttribute(context, model).asBoolean(false);
    context.addStep(new AbstractDeploymentChainStep() {

        protected void execute(DeploymentProcessorTarget processorTarget) {
            processorTarget.addDeploymentProcessor(XTSExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_XTS_SOAP_HANDLERS, new XTSHandlerDeploymentProcessor());
            processorTarget.addDeploymentProcessor(XTSExtension.SUBSYSTEM_NAME, Phase.DEPENDENCIES, Phase.DEPENDENCIES_XTS, new XTSDependenciesDeploymentProcessor());
            processorTarget.addDeploymentProcessor(XTSExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_XTS_PORTABLE_EXTENSIONS, new GracefulShutdownDeploymentProcessor());
        }
    }, OperationContext.Stage.RUNTIME);
    final ServiceTarget target = context.getServiceTarget();
    final ClassLoader loader = XTSService.class.getClassLoader();
    ServiceBuilder&lt;Context&gt; endpointBuilder;
    ArrayList&lt;ServiceController&lt;Context&gt;&gt; controllers = new ArrayList&lt;ServiceController&lt;Context&gt;&gt;();
    Map&lt;Class&lt;?&gt;, Object&gt; attachments = new HashMap&lt;&gt;();
    attachments.put(RejectionRule.class, new GracefulShutdownRejectionRule());
    for (ContextInfo contextInfo : getContextDefinitions(context, model)) {
        String contextName = contextInfo.contextPath;
        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
        for (EndpointInfo endpointInfo : contextInfo.endpointInfo) {
            map.put(endpointInfo.URLPattern, endpointInfo.SEIClassname);
        }
        endpointBuilder = EndpointPublishService.createServiceBuilder(target, contextName, loader, hostName, map, null, null, null, attachments, context.getCapabilityServiceSupport());
        controllers.add(endpointBuilder.setInitialMode(Mode.ACTIVE).install());
    }
    XTSHandlersService.install(target, isDefaultContextPropagation);
    final XTSManagerService xtsService = new XTSManagerService(coordinatorURL);
    ServiceBuilder&lt;?&gt; xtsServiceBuilder = target.addService(XTSServices.JBOSS_XTS_MAIN, xtsService);
    xtsServiceBuilder.requires(TxnServices.JBOSS_TXN_ARJUNA_TRANSACTION_MANAGER);
    xtsServiceBuilder.addDependency(WSServices.CONFIG_SERVICE, ServerConfig.class, xtsService.getWSServerConfig());
    xtsServiceBuilder.requires(WSServices.XTS_CLIENT_INTEGRATION_SERVICE);
    for (ServiceController&lt;Context&gt; controller : controllers) {
        xtsServiceBuilder.requires(controller.getName());
    }
    xtsServiceBuilder.setInitialMode(Mode.ACTIVE).install();
    final TxBridgeInboundRecoveryService txBridgeInboundRecoveryService = new TxBridgeInboundRecoveryService();
    ServiceBuilder&lt;?&gt; txBridgeInboundRecoveryServiceBuilder = target.addService(XTSServices.JBOSS_XTS_TXBRIDGE_INBOUND_RECOVERY, txBridgeInboundRecoveryService);
    txBridgeInboundRecoveryServiceBuilder.requires(XTSServices.JBOSS_XTS_MAIN);
    txBridgeInboundRecoveryServiceBuilder.setInitialMode(Mode.ACTIVE).install();
    final TxBridgeOutboundRecoveryService txBridgeOutboundRecoveryService = new TxBridgeOutboundRecoveryService();
    ServiceBuilder&lt;?&gt; txBridgeOutboundRecoveryServiceBuilder = target.addService(XTSServices.JBOSS_XTS_TXBRIDGE_OUTBOUND_RECOVERY, txBridgeOutboundRecoveryService);
    txBridgeOutboundRecoveryServiceBuilder.requires(XTSServices.JBOSS_XTS_MAIN);
    txBridgeOutboundRecoveryServiceBuilder.setInitialMode(Mode.ACTIVE).install();
}
</code></pre></div></td>
</tr>
<tr>
    <td>40</td><td>1953.57</td><td>2</td><td>47</td>
    <td><div class="code-container"><pre><code class="language-java">protected void performBoottime(final OperationContext context, ModelNode operation, Resource resource) throws OperationFailedException {
    final ModelNode model = resource.getModel();
    final boolean requireBeanDescriptor = REQUIRE_BEAN_DESCRIPTOR_ATTRIBUTE.resolveModelAttribute(context, model).asBoolean();
    final boolean legacyEmptyBeansXmlTreatment = LEGACY_EMPTY_BEANS_XML_TREATMENT_ATTRIBUTE.resolveModelAttribute(context, model).asBoolean();
    final boolean nonPortableMode = WeldResourceDefinition.NON_PORTABLE_MODE_ATTRIBUTE.resolveModelAttribute(context, model).asBoolean();
    final boolean developmentMode = WeldResourceDefinition.DEVELOPMENT_MODE_ATTRIBUTE.resolveModelAttribute(context, model).asBoolean();
    final int threadPoolSize = WeldResourceDefinition.THREAD_POOL_SIZE_ATTRIBUTE.resolveModelAttribute(context, model).asInt(WeldExecutorServices.DEFAULT_BOUND);
    context.addStep(new AbstractDeploymentChainStep() {

        @Override
        protected void execute(DeploymentProcessorTarget processorTarget) {
            final JBossAllXmlParserRegisteringProcessor&lt;?&gt; jbossAllParsers = JBossAllXmlParserRegisteringProcessor.builder().addParser(WeldJBossAll10Parser.ROOT_ELEMENT, WeldJBossAllConfiguration.ATTACHMENT_KEY, WeldJBossAll10Parser.INSTANCE).addParser(WeldJBossAll11Parser.ROOT_ELEMENT, WeldJBossAllConfiguration.ATTACHMENT_KEY, WeldJBossAll11Parser.INSTANCE).build();
            processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_REGISTER_JBOSS_ALL_WELD, jbossAllParsers);
            processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_WELD_CONFIGURATION, new WeldConfigurationProcessor(requireBeanDescriptor, nonPortableMode, developmentMode, legacyEmptyBeansXmlTreatment));
            processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_CDI_ANNOTATIONS, new CdiAnnotationProcessor());
            processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_CDI_BEAN_DEFINING_ANNOTATIONS, new BeanDefiningAnnotationProcessor());
            processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_WELD_DEPLOYMENT, new BeansXmlProcessor());
            processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_WELD_IMPLICIT_DEPLOYMENT_DETECTION, new WeldImplicitDeploymentProcessor());
            processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.DEPENDENCIES, Phase.DEPENDENCIES_WELD, new WeldDependencyProcessor());
            processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_WELD_WEB_INTEGRATION, new WebIntegrationProcessor());
            processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_WELD_BEAN_ARCHIVE, new BeanArchiveProcessor());
            processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_WELD_EXTERNAL_BEAN_ARCHIVE, new ExternalBeanArchiveProcessor());
            processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_WELD_PORTABLE_EXTENSIONS, new WeldPortableExtensionProcessor());
            processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, 0x0F10, new EarApplicationScopedObserverMethodProcessor());
            processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_WELD_COMPONENT_INTEGRATION, new WeldComponentIntegrationProcessor());
            processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_ENV_ENTRY + 1, new SimpleEnvEntryCdiResourceInjectionProcessor());
            processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_WELD_DEPLOYMENT, new WeldDeploymentProcessor(checkJtsEnabled(context)));
            processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_WELD_BEAN_MANAGER, new WeldBeanManagerServiceProcessor());
            processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.CLEANUP, Phase.CLEANUP_EE - 1, new WeldDeploymentCleanupProcessor());
            ServiceLoader&lt;DeploymentUnitProcessorProvider&gt; processorProviders = ServiceLoader.load(DeploymentUnitProcessorProvider.class, WildFlySecurityManager.getClassLoaderPrivileged(WeldSubsystemAdd.class));
            for (DeploymentUnitProcessorProvider provider : processorProviders) {
                processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, provider.getPhase(), provider.getPriority(), provider.getProcessor());
            }
        }
    }, OperationContext.Stage.RUNTIME);
    context.getServiceTarget().addService(TCCLSingletonService.SERVICE_NAME).setInstance(new TCCLSingletonService()).setInitialMode(Mode.ON_DEMAND).install();
    ServiceBuilder&lt;?&gt; builder = context.getServiceTarget().addService(WeldExecutorServices.SERVICE_NAME);
    final Consumer&lt;ExecutorServices&gt; executorServicesConsumer = builder.provides(WeldExecutorServices.SERVICE_NAME);
    builder.setInstance(new WeldExecutorServices(executorServicesConsumer, threadPoolSize));
    builder.setInitialMode(Mode.ON_DEMAND);
    builder.install();
}
</code></pre></div></td>
</tr>
<tr>
    <td>41</td><td>876.13</td><td>12</td><td>48</td>
    <td><div class="code-container"><pre><code class="language-java">public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {
    final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();
    if (WeldDeploymentMarker.isWeldDeployment(deploymentUnit)) {
        return;
    }
    if (Utils.getRootDeploymentUnit(deploymentUnit).getAttachment(WeldConfiguration.ATTACHMENT_KEY).isRequireBeanDescriptor()) {
        return;
    }
    final Set&lt;AnnotationType&gt; beanDefiningAnnotations = new HashSet&lt;&gt;(getRootDeploymentUnit(deploymentUnit).getAttachment(WeldAttachments.BEAN_DEFINING_ANNOTATIONS));
    final Map&lt;ResourceRoot, Index&gt; indexes = AnnotationIndexUtils.getAnnotationIndexes(deploymentUnit);
    final ExplicitBeanArchiveMetadataContainer explicitBeanArchiveMetadata = deploymentUnit.getAttachment(ExplicitBeanArchiveMetadataContainer.ATTACHMENT_KEY);
    final ResourceRoot classesRoot = deploymentUnit.getAttachment(WeldAttachments.CLASSES_RESOURCE_ROOT);
    final ResourceRoot deploymentRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT);
    for (Entry&lt;ResourceRoot, Index&gt; entry : indexes.entrySet()) {
        ResourceRoot resourceRoot = entry.getKey();
        if (resourceRoot == classesRoot) {
            resourceRoot = deploymentRoot;
        }
        if (explicitBeanArchiveMetadata != null &amp;&amp; explicitBeanArchiveMetadata.getBeanArchiveMetadata().containsKey(resourceRoot)) {
            continue;
        }
        for (final AnnotationType annotation : beanDefiningAnnotations) {
            if (!entry.getValue().getAnnotations(annotation.getName()).isEmpty()) {
                WeldDeploymentMarker.mark(deploymentUnit);
                return;
            }
        }
    }
    final EEModuleDescription eeModuleDescription = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.EE_MODULE_DESCRIPTION);
    final Iterable&lt;ImplicitBeanArchiveDetector&gt; detectors = ServiceLoader.load(ImplicitBeanArchiveDetector.class, WildFlySecurityManager.getClassLoaderPrivileged(WeldImplicitDeploymentProcessor.class));
    for (ComponentDescription component : eeModuleDescription.getComponentDescriptions()) {
        for (ImplicitBeanArchiveDetector detector : detectors) {
            if (detector.isImplicitBeanArchiveRequired(component)) {
                WeldDeploymentMarker.mark(deploymentUnit);
                return;
            }
        }
    }
}
</code></pre></div></td>
</tr>
<tr>
    <td>42</td><td>845.5</td><td>12</td><td>41</td>
    <td><div class="code-container"><pre><code class="language-java">protected BeanDeploymentArchiveImpl createAndRegisterAdditionalBeanDeploymentArchive(Module module, Class&lt;?&gt; beanClass) {
    String id = null;
    if (module == null) {
        id = BOOTSTRAP_CLASSLOADER_BDA_ID;
    } else {
        id = module.getIdentifier() + ADDITIONAL_CLASSES_BDA_SUFFIX;
    }
    BeanDeploymentArchiveImpl newBda = new BeanDeploymentArchiveImpl(Collections.singleton(beanClass.getName()), Collections.singleton(beanClass.getName()), BeansXml.EMPTY_BEANS_XML, module, id, BeanArchiveType.SYNTHETIC, false);
    WeldLogger.DEPLOYMENT_LOGGER.beanArchiveDiscovered(newBda);
    newBda.addBeanClass(beanClass);
    ServiceRegistry newBdaServices = newBda.getServices();
    for (Entry&lt;Class&lt;? extends Service&gt;, Service&gt; entry : serviceRegistry.entrySet()) {
        if (!newBdaServices.contains(entry.getKey())) {
            newBdaServices.add(entry.getKey(), Reflections.cast(entry.getValue()));
        }
    }
    if (module == null) {
        newBdaServices.add(ResourceLoader.class, serviceRegistry.get(ResourceLoader.class));
    }
    if (module != null &amp;&amp; eeModuleDescriptors.containsKey(module.getIdentifier())) {
        newBda.getServices().add(EEModuleDescriptor.class, eeModuleDescriptors.get(module.getIdentifier()));
    }
    for (BeanDeploymentArchiveImpl bda : beanDeploymentArchives) {
        if (newBda.isAccessible(bda)) {
            newBda.addBeanDeploymentArchive(bda);
        }
    }
    for (BeanDeploymentArchiveImpl bda : beanDeploymentArchives) {
        if (bda.isAccessible(newBda)) {
            bda.addBeanDeploymentArchive(newBda);
        }
    }
    newBda.addBeanDeploymentArchives(rootBeanDeploymentModule.getBeanDeploymentArchives());
    final ClassLoader cl = beanClass.getClassLoader();
    if (cl != null) {
        additionalBeanDeploymentArchivesByClassloader.put(cl, newBda);
    }
    beanDeploymentArchives.add(newBda);
    return newBda;
}
</code></pre></div></td>
</tr>
<tr>
    <td>43</td><td>888.53</td><td>9</td><td>39</td>
    <td><div class="code-container"><pre><code class="language-java">private Map&lt;String, List&lt;String&gt;&gt; discover(BeanDiscoveryMode beanDiscoveryMode, URL beansXmlUrl, URL indexUrl, Set&lt;AnnotationType&gt; beanDefiningAnnotations) {
    List&lt;String&gt; discoveredBeanClasses = new ArrayList&lt;String&gt;();
    List&lt;String&gt; allKnownClasses = new ArrayList&lt;String&gt;();
    BiConsumer&lt;String, ClassFile&gt; consumer;
    if (BeanDiscoveryMode.ANNOTATED.equals(beanDiscoveryMode)) {
        Index index = tryLoadIndex(indexUrl);
        if (index != null) {
            consumer = (name, classFile) -&gt; {
                ClassInfo classInfo = index.getClassByName(DotName.createSimple(name));
                allKnownClasses.add(name);
                if (classInfo != null &amp;&amp; hasBeanDefiningAnnotation(classInfo, beanDefiningAnnotations)) {
                    discoveredBeanClasses.add(name);
                }
            };
        } else {
            consumer = (name, classFile) -&gt; {
                try (InputStream in = classFile.openStream()) {
                    ClassInfo classInfo = Index.singleClass(in);
                    allKnownClasses.add(name);
                    if (classInfo != null &amp;&amp; hasBeanDefiningAnnotation(classInfo, beanDefiningAnnotations)) {
                        discoveredBeanClasses.add(name);
                    }
                } catch (IOException e) {
                    WeldLogger.DEPLOYMENT_LOGGER.cannotIndexClassName(name, beansXmlUrl);
                }
            };
        }
    } else {
        consumer = (name, classFile) -&gt; {
            allKnownClasses.add(name);
            discoveredBeanClasses.add(name);
        };
    }
    Map&lt;String, List&lt;String&gt;&gt; result = new HashMap&lt;&gt;();
    result.put(ALL_KNOWN_CLASSES, allKnownClasses);
    result.put(BEAN_CLASSES, discoveredBeanClasses);
    UrlScanner scanner = new UrlScanner(beansXmlUrl, consumer);
    return scanner.scan() ? result : Collections.emptyMap();
}
</code></pre></div></td>
</tr>
<tr>
    <td>44</td><td>702.92</td><td>8</td><td>39</td>
    <td><div class="code-container"><pre><code class="language-java">public synchronized void start(final StartContext context) throws StartException {
    final ClassLoader cl = WildFlySecurityManager.getCurrentContextClassLoaderPrivileged();
    try {
        WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(classLoader);
        beanManager = weldContainerSupplier.get().getBeanManager(beanDeploymentArchiveId);
        for (final Class&lt;?&gt; interceptor : interceptorClasses) {
            AnnotatedType&lt;?&gt; type = beanManager.createAnnotatedType(interceptor);
            @SuppressWarnings(&quot;rawtypes&quot;)
            InjectionTarget injectionTarget = beanManager.getInjectionTargetFactory(type).createInterceptorInjectionTarget();
            interceptorInjections.put(interceptor, beanManager.fireProcessInjectionTarget(type, injectionTarget));
        }
        if (ejbName != null) {
            EjbDescriptor&lt;Object&gt; descriptor = beanManager.getEjbDescriptor(ejbName);
            if (descriptor != null) {
                bean = beanManager.getBean(descriptor);
            }
        }
        if (bean instanceof SessionBean&lt;?&gt;) {
            SessionBean&lt;?&gt; sessionBean = (SessionBean&lt;?&gt;) bean;
            this.injectionTarget = sessionBean.getProducer();
            return;
        }
        WeldInjectionTarget&lt;?&gt; injectionTarget = InjectionTargets.createInjectionTarget(componentClass, bean, beanManager, !isComponentWithView);
        for (ComponentSupport support : ServiceLoader.load(ComponentSupport.class, WildFlySecurityManager.getClassLoaderPrivileged(WeldComponentService.class))) {
            if (support.isProcessing(componentDescription)) {
                this.injectionTarget = support.processInjectionTarget(injectionTarget, componentDescription, beanManager);
                break;
            }
        }
        if (this.injectionTarget == null) {
            this.injectionTarget = injectionTarget;
        }
        beanManager.getServices().get(InjectionTargetService.class).validateProducer(injectionTarget);
    } finally {
        WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(cl);
    }
}
</code></pre></div></td>
</tr>
<tr>
    <td>45</td><td>746.61</td><td>6</td><td>33</td>
    <td><div class="code-container"><pre><code class="language-java">public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {
    final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();
    final DeploymentUnit parent = Utils.getRootDeploymentUnit(deploymentUnit);
    final Module module = deploymentUnit.getAttachment(Attachments.MODULE);
    final ServiceTarget serviceTarget = phaseContext.getServiceTarget();
    ServiceName weldStartCompletionServiceName = parent.getServiceName().append(WeldStartCompletionService.SERVICE_NAME);
    ServiceName weldBootstrapServiceName = parent.getServiceName().append(WeldBootstrapService.SERVICE_NAME);
    ServiceName weldStartServiceName = parent.getServiceName().append(WeldStartService.SERVICE_NAME);
    if (!WeldDeploymentMarker.isPartOfWeldDeployment(deploymentUnit)) {
        return;
    }
    if (deploymentUnit.getParent() != null) {
        return;
    }
    ServiceBuilder&lt;?&gt; weldStartCompletionServiceBuilder = serviceTarget.addService(weldStartCompletionServiceName);
    final Supplier&lt;WeldBootstrapService&gt; bootstrapSupplier = weldStartCompletionServiceBuilder.requires(weldBootstrapServiceName);
    weldStartCompletionServiceBuilder.requires(weldStartServiceName);
    for (ServiceName componentStartSN : getComponentStartServiceNames(deploymentUnit)) {
        weldStartCompletionServiceBuilder.requires(componentStartSN);
    }
    final List&lt;DeploymentUnit&gt; subDeployments = deploymentUnit.getAttachmentList(Attachments.SUB_DEPLOYMENTS);
    for (DeploymentUnit sub : subDeployments) {
        ServiceRegistry registry = sub.getServiceRegistry();
        List&lt;ServiceName&gt; componentStartServiceNames = getComponentStartServiceNames(sub);
        for (ServiceName componentStartSN : componentStartServiceNames) {
            weldStartCompletionServiceBuilder.requires(componentStartSN);
        }
    }
    weldStartCompletionServiceBuilder.setInstance(new WeldStartCompletionService(bootstrapSupplier, WeldDeploymentProcessor.getSetupActions(deploymentUnit), module.getClassLoader()));
    weldStartCompletionServiceBuilder.install();
}
</code></pre></div></td>
</tr>
<tr>
    <td>46</td><td>406.24</td><td>16</td><td>34</td>
    <td><div class="code-container"><pre><code class="language-java">private static boolean containsAnnotation(Annotation[] annotations, Class&lt;? extends Annotation&gt; requiredAnnotation, boolean checkMetaAnnotations) {
    for (Annotation annotation : annotations) {
        Class&lt;? extends Annotation&gt; annotationType = annotation.annotationType();
        if (requiredAnnotation.equals(annotationType)) {
            return true;
        }
        if (checkMetaAnnotations &amp;&amp; containsAnnotation(annotationType.getAnnotations(), requiredAnnotation, false)) {
            return true;
        }
    }
    return false;
}
</code></pre></div></td>
</tr>
<tr>
    <td>47</td><td>644.33</td><td>7</td><td>28</td>
    <td><div class="code-container"><pre><code class="language-java">public Object processInvocation(InterceptorContext interceptorContext) throws Exception {
    BeanManagerImpl beanManager = this.beanManager;
    if (beanManager == null) {
        beanManager = this.beanManager = weldContainerSupplier.get().getBeanManager(beanArchiveId);
    }
    SessionBean&lt;Object&gt; bean = null;
    if (ejbName != null) {
        EjbDescriptor&lt;Object&gt; descriptor = beanManager.getEjbDescriptor(this.ejbName);
        if (descriptor != null) {
            bean = beanManager.getBean(descriptor);
        }
    }
    InterceptorBindings interceptorBindings = interceptorBindingsSupplier.get();
    final ComponentInstance componentInstance = interceptorContext.getPrivateData(ComponentInstance.class);
    InterceptorInstances existing = interceptorSupport.getInterceptorInstances(componentInstance);
    if (existing == null) {
        CreationalContext&lt;Object&gt; creationalContext = beanManager.createCreationalContext(bean);
        HashMap&lt;String, SerializableContextualInstance&lt;Interceptor&lt;Object&gt;, Object&gt;&gt; interceptorInstances = new HashMap&lt;String, SerializableContextualInstance&lt;Interceptor&lt;Object&gt;, Object&gt;&gt;();
        if (interceptorBindings != null) {
            for (Interceptor&lt;?&gt; interceptor : interceptorBindings.getAllInterceptors()) {
                addInterceptorInstance((Interceptor&lt;Object&gt;) interceptor, beanManager, interceptorInstances, creationalContext);
            }
        }
        interceptorSupport.setInterceptorInstances(componentInstance, new WeldInterceptorInstances(creationalContext, interceptorInstances));
    }
    return interceptorContext.proceed();
}
</code></pre></div></td>
</tr>
<tr>
    <td>48</td><td>474.97</td><td>8</td><td>27</td>
    <td><div class="code-container"><pre><code class="language-java">public Object resolveResource(String jndiName, String mappedName) {
    String name = ResourceInjectionUtilities.getResourceName(jndiName, mappedName);
    try {
        return context.lookup(name);
    } catch (NamingException e) {
        throw WeldLogger.ROOT_LOGGER.couldNotFindResource(name, e);
    }
}
</code></pre></div></td>
</tr>
<tr>
    <td>49</td><td>447.67</td><td>3</td><td>29</td>
    <td><div class="code-container"><pre><code class="language-java">public synchronized void start(final StartContext context) throws StartException {
    final ClassLoader loader = XTSService.class.getClassLoader();
    WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(loader);
    try {
        ServerConfig serverConfigValue = wsServerConfig.getValue();
        WSCEnvironmentBean wscEnVBean = XTSPropertyManager.getWSCEnvironmentBean();
        if (coordinatorURL != null) {
            wscEnVBean.setCoordinatorURL11(coordinatorURL);
        } else {
            String defaultCoordinatorUrl = &quot;http://&quot; + serverConfigValue.getWebServiceHost() + &quot;:&quot; + serverConfigValue.getWebServicePort() + &quot;/&quot; + wscEnVBean.getCoordinatorPath11();
            wscEnVBean.setCoordinatorURL11(defaultCoordinatorUrl);
        }
        wscEnVBean.setBindAddress11(serverConfigValue.getWebServiceHost());
        wscEnVBean.setBindPort11(serverConfigValue.getWebServicePort());
        wscEnVBean.setBindPortSecure11(serverConfigValue.getWebServiceSecurePort());
        XTSService service = new XTSService();
        try {
            service.start();
        } catch (Exception e) {
            throw XtsAsLogger.ROOT_LOGGER.xtsServiceFailedToStart();
        }
        xtsService = service;
    } finally {
        WildFlySecurityManager.setCurrentContextClassLoaderPrivileged((ClassLoader) null);
    }
}
</code></pre></div></td>
</tr>
<tr>
    <td>50</td><td>593.15</td><td>2</td><td>24</td>
    <td><div class="code-container"><pre><code class="language-java">public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {
    final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();
    final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);
    final ModuleLoader moduleLoader = Module.getBootModuleLoader();
    addDependency(moduleSpecification, moduleLoader, JAVAX_ENTERPRISE_API);
    addDependency(moduleSpecification, moduleLoader, JAVAX_INJECT_API);
    if (!WeldDeploymentMarker.isPartOfWeldDeployment(deploymentUnit)) {
        return;
    }
    addDependency(moduleSpecification, moduleLoader, JAVAX_PERSISTENCE_API_ID);
    addDependency(moduleSpecification, moduleLoader, WELD_CORE_ID);
    addDependency(moduleSpecification, moduleLoader, WELD_API_ID);
    addDependency(moduleSpecification, moduleLoader, WELD_SPI_ID);
    ModuleDependency weldSubsystemDependency = new ModuleDependency(moduleLoader, JBOSS_AS_WELD_ID, false, false, false, false);
    weldSubsystemDependency.addImportFilter(PathFilters.getMetaInfFilter(), true);
    weldSubsystemDependency.addImportFilter(PathFilters.is(&quot;org/jboss/as/weld/injection&quot;), true);
    weldSubsystemDependency.addImportFilter(PathFilters.acceptAll(), false);
    weldSubsystemDependency.addExportFilter(PathFilters.getMetaInfFilter(), true);
    moduleSpecification.addSystemDependency(weldSubsystemDependency);
    ModuleDependency weldEjbDependency = new ModuleDependency(moduleLoader, JBOSS_AS_WELD_EJB_ID, true, false, false, false);
    weldEjbDependency.addImportFilter(PathFilters.is(&quot;org/jboss/as/weld/ejb&quot;), true);
    weldEjbDependency.addImportFilter(PathFilters.acceptAll(), false);
    moduleSpecification.addSystemDependency(weldEjbDependency);
}
</code></pre></div></td>
</tr>
<tr>
    <td>51</td><td>430.84</td><td>6</td><td>21</td>
    <td><div class="code-container"><pre><code class="language-java">public Set&lt;ServiceName&gt; getDependencies(DeploymentUnit unit) {
    CompositeIndex index = unit.getAttachment(Attachments.COMPOSITE_ANNOTATION_INDEX);
    PropertyReplacer replacer = EJBAnnotationPropertyReplacement.propertyReplacer(unit);
    List&lt;AnnotationInstance&gt; annotations = index.getAnnotations(RESOURCE_ANNOTATION_NAME);
    Set&lt;ServiceName&gt; result = !annotations.isEmpty() ? new TreeSet&lt;&gt;() : Collections.emptySet();
    for (AnnotationInstance annotation : annotations) {
        AnnotationValue lookupValue = annotation.value(&quot;lookup&quot;);
        if (lookupValue != null) {
            String lookup = replacer.replaceProperties(lookupValue.asString());
            try {
                ServiceName name = ContextNames.bindInfoFor(lookup).getBinderServiceName();
                if (ContextNames.JBOSS_CONTEXT_SERVICE_NAME.isParentOf(name)) {
                    result.add(name);
                }
            } catch (RuntimeException e) {
            }
        }
    }
    return result;
}
</code></pre></div></td>
</tr>
<tr>
    <td>52</td><td>356.72</td><td>6</td><td>20</td>
    <td><div class="code-container"><pre><code class="language-java">public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {
    final DeploymentUnit unit = phaseContext.getDeploymentUnit();
    final List&lt;WebserviceDescriptionMetaData&gt; webserviceDescriptions = new ArrayList&lt;WebserviceDescriptionMetaData&gt;();
    boolean modifiedWSMeta = false;
    for (String endpoint : getDeploymentClasses(unit)) {
        try {
            final EndpointMetaData endpointMetaData = EndpointMetaData.build(unit, endpoint);
            if (endpointMetaData.isXTSEnabled()) {
                XTSDeploymentMarker.mark(unit);
                final boolean result = updateXTSEndpoint(endpoint, endpointMetaData, webserviceDescriptions, unit);
                modifiedWSMeta = modifiedWSMeta || result;
            }
        } catch (XTSException e) {
            throw XtsAsLogger.ROOT_LOGGER.errorProcessingEndpoint(endpoint, e);
        }
    }
    if (modifiedWSMeta) {
        unit.putAttachment(WSAttachmentKeys.WEBSERVICES_METADATA_KEY, new WebservicesMetaData(null, webserviceDescriptions));
    }
}
</code></pre></div></td>
</tr>
<tr>
    <td>53</td><td>345.95</td><td>4</td><td>20</td>
    <td><div class="code-container"><pre><code class="language-java">private boolean updateXTSEndpoint(final String endpoint, final EndpointMetaData endpointMetaData, final List&lt;WebserviceDescriptionMetaData&gt; webserviceDescriptions, final DeploymentUnit unit) {
    if (endpointMetaData.isWebservice()) {
        final List&lt;String&gt; handlers = new ArrayList&lt;String&gt;();
        if (endpointMetaData.isBridgeEnabled()) {
            handlers.add(TX_BRIDGE_WFTC_INTEGRATION_HANDLER);
            handlers.add(TX_BRIDGE_HANDLER);
        }
        handlers.add(TX_CONTEXT_HANDLER);
        if (!isAnyOfHandlersRegistered(unit, endpoint, handlers)) {
            final UnifiedHandlerChainsMetaData unifiedHandlerChainsMetaData = buildHandlerChains(handlers);
            final QName portQname = endpointMetaData.getWebServiceAnnotation().buildPortQName();
            webserviceDescriptions.add(new WebserviceDescriptionMetaData(null, null, null, buildPortComponent(endpointMetaData.isEJB(), endpoint, portQname, unifiedHandlerChainsMetaData)));
            registerHandlersWithAS(unit, endpoint, handlers);
            return true;
        }
    }
    return false;
}
</code></pre></div></td>
</tr>
<tr>
    <td>54</td><td>188.87</td><td>5</td><td>21</td>
    <td><div class="code-container"><pre><code class="language-java">public Object proceed() throws Exception {
    int oldPosition = position;
    try {
        if (position &lt; invocationQueue.size()) {
            Object interceptorInstance = interceptorInstances.get(position);
            try {
                return invocationQueue.get(position++).intercept(interceptionType, interceptorInstance, this);
            } catch (Exception e) {
                if (e instanceof WeldException &amp;&amp; e.getCause() instanceof Exception) {
                    throw ((Exception) e.getCause());
                } else {
                    throw e;
                }
            }
        } else {
            return delegateInvocationContext.proceed();
        }
    } finally {
        position = oldPosition;
    }
}
</code></pre></div></td>
</tr>
<tr>
    <td>55</td><td>280.94</td><td>4</td><td>17</td>
    <td><div class="code-container"><pre><code class="language-java">private void registerHandlersWithAS(DeploymentUnit unit, String endpointClass, List&lt;String&gt; handlersToAdd) {
    WSEndpointHandlersMapping mapping = unit.getAttachment(WSAttachmentKeys.WS_ENDPOINT_HANDLERS_MAPPING_KEY);
    if (mapping == null) {
        mapping = new WSEndpointHandlersMapping();
        unit.putAttachment(WSAttachmentKeys.WS_ENDPOINT_HANDLERS_MAPPING_KEY, mapping);
    }
    Set&lt;String&gt; existingHandlers = mapping.getHandlers(endpointClass);
    if (existingHandlers == null) {
        existingHandlers = new HashSet&lt;String&gt;();
    } else {
        existingHandlers = new HashSet&lt;String&gt;(existingHandlers);
    }
    for (String handler : handlersToAdd) {
        existingHandlers.add(handler);
    }
    mapping.registerEndpointHandlers(endpointClass, existingHandlers);
}
</code></pre></div></td>
</tr>
<tr>
    <td>56</td><td>166.91</td><td>5</td><td>17</td>
    <td><div class="code-container"><pre><code class="language-java">private boolean isAnyOfHandlersRegistered(final DeploymentUnit unit, final String endpointClass, final List&lt;String&gt; handlers) {
    final WSEndpointHandlersMapping mapping = unit.getAttachment(WSAttachmentKeys.WS_ENDPOINT_HANDLERS_MAPPING_KEY);
    if (mapping == null) {
        return false;
    }
    final Set&lt;String&gt; existingHandlers = mapping.getHandlers(endpointClass);
    if (existingHandlers == null) {
        return false;
    }
    for (final String handler : handlers) {
        if (existingHandlers.contains(handler)) {
            return true;
        }
    }
    return false;
}
</code></pre></div></td>
</tr>
<tr>
    <td>57</td><td>307.67</td><td>1</td><td>14</td>
    <td><div class="code-container"><pre><code class="language-java">public void registerAttributes(ManagementResourceRegistration resourceRegistration) {
    resourceRegistration.registerReadWriteAttribute(HOST_NAME, null, new ReloadRequiredWriteAttributeHandler(HOST_NAME));
    resourceRegistration.registerReadWriteAttribute(ENVIRONMENT_URL, null, new ReloadRequiredWriteAttributeHandler(ENVIRONMENT_URL));
    resourceRegistration.registerReadWriteAttribute(DEFAULT_CONTEXT_PROPAGATION, null, new ReloadRequiredWriteAttributeHandler(DEFAULT_CONTEXT_PROPAGATION));
    resourceRegistration.registerReadWriteAttribute(ASYNC_REGISTRATION, null, new ReloadRequiredWriteAttributeHandler(ASYNC_REGISTRATION));
    resourceRegistration.registerReadOnlyAttribute(ENVIRONMENT, new OperationStepHandler() {

        @Override
        public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {
            ModelNode url = context.readResource(PathAddress.EMPTY_ADDRESS).getModel().get(ModelDescriptionConstants.URL);
            context.getResult().get(ModelDescriptionConstants.URL).set(url);
        }
    });
}
</code></pre></div></td>
</tr>
<tr>
    <td>58</td><td>276.12</td><td>2</td><td>13</td>
    <td><div class="code-container"><pre><code class="language-java">public UnifiedHandlerChainMetaData getHandlerChain() {
    List&lt;UnifiedHandlerMetaData&gt; handlers = new ArrayList&lt;UnifiedHandlerMetaData&gt;(2);
    if (enabled) {
        handlers.add(new UnifiedHandlerMetaData(BRIDGE_ENABLED_HANDLER_CLASS, BRIDGE_HANDLER_NAME, null, null, null, null));
        handlers.add(new UnifiedHandlerMetaData(WSAT_ENABLED_HANDLER_CLASS, WSAT_HANDLER_NAME, null, null, null, null));
    } else {
        handlers.add(new UnifiedHandlerMetaData(BRIDGE_DISABLED_HANDLER_CLASS, BRIDGE_HANDLER_NAME, null, null, null, null));
        handlers.add(new UnifiedHandlerMetaData(WSAT_DISABLED_HANDLER_CLASS, WSAT_HANDLER_NAME, null, null, null, null));
    }
    return new UnifiedHandlerChainMetaData(null, null, HANDLER_PROTOCOL_BINDINGS, handlers, false, HANDLER_CHAIN_ID);
}
</code></pre></div></td>
</tr>
<tr>
    <td>59</td><td>283.63</td><td>1</td><td>12</td>
    <td><div class="code-container"><pre><code class="language-java">public static void init() throws IOException {
    ClassFileServices service = new WeldClassFileServices(IndexUtils.createIndex(Alpha.class, AlphaImpl.class, AbstractAlpha.class, InnerClasses.class, Bravo.class, &quot;org/jboss/as/weld/discovery/vetoed/package-info.class&quot;, Inject.class, Named.class, Charlie.class), Thread.currentThread().getContextClassLoader());
    alpha = service.getClassFileInfo(Alpha.class.getName());
    abstractAlpha = service.getClassFileInfo(AbstractAlpha.class.getName());
    alphaImpl = service.getClassFileInfo(AlphaImpl.class.getName());
    innerInterface = service.getClassFileInfo(InnerClasses.InnerInterface.class.getName());
    bravo = service.getClassFileInfo(Bravo.class.getName());
    charlie = service.getClassFileInfo(Charlie.class.getName());
}
</code></pre></div></td>
</tr>
<tr>
    <td>60</td><td>305.25</td><td>3</td><td>10</td>
    <td><div class="code-container"><pre><code class="language-java"> static Iterable&lt;ContextInfo&gt; getContextDefinitions(OperationContext context, ModelNode model) throws IllegalArgumentException, OperationFailedException {
    Collection&lt;ContextInfo&gt; updatedContextDefinitions = new ArrayList&lt;&gt;(Arrays.asList(contextDefinitions));
    Collection&lt;EndpointInfo&gt; wsC11EndpointInfos = new ArrayList&lt;&gt;(Arrays.asList(wsC11));
    if (ASYNC_REGISTRATION.resolveModelAttribute(context, model).asBoolean() || Boolean.getBoolean(XTSSubsystemAdd.WSAT_ASYNC_REGISTRATION_PARAM_NAME)) {
        wsC11EndpointInfos.addAll(Arrays.asList(wsC11Async));
    }
    ContextInfo wsC11ContextInfo = new ContextInfo(WS_C11_CONTEXT_DEFINITION_NAME, wsC11EndpointInfos.toArray(new EndpointInfo[wsC11EndpointInfos.size()]));
    updatedContextDefinitions.add(wsC11ContextInfo);
    return updatedContextDefinitions;
}
</code></pre></div></td>
</tr>
<tr>
    <td>61</td><td>167.18</td><td>2</td><td>11</td>
    <td><div class="code-container"><pre><code class="language-java">public ExpressionFactory wrap(ExpressionFactory expressionFactory, ServletContext servletContext) {
    BeanManager beanManager = getBeanManager();
    if (beanManager == null) {
        return expressionFactory;
    }
    JspApplicationContext jspAppContext = JspFactory.getDefaultFactory().getJspApplicationContext(servletContext);
    jspAppContext.addELResolver(beanManager.getELResolver());
    jspAppContext.addELContextListener(Reflections.&lt;ELContextListener&gt;newInstance(&quot;org.jboss.weld.module.web.el.WeldELContextListener&quot;, getClass().getClassLoader()));
    return beanManager.wrapExpressionFactory(expressionFactory);
}
</code></pre></div></td>
</tr>
<tr>
    <td>62</td><td>169.46</td><td>2</td><td>10</td>
    <td><div class="code-container"><pre><code class="language-java">protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model) throws OperationFailedException {
    for (ContextInfo contextInfo : XTSSubsystemAdd.getContextDefinitions(context, model)) {
        String contextName = contextInfo.contextPath;
        context.removeService(WSServices.ENDPOINT_PUBLISH_SERVICE.append(contextName));
    }
    context.removeService(XTSServices.JBOSS_XTS_MAIN);
    context.removeService(XTSServices.JBOSS_XTS_TXBRIDGE_INBOUND_RECOVERY);
    context.removeService(XTSServices.JBOSS_XTS_TXBRIDGE_OUTBOUND_RECOVERY);
}
</code></pre></div></td>
</tr>
<tr>
    <td>63</td><td>88.0</td><td>3</td><td>11</td>
    <td><div class="code-container"><pre><code class="language-java">public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {
    final DeploymentUnit unit = phaseContext.getDeploymentUnit();
    final CompositeIndex compositeIndex = unit.getAttachment(Attachments.COMPOSITE_ANNOTATION_INDEX);
    if (compositeIndex == null) {
        return;
    }
    if (isTransactionalEndpointPresent(compositeIndex)) {
        addXTSModuleDependency(unit);
    }
}
</code></pre></div></td>
</tr>
<tr>
    <td>64</td><td>97.67</td><td>2</td><td>9</td>
    <td><div class="code-container"><pre><code class="language-java">private static String getTargetClassName(final AnnotationInstance annotationInstance) {
    final String fullName = annotationInstance.target().toString();
    final int lastDotIndex = fullName.lastIndexOf(&quot;.&quot;);
    if (lastDotIndex == -1) {
        return fullName;
    } else {
        return fullName.substring(lastDotIndex + 1);
    }
}
</code></pre></div></td>
</tr>
<tr>
    <td>65</td><td>74.23</td><td>3</td><td>9</td>
    <td><div class="code-container"><pre><code class="language-java">public boolean rejectMessage(Map&lt;QName, Object&gt; headers) {
    if (headers.containsKey(ArjunaConstants.WSARJ_ELEMENT_INSTANCE_IDENTIFIER_QNAME) || headers.containsKey(CoordinationConstants.WSCOOR_ELEMENT_COORDINATION_CONTEXT_QNAME)) {
        return false;
    }
    XtsAsLogger.ROOT_LOGGER.rejectingCallBecauseNotPartOfXtsTx();
    return true;
}
</code></pre></div></td>
</tr>
<tr>
    <td>66</td><td>152.29</td><td>2</td><td>7</td>
    <td><div class="code-container"><pre><code class="language-java">private UnifiedHandlerChainsMetaData buildHandlerChains(List&lt;String&gt; handlerClasses) {
    List&lt;UnifiedHandlerMetaData&gt; handlers = new ArrayList&lt;UnifiedHandlerMetaData&gt;();
    for (String handlerClass : handlerClasses) {
        handlers.add(new UnifiedHandlerMetaData(handlerClass, null, null, null, null, null));
    }
    return new UnifiedHandlerChainsMetaData(new UnifiedHandlerChainMetaData(null, null, null, handlers, false, null));
}
</code></pre></div></td>
</tr>
<tr>
    <td>67</td><td>105.49</td><td>2</td><td>7</td>
    <td><div class="code-container"><pre><code class="language-java">private Set&lt;String&gt; getDeploymentClasses(DeploymentUnit unit) {
    final Set&lt;String&gt; endpoints = new HashSet&lt;String&gt;();
    for (final String annotation : TransactionalAnnotation.TRANSACTIONAL_ANNOTATIONS) {
        addEndpointsToList(endpoints, ASHelper.getAnnotations(unit, DotName.createSimple(annotation)));
    }
    return endpoints;
}
</code></pre></div></td>
</tr>
<tr>
    <td>68</td><td>66.57</td><td>1</td><td>7</td>
    <td><div class="code-container"><pre><code class="language-java">protected void populateModel(ModelNode operation, ModelNode model) throws OperationFailedException {
    HOST_NAME.validateAndSet(operation, model);
    ENVIRONMENT_URL.validateAndSet(operation, model);
    DEFAULT_CONTEXT_PROPAGATION.validateAndSet(operation, model);
    ASYNC_REGISTRATION.validateAndSet(operation, model);
}
</code></pre></div></td>
</tr>
<tr>
    <td>69</td><td>30.0</td><td>3</td><td>8</td>
    <td><div class="code-container"><pre><code class="language-java">public synchronized void stop(final StopContext context) {
    if (xtsService != null) {
        try {
            xtsService.stop();
        } catch (Exception e) {
        }
    }
}
</code></pre></div></td>
</tr>
<tr>
    <td>70</td><td>100.0</td><td>1</td><td>5</td>
    <td><div class="code-container"><pre><code class="language-java">private void addXTSModuleDependency(final DeploymentUnit unit) {
    final ModuleLoader moduleLoader = Module.getBootModuleLoader();
    final ModuleSpecification moduleSpec = unit.getAttachment(Attachments.MODULE_SPECIFICATION);
    moduleSpec.addSystemDependency(new ModuleDependency(moduleLoader, XTS_MODULE, false, false, false, false));
}
</code></pre></div></td>
</tr>
<tr>
    <td>71</td><td>86.37</td><td>1</td><td>5</td>
    <td><div class="code-container"><pre><code class="language-java">public void initializeParsers(ExtensionParsingContext context) {
    context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.XTS_1_0.getUriString(), XTSSubsystemParser::new);
    context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.XTS_2_0.getUriString(), XTSSubsystemParser::new);
    context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.XTS_3_0.getUriString(), XTSSubsystemParser::new);
}
</code></pre></div></td>
</tr>
<tr>
    <td>72</td><td>108.42</td><td>2</td><td>4</td>
    <td><div class="code-container"><pre><code class="language-java"> static StandardResourceDescriptionResolver getResourceDescriptionResolver(final String keyPrefix) {
    String prefix = SUBSYSTEM_NAME + (keyPrefix == null ? &quot;&quot; : &quot;.&quot; + keyPrefix);
    return new StandardResourceDescriptionResolver(prefix, RESOURCE_NAME, XTSExtension.class.getClassLoader(), true, false);
}
</code></pre></div></td>
</tr>
<tr>
    <td>73</td><td>44.38</td><td>1</td><td>5</td>
    <td><div class="code-container"><pre><code class="language-java">public void start(final StartContext context) throws StartException {
    final XTSHandlersManager xtsHandlerManager = new XTSHandlersManager(isDefaultContextPropagation);
    handlerChainMetaData = xtsHandlerManager.getHandlerChain();
}
</code></pre></div></td>
</tr>
<tr>
    <td>74</td><td>28.07</td><td>1</td><td>5</td>
    <td><div class="code-container"><pre><code class="language-java">public void registerOperations(ManagementResourceRegistration registration) {
    super.registerOperations(registration);
    registration.registerOperationHandler(GenericSubsystemDescribeHandler.DEFINITION, GenericSubsystemDescribeHandler.INSTANCE);
}
</code></pre></div></td>
</tr>
<tr>
    <td>75</td><td>36.0</td><td>2</td><td>4</td>
    <td><div class="code-container"><pre><code class="language-java">public static T notNull(T value) {
    if (value == null)
        throw XtsAsLogger.ROOT_LOGGER.xtsServiceIsNotStarted();
    return value;
}
</code></pre></div></td>
</tr>
<tr>
    <td>76</td><td>33.0</td><td>1</td><td>4</td>
    <td><div class="code-container"><pre><code class="language-java">private void addDependency(ModuleSpecification moduleSpecification, ModuleLoader moduleLoader, String moduleIdentifier, boolean optional) {
    moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, moduleIdentifier, optional, false, true, false));
}
</code></pre></div></td>
</tr>
<tr>
    <td>77</td><td>22.46</td><td>1</td><td>4</td>
    <td><div class="code-container"><pre><code class="language-java">protected String getSubsystemXml() throws IOException {
    return readResource(String.format(&quot;subsystem-%s.xml&quot;, XTSExtension.CURRENT_MODEL_VERSION));
}
</code></pre></div></td>
</tr>
<tr>
    <td>78</td><td>34.87</td><td>1</td><td>3</td>
    <td><div class="code-container"><pre><code class="language-java">private BeansXml parseBeansXml(URL beansXmlFile, BeansXmlParser parser, final DeploymentUnit deploymentUnit) throws DeploymentUnitProcessingException {
    return parser.parse(beansXmlFile);
}
</code></pre></div></td>
</tr>
<tr>
    <td>79</td><td>11.61</td><td>1</td><td>4</td>
    <td><div class="code-container"><pre><code class="language-java">public void stop(final StopContext context) {
    weldTransactionServicesConsumer.accept(null);
}
</code></pre></div></td>
</tr>
<tr>
    <td>80</td><td>18.58</td><td>1</td><td>3</td>
    <td><div class="code-container"><pre><code class="language-java">public static void mark(DeploymentUnit unit) {
    unit.putAttachment(MARKER, new XTSDeploymentMarker());
}
</code></pre></div></td>
</tr>
<tr>
    <td>81</td><td>13.93</td><td>1</td><td>3</td>
    <td><div class="code-container"><pre><code class="language-java">public static ServiceName endpointServiceName(String name) {
    return JBOSS_XTS_ENDPOINT.append(name);
}
</code></pre></div></td>
</tr>
<tr>
    <td>82</td><td>11.61</td><td>1</td><td>3</td>
    <td><div class="code-container"><pre><code class="language-java">public void stop(final StopContext context) {
    handlerChainMetaData = null;
}
</code></pre></div></td>
</tr>
<tr>
    <td>83</td><td>8.0</td><td>1</td><td>3</td>
    <td><div class="code-container"><pre><code class="language-java">public Map&lt;ResourceRoot, ExplicitBeanArchiveMetadata&gt; getBeanArchiveMetadata() {
    return beanArchiveMetadata;
}
</code></pre></div></td>
</tr>
<tr>
    <td>84</td><td>2.0</td><td>1</td><td>4</td>
    <td><div class="code-container"><pre><code class="language-java">protected String getSubsystemXsdPath() {
    return &quot;schema/jboss-as-xts_3_0.xsd&quot;;
}
</code></pre></div></td>
</tr>
<tr>
    <td>85</td><td>4.0</td><td>1</td><td>3</td>
    <td><div class="code-container"><pre><code class="language-java">public void setStopServices(boolean stopServices) {
    this.stopServices = stopServices;
}
</code></pre></div></td>
</tr>
<tr>
    <td>86</td><td>3.0</td><td>1</td><td>3</td>
    <td><div class="code-container"><pre><code class="language-java">public static WSDeploymentBuilder getInstance() {
    return WSDeploymentBuilder.SINGLETON;
}
</code></pre></div></td>
</tr>
<tr>
    <td>87</td><td>2.0</td><td>1</td><td>3</td>
    <td><div class="code-container"><pre><code class="language-java">public String getName() {
    return name;
}
</code></pre></div></td>
</tr>
<tr>
    <td>88</td><td>4.75</td><td>1</td><td>2</td>
    <td><div class="code-container"><pre><code class="language-java">public static void pushCall() {
    nonTxStack.push(null);
}
</code></pre></div></td>
</tr>
<tr>
    <td>89</td><td>3.0</td><td>1</td><td>2</td>
    <td><div class="code-container"><pre><code class="language-java">public int size() {
    return this.functionName.size();
}
</code></pre></div></td>
</tr>
<tr>
    <td>90</td><td>23.22</td><td>1</td><td>1</td>
    <td><div class="code-container"><pre><code class="language-java">public QuintFunction&lt;I1, I2, I3, I4, I5, O&gt; sync(QuintFunction&lt;I1, I2, I3, I4, I5, O&gt; f) {
    return (a, b, c, d, e) -&gt; waitOn(async(f).apply(a, b, c, d, e));
}
</code></pre></div></td>
</tr>
<tr>
    <td>91</td><td>2.0</td><td>1</td><td>2</td>
    <td><div class="code-container"><pre><code class="language-java">public void ejbCreate() throws RemoteException, CreateException {
}
</code></pre></div></td>
</tr>
<tr>
    <td>92</td><td>12.0</td><td>1</td><td>1</td>
    <td><div class="code-container"><pre><code class="language-java">public void setDatum(Object datum) {
    this.datum = (TaskUpdated) datum;
}
</code></pre></div></td>
</tr>
<tr>
    <td>93</td><td>8.0</td><td>1</td><td>1</td>
    <td><div class="code-container"><pre><code class="language-java">public int getNumReduceTasks() {
    return getInt(JobContext.NUM_REDUCES, 1);
}
</code></pre></div></td>
</tr>
<tr>
    <td>94</td><td>6.34</td><td>1</td><td>1</td>
    <td><div class="code-container"><pre><code class="language-java"> static int nextLong() {
    return RANDOM.get().nextInt();
}
</code></pre></div></td>
</tr>
<tr>
    <td>95</td><td>4.75</td><td>1</td><td>1</td>
    <td><div class="code-container"><pre><code class="language-java"> void destroyMethod3() {
    this.destroyMethod3Called = true;
}
</code></pre></div></td>
</tr>
<tr>
    <td>96</td><td>3.0</td><td>1</td><td>1</td>
    <td><div class="code-container"><pre><code class="language-java">public EventType getEventType() {
    return EventType.JOB_SUBMITTED;
}
</code></pre></div></td>
</tr>
<tr>
    <td>97</td><td>2.0</td><td>1</td><td>1</td>
    <td><div class="code-container"><pre><code class="language-java">public long getRejectUploads() {
    return rejectedUploads.value();
}
</code></pre></div></td>
</tr>
    </tbody>
</table>

<script src="script.js"></script>
</body>
</html>
